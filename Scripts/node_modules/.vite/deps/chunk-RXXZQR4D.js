import {
  require_fast_deep_equal
} from "./chunk-5NNLBS7K.js";
import {
  Accent_default,
  Dark2_default,
  Delaunay,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  Set1_default,
  Set2_default,
  Set3_default,
  Symbol as Symbol2,
  albersUsa_default,
  albers_default,
  arc_default,
  area_default,
  area_default2,
  ascending,
  azimuthalEqualArea_default,
  azimuthalEquidistant_default,
  basisClosed_default2 as basisClosed_default,
  basisOpen_default,
  basis_default2 as basis_default,
  binary_default,
  bisectLeft,
  bisectRight,
  bisect_default,
  bisector,
  bounds_default,
  bundle_default,
  cardinalClosed_default,
  cardinalOpen_default,
  cardinal_default,
  category10_default,
  catmullRomClosed_default,
  catmullRomOpen_default,
  catmullRom_default,
  center_default,
  centroid_default,
  cluster_default,
  collide_default,
  conicConformal_default,
  conicEqualArea_default,
  conicEquidistant_default,
  deviation,
  dice_default,
  diverging,
  divergingLog,
  divergingPow,
  divergingSqrt,
  divergingSymlog,
  dsv_default,
  equalEarth_default,
  equirectangular_default,
  format,
  formatLocale,
  formatPrefix,
  formatSpecifier,
  gnomonic_default,
  graticule,
  hcl,
  hierarchy,
  hsl,
  identity,
  identity_default,
  implicit,
  intersection,
  interval_default,
  lab,
  line_default,
  linear,
  linearClosed_default,
  linear_default,
  link_default,
  locale_default,
  log,
  manyBody_default,
  max,
  mean,
  median,
  mercator_default,
  millisecond,
  min,
  monotoneX,
  monotoneY,
  naturalEarth1_default,
  natural_default,
  observable10_default,
  ordinal,
  orthographic_default,
  pack_default,
  partition_default,
  path,
  path_default,
  permute,
  piecewise,
  pow,
  precisionFixed_default,
  precisionPrefix_default,
  precisionRound_default,
  projection,
  quantile,
  quantile2,
  quantileSorted,
  quantize,
  range,
  resquarify_default,
  rgb,
  round_default,
  second,
  sequential,
  sequentialLog,
  sequentialPow,
  sequentialSqrt,
  sequentialSymlog,
  simulation_default,
  sliceDice_default,
  slice_default,
  sqrt,
  squarify_default,
  src_exports,
  stepAfter,
  stepBefore,
  step_default,
  stereographic_default,
  stratify_default,
  sum,
  symlog,
  threshold,
  tickFormat,
  tickStep,
  time,
  timeDay,
  timeFormat,
  timeHour,
  timeMinute,
  timeMonth,
  timeParse,
  timeSunday,
  timeYear,
  transverseMercator_default,
  tree_default,
  treemap_default,
  union,
  utcDay,
  utcFormat,
  utcHour,
  utcMinute,
  utcMonth,
  utcParse,
  utcSunday,
  utcTime,
  utcYear,
  value_default,
  x_default,
  y_default
} from "./chunk-VG2TALFG.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/json-stringify-pretty-compact/index.js
var require_json_stringify_pretty_compact = __commonJS({
  "node_modules/json-stringify-pretty-compact/index.js"(exports, module4) {
    "use strict";
    var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
    module4.exports = function stringify4(passedObj, options) {
      var indent, maxLength, replacer2;
      options = options || {};
      indent = JSON.stringify(
        [1],
        void 0,
        options.indent === void 0 ? 2 : options.indent
      ).slice(2, -3);
      maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
      replacer2 = options.replacer;
      return function _stringify(obj, currentIndent, reserved) {
        var end, index3, items, key2, keyPart, keys5, length3, nextIndent, prettified, start, string, value3;
        if (obj && typeof obj.toJSON === "function") {
          obj = obj.toJSON();
        }
        string = JSON.stringify(obj, replacer2);
        if (string === void 0) {
          return string;
        }
        length3 = maxLength - currentIndent.length - reserved;
        if (string.length <= length3) {
          prettified = string.replace(
            stringOrChar,
            function(match3, stringLiteral) {
              return stringLiteral || match3 + " ";
            }
          );
          if (prettified.length <= length3) {
            return prettified;
          }
        }
        if (replacer2 != null) {
          obj = JSON.parse(string);
          replacer2 = void 0;
        }
        if (typeof obj === "object" && obj !== null) {
          nextIndent = currentIndent + indent;
          items = [];
          index3 = 0;
          if (Array.isArray(obj)) {
            start = "[";
            end = "]";
            length3 = obj.length;
            for (; index3 < length3; index3++) {
              items.push(
                _stringify(obj[index3], nextIndent, index3 === length3 - 1 ? 0 : 1) || "null"
              );
            }
          } else {
            start = "{";
            end = "}";
            keys5 = Object.keys(obj);
            length3 = keys5.length;
            for (; index3 < length3; index3++) {
              key2 = keys5[index3];
              keyPart = JSON.stringify(key2) + ": ";
              value3 = _stringify(
                obj[key2],
                nextIndent,
                keyPart.length + (index3 === length3 - 1 ? 0 : 1)
              );
              if (value3 !== void 0) {
                items.push(keyPart + value3);
              }
            }
          }
          if (items.length > 0) {
            return [start, indent + items.join(",\n" + nextIndent), end].join(
              "\n" + currentIndent
            );
          }
        }
        return string;
      }(passedObj, "", 0);
    };
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports, module4) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type3) {
        return type3 != null && obj instanceof type3;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype2, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype2 = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve2, reject) {
              parent2.then(function(value3) {
                resolve2(_clone(value3, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype2 == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype2);
              proto = prototype2;
            }
          }
          if (circular) {
            var index3 = allParents.indexOf(parent2);
            if (index3 != -1) {
              return allChildren[index3];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value3, key2) {
              var keyChild = _clone(key2, depth2 - 1);
              var valueChild = _clone(value3, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value3) {
              var entryChild = _clone(value3, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols4 = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols4.length; i++) {
              var symbol2 = symbols4[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol2);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol2] = _clone(parent2[symbol2], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol2, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re2) {
        var flags = "";
        if (re2.global) flags += "g";
        if (re2.ignoreCase) flags += "i";
        if (re2.multiline) flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module4 === "object" && module4.exports) {
      module4.exports = clone;
    }
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module4) {
    "use strict";
    module4.exports = function(data3, opts2) {
      if (!opts2) opts2 = {};
      if (typeof opts2 === "function") opts2 = { cmp: opts2 };
      var cycles = typeof opts2.cycles === "boolean" ? opts2.cycles : false;
      var cmp2 = opts2.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b2) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b2, value: node[b2] };
            return f(aobj, bobj);
          };
        };
      }(opts2.cmp);
      var seen = [];
      return function stringify4(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i) out += ",";
            out += stringify4(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys5 = Object.keys(node).sort(cmp2 && cmp2(node));
        out = "";
        for (i = 0; i < keys5.length; i++) {
          var key2 = keys5[i];
          var value3 = stringify4(node[key2]);
          if (!value3) continue;
          if (out) out += ",";
          out += JSON.stringify(key2) + ":" + value3;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data3);
    };
  }
});

// node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/fast-json-patch/module/helpers.mjs
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3) if (b3.hasOwnProperty(p)) d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key2) {
  return _hasOwnProperty.call(obj, key2);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k2 = 0; k2 < keys_1.length; k2++) {
      keys_1[k2] = "" + k2;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys5 = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys5.push(i);
    }
  }
  return keys5;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path3) {
  if (path3.indexOf("/") === -1 && path3.indexOf("~") === -1)
    return path3;
  return path3.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path3) {
  return path3.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key2 in args) {
    var value3 = typeof args[key2] === "object" ? JSON.stringify(args[key2], null, 2) : args[key2];
    if (typeof value3 !== "undefined") {
      messageParts.push(key2 + ": " + value3);
    }
  }
  return messageParts.join("\n");
}
var PatchError = (
  /** @class */
  function(_super) {
    __extends(PatchError2, _super);
    function PatchError2(message, name4, index3, operation, tree) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name4, index: index3, operation, tree })) || this;
      _this.name = name4;
      _this.index = index3;
      _this.operation = operation;
      _this.tree = tree;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      _this.message = patchErrorMessageFormatter(message, { name: name4, index: index3, operation, tree });
      return _this;
    }
    return PatchError2;
  }(Error)
);

// node_modules/fast-json-patch/module/core.mjs
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key2, document2) {
    obj[key2] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key2, document2) {
    var removed = obj[key2];
    delete obj[key2];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key2, document2) {
    var removed = obj[key2];
    obj[key2] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key2, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key2, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key2, document2) {
    return { newDocument: document2, test: _areEquals(obj[key2], this.value) };
  },
  _get: function(obj, key2, document2) {
    this.value = obj[key2];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index3) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index3 === void 0) {
    index3 = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index3, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index3, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path3 = operation.path || "";
    var keys5 = path3.split("/");
    var obj = document2;
    var t2 = 1;
    var len = keys5.length;
    var existingPathFragment = void 0;
    var key2 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key2 = keys5[t2];
      if (key2 && key2.indexOf("~") != -1) {
        key2 = unescapePathComponent(key2);
      }
      if (banPrototypeModifications && (key2 == "__proto__" || key2 == "prototype" && t2 > 0 && keys5[t2 - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key2] === void 0) {
            existingPathFragment = keys5.slice(0, t2).join("/");
          } else if (t2 == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t2++;
      if (Array.isArray(obj)) {
        if (key2 === "-") {
          key2 = obj.length;
        } else {
          if (validateOperation && !isInteger(key2)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index3, operation, document2);
          } else if (isInteger(key2)) {
            key2 = ~~key2;
          }
        }
        if (t2 >= len) {
          if (validateOperation && operation.op === "add" && key2 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index3, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key2, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index3, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t2 >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key2, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index3, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key2];
      if (validateOperation && t2 < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index3, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch2, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch2)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch2.length);
  for (var i = 0, length_1 = patch2.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch2[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index3) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index3, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index3, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index3, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index3, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index3, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index3, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index3, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index3, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index3, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index3, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index3, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error2 = validate([existingValue], document2);
      if (error2 && error2.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index3, operation, document2);
      }
    }
  }
}
function validate(sequence3, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence3)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence3), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence3.length; i++) {
        externalValidator(sequence3[i], i, document2, void 0);
      }
    }
  } catch (e2) {
    if (e2 instanceof JsonPatchError) {
      return e2;
    } else {
      throw e2;
    }
  }
}
function _areEquals(a, b2) {
  if (a === b2)
    return true;
  if (a && b2 && typeof a == "object" && typeof b2 == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b2), i, length3, key2;
    if (arrA && arrB) {
      length3 = a.length;
      if (length3 != b2.length)
        return false;
      for (i = length3; i-- !== 0; )
        if (!_areEquals(a[i], b2[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys5 = Object.keys(a);
    length3 = keys5.length;
    if (length3 !== Object.keys(b2).length)
      return false;
    for (i = length3; i-- !== 0; )
      if (!b2.hasOwnProperty(keys5[i]))
        return false;
    for (i = length3; i-- !== 0; ) {
      key2 = keys5[i];
      if (!_areEquals(a[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a !== a && b2 !== b2;
}

// node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mirror2(obj) {
      this.observers = /* @__PURE__ */ new Map();
      this.obj = obj;
    }
    return Mirror2;
  }()
);
var ObserverInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ObserverInfo2(callback, observer) {
      this.callback = callback;
      this.observer = observer;
    }
    return ObserverInfo2;
  }()
);
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp2 = observer.patches;
  if (temp2.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp2);
    }
  }
  return temp2;
}
function _generate(mirror, obj, patches, path3, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t2 = oldKeys.length - 1; t2 >= 0; t2--) {
    var key2 = oldKeys[t2];
    var oldVal = mirror[key2];
    if (hasOwnProperty(obj, key2) && !(obj[key2] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key2];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path3 + "/" + escapePathComponent(key2), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path3 + "/" + escapePathComponent(key2) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path: path3, value: mirror });
      }
      patches.push({ op: "replace", path: path3, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t2 = 0; t2 < newKeys.length; t2++) {
    var key2 = newKeys[t2];
    if (!hasOwnProperty(mirror, key2) && obj[key2] !== void 0) {
      patches.push({ op: "add", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(obj[key2]) });
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/fast-json-patch/index.mjs
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});

// node_modules/vega-embed/build/vega-embed.module.js
var import_json_stringify_pretty_compact = __toESM(require_json_stringify_pretty_compact());

// node_modules/vega/build/vega.module.js
var vega_module_exports = {};
__export(vega_module_exports, {
  Bounds: () => Bounds,
  CanvasHandler: () => CanvasHandler,
  CanvasRenderer: () => CanvasRenderer,
  DATE: () => DATE,
  DAY: () => DAY,
  DAYOFYEAR: () => DAYOFYEAR,
  Dataflow: () => Dataflow,
  Debug: () => Debug,
  Error: () => Error$1,
  EventStream: () => EventStream,
  Gradient: () => Gradient,
  GroupItem: () => GroupItem,
  HOURS: () => HOURS,
  Handler: () => Handler,
  HybridHandler: () => HybridHandler,
  HybridRenderer: () => HybridRenderer,
  Info: () => Info,
  Item: () => Item,
  MILLISECONDS: () => MILLISECONDS,
  MINUTES: () => MINUTES,
  MONTH: () => MONTH,
  Marks: () => Marks,
  MultiPulse: () => MultiPulse,
  None: () => None,
  Operator: () => Operator,
  Parameters: () => Parameters,
  Pulse: () => Pulse,
  QUARTER: () => QUARTER,
  RenderType: () => RenderType,
  Renderer: () => Renderer,
  ResourceLoader: () => ResourceLoader,
  SECONDS: () => SECONDS,
  SVGHandler: () => SVGHandler,
  SVGRenderer: () => SVGRenderer,
  SVGStringRenderer: () => SVGStringRenderer,
  Scenegraph: () => Scenegraph,
  TIME_UNITS: () => TIME_UNITS,
  Transform: () => Transform,
  View: () => View,
  WEEK: () => WEEK,
  Warn: () => Warn,
  YEAR: () => YEAR,
  accessor: () => accessor,
  accessorFields: () => accessorFields,
  accessorName: () => accessorName,
  array: () => array,
  ascending: () => ascending2,
  bandwidthNRD: () => estimateBandwidth,
  bin: () => bin2,
  bootstrapCI: () => bootstrapCI,
  boundClip: () => boundClip,
  boundContext: () => boundContext,
  boundItem: () => boundItem,
  boundMark: () => boundMark,
  boundStroke: () => boundStroke,
  changeset: () => changeset,
  clampRange: () => clampRange,
  codegenExpression: () => codegen,
  compare: () => compare2,
  constant: () => constant,
  cumulativeLogNormal: () => cumulativeLogNormal,
  cumulativeNormal: () => cumulativeNormal,
  cumulativeUniform: () => cumulativeUniform,
  dayofyear: () => dayofyear,
  debounce: () => debounce,
  defaultLocale: () => defaultLocale,
  definition: () => definition,
  densityLogNormal: () => densityLogNormal,
  densityNormal: () => densityNormal,
  densityUniform: () => densityUniform,
  domChild: () => domChild,
  domClear: () => domClear,
  domCreate: () => domCreate,
  domFind: () => domFind,
  dotbin: () => dotbin,
  error: () => error,
  expressionFunction: () => expressionFunction,
  extend: () => extend,
  extent: () => extent,
  extentIndex: () => extentIndex,
  falsy: () => falsy,
  fastmap: () => fastmap,
  field: () => field,
  flush: () => flush,
  font: () => font,
  fontFamily: () => fontFamily,
  fontSize: () => fontSize,
  format: () => format2,
  formatLocale: () => numberFormatDefaultLocale,
  formats: () => formats,
  hasOwnProperty: () => has,
  id: () => id,
  identity: () => identity2,
  inferType: () => inferType,
  inferTypes: () => inferTypes,
  ingest: () => ingest$1,
  inherits: () => inherits,
  inrange: () => inrange,
  interpolate: () => interpolate,
  interpolateColors: () => interpolateColors,
  interpolateRange: () => interpolateRange,
  intersect: () => intersect,
  intersectBoxLine: () => intersectBoxLine,
  intersectPath: () => intersectPath,
  intersectPoint: () => intersectPoint,
  intersectRule: () => intersectRule,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isFunction: () => isFunction,
  isIterable: () => isIterable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isTuple: () => isTuple,
  key: () => key,
  lerp: () => lerp,
  lineHeight: () => lineHeight,
  loader: () => loader,
  locale: () => locale,
  logger: () => logger,
  lruCache: () => lruCache,
  markup: () => markup,
  merge: () => merge,
  mergeConfig: () => mergeConfig,
  multiLineOffset: () => multiLineOffset,
  one: () => one,
  pad: () => pad,
  panLinear: () => panLinear,
  panLog: () => panLog,
  panPow: () => panPow,
  panSymlog: () => panSymlog,
  parse: () => parse6,
  parseExpression: () => parser,
  parseSelector: () => eventSelector,
  path: () => path,
  pathCurves: () => curves,
  pathEqual: () => pathEqual,
  pathParse: () => parse4,
  pathRectangle: () => vg_rect,
  pathRender: () => pathRender,
  pathSymbols: () => symbols2,
  pathTrail: () => vg_trail,
  peek: () => peek,
  point: () => point2,
  projection: () => projection2,
  quantileLogNormal: () => quantileLogNormal,
  quantileNormal: () => quantileNormal,
  quantileUniform: () => quantileUniform,
  quantiles: () => quantiles,
  quantizeInterpolator: () => quantizeInterpolator,
  quarter: () => quarter,
  quartiles: () => quartiles,
  random: () => random,
  randomInteger: () => integer,
  randomKDE: () => kde,
  randomLCG: () => lcg,
  randomLogNormal: () => lognormal,
  randomMixture: () => mixture,
  randomNormal: () => gaussian,
  randomUniform: () => uniform,
  read: () => read,
  regressionConstant: () => constant2,
  regressionExp: () => exp2,
  regressionLinear: () => linear2,
  regressionLoess: () => loess,
  regressionLog: () => log3,
  regressionPoly: () => poly,
  regressionPow: () => pow3,
  regressionQuad: () => quad,
  renderModule: () => renderModule,
  repeat: () => repeat,
  resetDefaultLocale: () => resetDefaultLocale,
  resetSVGClipId: () => resetSVGClipId,
  resetSVGDefIds: () => resetSVGDefIds,
  responseType: () => responseType,
  runtimeContext: () => context2,
  sampleCurve: () => sampleCurve,
  sampleLogNormal: () => sampleLogNormal,
  sampleNormal: () => sampleNormal,
  sampleUniform: () => sampleUniform,
  scale: () => scale,
  sceneEqual: () => sceneEqual,
  sceneFromJSON: () => sceneFromJSON,
  scenePickVisit: () => pickVisit,
  sceneToJSON: () => sceneToJSON,
  sceneVisit: () => visit,
  sceneZOrder: () => zorder,
  scheme: () => scheme,
  serializeXML: () => serializeXML,
  setHybridRendererOptions: () => setHybridRendererOptions,
  setRandom: () => setRandom,
  span: () => span,
  splitAccessPath: () => splitAccessPath,
  stringValue: () => $,
  textMetrics: () => textMetrics,
  timeBin: () => bin,
  timeFloor: () => timeFloor,
  timeFormatLocale: () => timeFormatDefaultLocale,
  timeInterval: () => timeInterval,
  timeOffset: () => timeOffset,
  timeSequence: () => timeSequence,
  timeUnitSpecifier: () => timeUnitSpecifier,
  timeUnits: () => timeUnits,
  toBoolean: () => toBoolean,
  toDate: () => toDate,
  toNumber: () => toNumber,
  toSet: () => toSet,
  toString: () => toString,
  transform: () => transform,
  transforms: () => transforms,
  truncate: () => truncate,
  truthy: () => truthy,
  tupleid: () => tupleid,
  typeParsers: () => typeParsers,
  utcFloor: () => utcFloor,
  utcInterval: () => utcInterval,
  utcOffset: () => utcOffset,
  utcSequence: () => utcSequence,
  utcdayofyear: () => utcdayofyear,
  utcquarter: () => utcquarter,
  utcweek: () => utcweek,
  version: () => version,
  visitArray: () => visitArray,
  week: () => week,
  writeConfig: () => writeConfig,
  zero: () => zero,
  zoomLinear: () => zoomLinear,
  zoomLog: () => zoomLog,
  zoomPow: () => zoomPow,
  zoomSymlog: () => zoomSymlog
});

// node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path3) {
  return path3.length === 1 ? get1(path3[0]) : getN(path3);
}
var get1 = (field3) => function(obj) {
  return obj[field3];
};
var getN = (path3) => {
  const len = path3.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path3[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path3 = [], n = p.length;
  let q = null, b2 = 0, s = "", i, j, c;
  p = p + "";
  function push2() {
    path3.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c = p[j];
    if (c === "\\") {
      s += p.substring(i, j++);
      i = j;
    } else if (c === q) {
      push2();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c === '"') {
      i = j + 1;
      q = c;
    } else if (i === b2 && c === "'") {
      i = j + 1;
      q = c;
    } else if (c === "." && !b2) {
      if (j > i) {
        push2();
      } else {
        i = j + 1;
      }
    } else if (c === "[") {
      if (j > i) push2();
      b2 = i = j + 1;
    } else if (c === "]") {
      if (!b2) error("Access path missing open bracket: " + p);
      if (b2 > 0) push2();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2) error("Access path missing closing bracket: " + p);
  if (q) error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push2();
  }
  return path3;
}
function field(field3, name4, opt) {
  const path3 = splitAccessPath(field3);
  field3 = path3.length === 1 ? path3[0] : field3;
  return accessor((opt && opt.get || getter)(path3), [field3], name4 || field3);
}
var id = field("id");
var identity2 = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
function log$1(method2, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method2].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method2) {
  let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : log$1;
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1) handler(method2 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn) handler(method2 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info) handler(method2 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug) handler(method2 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig() {
  for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
    configs[_key] = arguments[_key];
  }
  return configs.reduce((out, source4) => {
    for (const key2 in source4) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source4.signals);
      } else {
        const r2 = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source4[key2], r2);
      }
    }
    return out;
  }, {});
}
function writeConfig(output3, key2, value3, recurse2) {
  if (!isLegalKey(key2)) return;
  let k2, o;
  if (isObject(value3) && !isArray(value3)) {
    o = isObject(output3[key2]) ? output3[key2] : output3[key2] = {};
    for (k2 in value3) {
      if (recurse2 && (recurse2 === true || recurse2[k2])) {
        writeConfig(o, k2, value3[k2]);
      } else if (isLegalKey(k2)) {
        o[k2] = value3[k2];
      }
    }
  } else {
    output3[key2] = value3;
  }
}
function mergeNamed(a, b2) {
  if (a == null) return b2;
  const map2 = {}, out = [];
  function add5(_) {
    if (!map2[_.name]) {
      map2[_.name] = 1;
      out.push(_);
    }
  }
  b2.forEach(add5);
  a.forEach(add5);
  return out;
}
function peek(array4) {
  return array4[array4.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign2) => (x2) => sign2 * Math.exp(x2);
var log2 = (sign2) => (x2) => Math.log(sign2 * x2);
var symlog2 = (c) => (x2) => Math.sign(x2) * Math.log1p(Math.abs(x2 / c));
var symexp = (c) => (x2) => Math.sign(x2) * Math.expm1(Math.abs(x2)) * c;
var pow2 = (exponent) => (x2) => x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
function pan(domain4, delta, lift, ground) {
  const d0 = lift(domain4[0]), d1 = lift(peek(domain4)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain4, delta) {
  return pan(domain4, delta, toNumber, identity2);
}
function panLog(domain4, delta) {
  var sign2 = Math.sign(domain4[0]);
  return pan(domain4, delta, log2(sign2), exp(sign2));
}
function panPow(domain4, delta, exponent) {
  return pan(domain4, delta, pow2(exponent), pow2(1 / exponent));
}
function panSymlog(domain4, delta, constant3) {
  return pan(domain4, delta, symlog2(constant3), symexp(constant3));
}
function zoom(domain4, anchor, scale6, lift, ground) {
  const d0 = lift(domain4[0]), d1 = lift(peek(domain4)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale6), ground(da + (d1 - da) * scale6)];
}
function zoomLinear(domain4, anchor, scale6) {
  return zoom(domain4, anchor, scale6, toNumber, identity2);
}
function zoomLog(domain4, anchor, scale6) {
  const sign2 = Math.sign(domain4[0]);
  return zoom(domain4, anchor, scale6, log2(sign2), exp(sign2));
}
function zoomPow(domain4, anchor, scale6, exponent) {
  return zoom(domain4, anchor, scale6, pow2(exponent), pow2(1 / exponent));
}
function zoomSymlog(domain4, anchor, scale6, constant3) {
  return zoom(domain4, anchor, scale6, symlog2(constant3), symexp(constant3));
}
function quarter(date) {
  return 1 + ~~(new Date(date).getMonth() / 3);
}
function utcquarter(date) {
  return 1 + ~~(new Date(date).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range6, min4, max4) {
  let lo = range6[0], hi = range6[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max4 - min4 ? [min4, max4] : [lo = Math.min(Math.max(lo, min4), max4 - span2), lo + span2];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare2(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get6 = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null) return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get6.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get6.length === 0 ? null : accessor(gen(get6, ord), Object.keys(fmap));
}
var ascending2 = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field3, order) => function(a, b2) {
  return ascending2(field3(a), field3(b2)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a, b2) {
    let f, c = 0, i = -1;
    while (c === 0 && ++i < n) {
      f = fields[i];
      c = ascending2(f(a), f(b2));
    }
    return c * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e2) => {
    if (tid) clearTimeout(tid);
    tid = setTimeout(() => (handler(e2), tid = null), delay);
  };
}
function extend(_) {
  for (let x2, k2, i = 1, len = arguments.length; i < len; ++i) {
    x2 = arguments[i];
    for (k2 in x2) {
      _[k2] = x2[k2];
    }
  }
  return _;
}
function extent(array4, f) {
  let i = 0, n, v, min4, max4;
  if (array4 && (n = array4.length)) {
    if (f == null) {
      for (v = array4[i]; i < n && (v == null || v !== v); v = array4[++i]) ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = array4[i];
        if (v != null) {
          if (v < min4) min4 = v;
          if (v > max4) max4 = v;
        }
      }
    } else {
      for (v = f(array4[i]); i < n && (v == null || v !== v); v = f(array4[++i])) ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = f(array4[i]);
        if (v != null) {
          if (v < min4) min4 = v;
          if (v > max4) max4 = v;
        }
      }
    }
  }
  return [min4, max4];
}
function extentIndex(array4, f) {
  const n = array4.length;
  let i = -1, a, b2, c, u, v;
  if (f == null) {
    while (++i < n) {
      b2 = array4[i];
      if (b2 != null && b2 >= b2) {
        a = c = b2;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = array4[i];
      if (b2 != null) {
        if (a > b2) {
          a = b2;
          u = i;
        }
        if (c < b2) {
          c = b2;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b2 = f(array4[i], i, array4);
      if (b2 != null && b2 >= b2) {
        a = c = b2;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = f(array4[i], i, array4);
      if (b2 != null) {
        if (a > b2) {
          a = b2;
          u = i;
        }
        if (c < b2) {
          c = b2;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
function has(object2, property2) {
  return Object.hasOwn(object2, property2);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test2;
  function has$1(key2) {
    return has(obj, key2) && obj[key2] !== NULL;
  }
  const map2 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key2) {
      return has$1(key2) ? obj[key2] : void 0;
    },
    set(key2, value3) {
      if (!has$1(key2)) {
        ++map2.size;
        if (obj[key2] === NULL) --map2.empty;
      }
      obj[key2] = value3;
      return this;
    },
    delete(key2) {
      if (has$1(key2)) {
        --map2.size;
        ++map2.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map2.size = map2.empty = 0;
      map2.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map2;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key2 in obj) {
        const value3 = obj[key2];
        if (value3 !== NULL && (!test2 || !test2(value3))) {
          next[key2] = value3;
          ++size;
        }
      }
      map2.size = size;
      map2.empty = 0;
      map2.object = obj = next;
    }
  };
  if (input) Object.keys(input).forEach((key2) => {
    map2.set(key2, input[key2]);
  });
  return map2;
}
function flush(range6, value3, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0) return center;
  const t2 = +threshold2;
  let a = range6[0], b2 = peek(range6), l;
  if (b2 < a) {
    l = a;
    a = b2;
    b2 = l;
  }
  l = Math.abs(value3 - a);
  const r2 = Math.abs(b2 - value3);
  return l < r2 && l <= t2 ? left : r2 <= t2 ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value3, range6, left, right) {
  let r0 = range6[0], r1 = range6[range6.length - 1], t2;
  if (r0 > r1) {
    t2 = r0;
    r0 = r1;
    r1 = t2;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value3 : r0 < value3) && (right ? value3 <= r1 : value3 < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map2 = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get6 = map2(fields[0]);
    fn = function(_) {
      return "" + get6(_);
    };
  } else {
    const get6 = fields.map(map2);
    fn = function(_) {
      let s = "" + get6[0](_), i = 0;
      while (++i < len) s += "|" + get6[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array4, frac) {
  const lo = array4[0], hi = peek(array4), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key2, value3) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value3;
  };
  clear2();
  return {
    clear: clear2,
    has: (key2) => has(curr, key2) || has(prev, key2),
    get: (key2) => has(curr, key2) ? curr[key2] : has(prev, key2) ? update3(key2, prev[key2]) : void 0,
    set: (key2, value3) => has(curr, key2) ? curr[key2] = value3 : update3(key2, value3)
  };
}
function merge(compare5, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1) return array0;
  if (!n0) return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare5(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0) s += str;
  return s;
}
function pad(str, length3, padchar, align2) {
  const c = padchar || " ", s = str + "", n = length3 - s.length;
  return n <= 0 ? s : align2 === "left" ? repeat(c, n) + s : align2 === "center" ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
}
function span(array4) {
  return array4 && peek(array4) - array4[0] || 0;
}
function $(x2) {
  return isArray(x2) ? "[" + x2.map($) + "]" : isObject(x2) || isString(x2) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(x2).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : x2;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser4) {
  parser4 = parser4 || defaultParser;
  return _ == null || _ === "" ? null : parser4(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i) s[_[i]] = true;
  return s;
}
function truncate(str, length3, align2, ellipsis) {
  const e2 = ellipsis != null ? ellipsis : "…", s = str + "", n = s.length, l = Math.max(0, length3 - e2.length);
  return n <= length3 ? s : align2 === "left" ? e2 + s.slice(n - l) : align2 === "center" ? s.slice(0, Math.ceil(l / 2)) + e2 + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e2;
}
function visitArray(array4, filter3, visitor) {
  if (array4) {
    if (filter3) {
      const n = array4.length;
      for (let i = 0; i < n; ++i) {
        const t2 = filter3(array4[i]);
        if (t2) visitor(t2, i, array4);
      }
    } else {
      array4.forEach(visitor);
    }
  }
}

// node_modules/topojson-client/src/identity.js
function identity_default2(x2) {
  return x2;
}

// node_modules/topojson-client/src/transform.js
function transform_default(transform4) {
  if (transform4 == null) return identity_default2;
  var x02, y02, kx2 = transform4.scale[0], ky = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i) x02 = y02 = 0;
    var j = 2, n = input.length, output3 = new Array(n);
    output3[0] = (x02 += input[0]) * kx2 + dx;
    output3[1] = (y02 += input[1]) * ky + dy;
    while (j < n) output3[j] = input[j], ++j;
    return output3;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default(array4, n) {
  var t2, j = array4.length, i = j - n;
  while (i < --j) t2 = array4[i], array4[i++] = array4[j], array4[j] = t2;
}

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  }) } : feature(topology, o);
}
function feature(topology, o) {
  var id2 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id2 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id2, properties, geometry } : { type: "Feature", id: id2, bbox, properties, geometry };
}
function object(topology, o) {
  var transformPoint = transform_default(topology.transform), arcs = topology.arcs;
  function arc4(i, points2) {
    if (points2.length) points2.pop();
    for (var a = arcs[i < 0 ? ~i : i], k2 = 0, n = a.length; k2 < n; ++k2) {
      points2.push(transformPoint(a[k2], k2));
    }
    if (i < 0) reverse_default(points2, n);
  }
  function point5(p) {
    return transformPoint(p);
  }
  function line4(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i) arc4(arcs2[i], points2);
    if (points2.length < 2) points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line4(arcs2);
    while (points2.length < 4) points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type3 = o2.type, coordinates;
    switch (type3) {
      case "GeometryCollection":
        return { type: type3, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point5(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point5);
        break;
      case "LineString":
        coordinates = line4(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line4);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type: type3, coordinates };
  }
  return geometry(o);
}

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc4 = topology.arcs[i < 0 ? ~i : i], t2;
    if (arc4.length < 3 && !arc4[1][0] && !arc4[1][1]) {
      t2 = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t2;
    }
  });
  arcs.forEach(function(i) {
    var e2 = ends(i), start = e2[0], end = e2[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc4 = topology.arcs[i < 0 ? ~i : i], p0 = arc4[0], p1;
    if (topology.transform) p1 = [0, 0], arc4.forEach(function(dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });
    else p1 = arc4[arc4.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }
  function flush2(fragmentByEnd2, fragmentByStart2) {
    for (var k2 in fragmentByEnd2) {
      var f = fragmentByEnd2[k2];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush2(fragmentByEnd, fragmentByStart);
  flush2(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter3) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object2, filter3);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter3) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter3 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter3(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
  });
  return arcs;
}

// node_modules/vega-time/build/vega-time.module.js
var YEAR = "year";
var QUARTER = "quarter";
var MONTH = "month";
var WEEK = "week";
var DATE = "date";
var DAY = "day";
var DAYOFYEAR = "dayofyear";
var HOURS = "hours";
var MINUTES = "minutes";
var SECONDS = "seconds";
var MILLISECONDS = "milliseconds";
var TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
var UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = array(units).slice(), m = {};
  if (!u.length) error("Missing time unit.");
  u.forEach((unit) => {
    if (has(UNITS, unit)) {
      m[unit] = 1;
    } else {
      error(`Invalid time unit: ${unit}.`);
    }
  });
  const numTypes = (m[WEEK] || m[DAY] ? 1 : 0) + (m[QUARTER] || m[MONTH] || m[DATE] ? 1 : 0) + (m[DAYOFYEAR] ? 1 : 0);
  if (numTypes > 1) {
    error(`Incompatible time units: ${units}`);
  }
  u.sort((a, b2) => UNITS[a] - UNITS[b2]);
  return u;
}
var defaultSpecifiers = {
  [YEAR]: "%Y ",
  [QUARTER]: "Q%q ",
  [MONTH]: "%b ",
  [DATE]: "%d ",
  [WEEK]: "W%U ",
  [DAY]: "%a ",
  [DAYOFYEAR]: "%j ",
  [HOURS]: "%H:00",
  [MINUTES]: "00:%M",
  [SECONDS]: ":%S",
  [MILLISECONDS]: ".%L",
  [`${YEAR}-${MONTH}`]: "%Y-%m ",
  [`${YEAR}-${MONTH}-${DATE}`]: "%Y-%m-%d ",
  [`${HOURS}-${MINUTES}`]: "%H:%M"
};
function timeUnitSpecifier(units, specifiers) {
  const s = extend({}, defaultSpecifiers, specifiers), u = timeUnits(units), n = u.length;
  let fmt = "", start = 0, end, key2;
  for (start = 0; start < n; ) {
    for (end = u.length; end > start; --end) {
      key2 = u.slice(start, end).join("-");
      if (s[key2] != null) {
        fmt += s[key2];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
var t0 = /* @__PURE__ */ new Date();
function localYear(y2) {
  t0.setFullYear(y2);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setHours(0, 0, 0, 0);
  return t0;
}
function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return timeDay.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return timeSunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y2) {
  return localYear(y2).getDay();
}
function localDate(y2, m, d, H, M, S, L) {
  if (0 <= y2 && y2 < 100) {
    const date = new Date(-1, m, d, H, M, S, L);
    date.setFullYear(y2);
    return date;
  }
  return new Date(y2, m, d, H, M, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y2 - 1, d);
}
function utcWeekNum(d) {
  const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y2 - 1, d);
}
function utcFirst(y2) {
  t0.setTime(Date.UTC(y2, 0, 1));
  return t0.getUTCDay();
}
function utcDate(y2, m, d, H, M, S, L) {
  if (0 <= y2 && y2 < 100) {
    const date = new Date(Date.UTC(-1, m, d, H, M, S, L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(y2, m, d, H, M, S, L));
}
function floor(units, step, get6, inv, newDate) {
  const s = step || 1, b2 = peek(units), _ = (unit, p, key2) => {
    key2 = key2 || unit;
    return getUnit(get6[key2], inv[key2], unit === b2 && s, p);
  };
  const t2 = /* @__PURE__ */ new Date(), u = toSet(units), y2 = u[YEAR] ? _(YEAR) : constant(2012), m = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : zero, d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : one, H = u[HOURS] ? _(HOURS) : zero, M = u[MINUTES] ? _(MINUTES) : zero, S = u[SECONDS] ? _(SECONDS) : zero, L = u[MILLISECONDS] ? _(MILLISECONDS) : zero;
  return function(v) {
    t2.setTime(+v);
    const year = y2(t2);
    return newDate(year, m(t2), d(t2, year), H(t2), M(t2), S(t2), L(t2));
  };
}
function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y2) => phase + step * Math.floor((f(d, y2) - phase) / step) : (d, y2) => step * Math.floor(f(d, y2) / step);
  return inv ? (d, y2) => inv(u(d, y2), y2) : u;
}
function weekday(week2, day, firstDay) {
  return day + week2 * 7 - (firstDay + 6) % 7;
}
var localGet = {
  [YEAR]: (d) => d.getFullYear(),
  [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH]: (d) => d.getMonth(),
  [DATE]: (d) => d.getDate(),
  [HOURS]: (d) => d.getHours(),
  [MINUTES]: (d) => d.getMinutes(),
  [SECONDS]: (d) => d.getSeconds(),
  [MILLISECONDS]: (d) => d.getMilliseconds(),
  [DAYOFYEAR]: (d) => localDayOfYear(d),
  [WEEK]: (d) => localWeekNum(d),
  [WEEK + DAY]: (d, y2) => weekday(localWeekNum(d), d.getDay(), localFirst(y2)),
  [DAY]: (d, y2) => weekday(1, d.getDay(), localFirst(y2))
};
var localInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w4, y2) => weekday(w4, 0, localFirst(y2))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
}
var utcGet = {
  [YEAR]: (d) => d.getUTCFullYear(),
  [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: (d) => d.getUTCMonth(),
  [DATE]: (d) => d.getUTCDate(),
  [HOURS]: (d) => d.getUTCHours(),
  [MINUTES]: (d) => d.getUTCMinutes(),
  [SECONDS]: (d) => d.getUTCSeconds(),
  [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR]: (d) => utcDayOfYear(d),
  [WEEK]: (d) => utcWeekNum(d),
  [DAY]: (d, y2) => weekday(1, d.getUTCDay(), utcFirst(y2)),
  [WEEK + DAY]: (d, y2) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y2))
};
var utcInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w4, y2) => weekday(w4, 0, utcFirst(y2))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}
var timeIntervals = {
  [YEAR]: timeYear,
  [QUARTER]: timeMonth.every(3),
  [MONTH]: timeMonth,
  [WEEK]: timeSunday,
  [DATE]: timeDay,
  [DAY]: timeDay,
  [DAYOFYEAR]: timeDay,
  [HOURS]: timeHour,
  [MINUTES]: timeMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
var utcIntervals = {
  [YEAR]: utcYear,
  [QUARTER]: utcMonth.every(3),
  [MONTH]: utcMonth,
  [WEEK]: utcSunday,
  [DATE]: utcDay,
  [DAY]: utcDay,
  [DAYOFYEAR]: utcDay,
  [HOURS]: utcHour,
  [MINUTES]: utcMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
function timeInterval(unit) {
  return timeIntervals[unit];
}
function utcInterval(unit) {
  return utcIntervals[unit];
}
function offset(ival, date, step) {
  return ival ? ival.offset(date, step) : void 0;
}
function timeOffset(unit, date, step) {
  return offset(timeInterval(unit), date, step);
}
function utcOffset(unit, date, step) {
  return offset(utcInterval(unit), date, step);
}
function sequence(ival, start, stop3, step) {
  return ival ? ival.range(start, stop3, step) : void 0;
}
function timeSequence(unit, start, stop3, step) {
  return sequence(timeInterval(unit), start, stop3, step);
}
function utcSequence(unit, start, stop3, step) {
  return sequence(utcInterval(unit), start, stop3, step);
}
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;
var Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS];
var Seconds = Milli.slice(0, -1);
var Minutes = Seconds.slice(0, -1);
var Hours = Minutes.slice(0, -1);
var Day = Hours.slice(0, -1);
var Week = [YEAR, WEEK];
var Month = [YEAR, MONTH];
var Year = [YEAR];
var intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin(opt) {
  const ext = opt.extent, max4 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max4;
  let i = bisector((i2) => i2[2]).right(intervals, target2), units, step;
  if (i === intervals.length) {
    units = Year, step = tickStep(ext[0] / durationYear, ext[1] / durationYear, max4);
  } else if (i) {
    i = intervals[target2 / intervals[i - 1][2] < intervals[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max(tickStep(ext[0], ext[1], max4), 1);
  }
  return {
    units,
    step
  };
}

// node_modules/vega-format/build/vega-format.module.js
function memoize(method2) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method2(spec));
}
function trimZeroes(numberFormat2, decimalChar) {
  return (x2) => {
    const str = numberFormat2(x2), dec = str.indexOf(decimalChar);
    if (dec < 0) return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec) if (str[idx] !== "0") {
      ++idx;
      break;
    }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c;
  if (i > 0) return i;
  for (i = str.length; --i > dec; ) {
    c = str.charCodeAt(i);
    if (c >= 48 && c <= 57) return i + 1;
  }
}
function numberLocale(locale2) {
  const format5 = memoize(locale2.format), formatPrefix2 = locale2.formatPrefix;
  return {
    format: format5,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s = formatSpecifier(spec || ",");
      if (s.precision == null) {
        s.precision = 12;
        switch (s.type) {
          case "%":
            s.precision -= 2;
            break;
          case "e":
            s.precision -= 1;
            break;
        }
        return trimZeroes(
          format5(s),
          // number format
          format5(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format5(s);
      }
    },
    formatSpan(start, stop3, count, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop3, count), value3 = Math.max(Math.abs(start), Math.abs(stop3));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value3))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value3);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value3))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format5(specifier);
    }
  };
}
var defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format,
    formatPrefix
  });
}
function numberFormatLocale(definition3) {
  return numberLocale(locale_default(definition3));
}
function numberFormatDefaultLocale(definition3) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition3) : defaultNumberLocale;
}
function timeMultiFormat(format5, interval2, spec) {
  spec = spec || {};
  if (!isObject(spec)) {
    error(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval2(SECONDS), minute = interval2(MINUTES), hour = interval2(HOURS), day = interval2(DATE), week2 = interval2(WEEK), month = interval2(MONTH), quarter2 = interval2(QUARTER), year = interval2(YEAR), L = format5(spec[MILLISECONDS] || ".%L"), S = format5(spec[SECONDS] || ":%S"), M = format5(spec[MINUTES] || "%I:%M"), H = format5(spec[HOURS] || "%I %p"), d = format5(spec[DATE] || spec[DAY] || "%a %d"), w4 = format5(spec[WEEK] || "%b %d"), m = format5(spec[MONTH] || "%B"), q = format5(spec[QUARTER] || "%B"), y2 = format5(spec[YEAR] || "%Y");
  return (date) => (second2(date) < date ? L : minute(date) < date ? S : hour(date) < date ? M : day(date) < date ? H : month(date) < date ? week2(date) < date ? d : w4 : year(date) < date ? quarter2(date) < date ? m : q : y2)(date);
}
function timeLocale(locale2) {
  const timeFormat4 = memoize(locale2.format), utcFormat3 = memoize(locale2.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat4(spec) : timeMultiFormat(timeFormat4, timeInterval, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat3(spec) : timeMultiFormat(utcFormat3, utcInterval, spec),
    timeParse: memoize(locale2.parse),
    utcParse: memoize(locale2.utcParse)
  };
}
var defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale(definition3) {
  return timeLocale(formatLocale(definition3));
}
function timeFormatDefaultLocale(definition3) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition3) : defaultTimeLocale;
}
var createLocale = (number5, time3) => extend({}, number5, time3);
function locale(numberSpec, timeSpec) {
  const number5 = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time3 = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number5, time3);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}

// node_modules/vega-loader/build/vega-loader.browser.module.js
var protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol = "file://";
function loaderFactory(fetch2, fs) {
  return (options) => ({
    options: options || {},
    sanitize,
    load,
    fileAccess: false,
    file: fileLoader(fs),
    http: httpLoader(fetch2)
  });
}
async function load(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
async function sanitize(uri, options) {
  options = extend({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error2, data3) => {
      if (error2) reject(error2);
      else accept(data3);
    });
  }) : fileReject;
}
async function fileReject() {
  error("No file system access.");
}
function httpLoader(fetch2) {
  return fetch2 ? async function(url, options) {
    const opt = extend({}, this.options.http, options), type3 = options && options.response, response = await fetch2(url, opt);
    return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type3]) ? response[type3]() : response.text();
  } : httpReject;
}
async function httpReject() {
  error("No HTTP fetch method available.");
}
var isValid = (_) => _ != null && _ === _;
var isBoolean2 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
var isDate2 = (_) => !Number.isNaN(Date.parse(_));
var isNumber2 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
var isInteger2 = (_) => isNumber2(_) && Number.isInteger(+_);
var typeParsers = {
  boolean: toBoolean,
  integer: toNumber,
  number: toNumber,
  date: toDate,
  string: toString,
  unknown: identity2
};
var typeTests = [isBoolean2, isInteger2, isNumber2, isDate2];
var typeList = ["boolean", "integer", "number", "date"];
function inferType(values5, field3) {
  if (!values5 || !values5.length) return "unknown";
  const n = values5.length, m = typeTests.length, a = typeTests.map((_, i) => i + 1);
  for (let i = 0, t2 = 0, j, value3; i < n; ++i) {
    value3 = field3 ? values5[i][field3] : values5[i];
    for (j = 0; j < m; ++j) {
      if (a[j] && isValid(value3) && !typeTests[j](value3)) {
        a[j] = 0;
        ++t2;
        if (t2 === typeTests.length) return "string";
      }
    }
  }
  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data3, fields) {
  return fields.reduce((types4, field3) => {
    types4[field3] = inferType(data3, field3);
    return types4;
  }, {});
}
function delimitedFormat(delimiter) {
  const parse7 = function(data3, format5) {
    const delim = {
      delimiter
    };
    return dsv(data3, format5 ? extend(format5, delim) : delim);
  };
  parse7.responseType = "text";
  return parse7;
}
function dsv(data3, format5) {
  if (format5.header) {
    data3 = format5.header.map($).join(format5.delimiter) + "\n" + data3;
  }
  return dsv_default(format5.delimiter).parse(data3 + "");
}
dsv.responseType = "text";
function isBuffer(_) {
  return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data3, format5) {
  const prop = format5 && format5.property ? field(format5.property) : identity2;
  return isObject(data3) && !isBuffer(data3) ? parseJSON(prop(data3), format5) : prop(JSON.parse(data3));
}
json.responseType = "json";
function parseJSON(data3, format5) {
  if (!isArray(data3) && isIterable(data3)) {
    data3 = [...data3];
  }
  return format5 && format5.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters = {
  interior: (a, b2) => a !== b2,
  exterior: (a, b2) => a === b2
};
function topojson(data3, format5) {
  let method2, object2, property2, filter3;
  data3 = json(data3, format5);
  if (format5 && format5.feature) {
    method2 = feature_default;
    property2 = format5.feature;
  } else if (format5 && format5.mesh) {
    method2 = mesh_default;
    property2 = format5.mesh;
    filter3 = filters[format5.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method2(data3, object2, filter3) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson.responseType = "json";
var format2 = {
  dsv,
  csv: delimitedFormat(","),
  tsv: delimitedFormat("	"),
  json,
  topojson
};
function formats(name4, reader) {
  if (arguments.length > 1) {
    format2[name4] = reader;
    return this;
  } else {
    return has(format2, name4) ? format2[name4] : null;
  }
}
function responseType(type3) {
  const f = formats(type3);
  return f && f.responseType || "text";
}
function read(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || "json");
  if (!reader) error("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse) parse(data3, schema.parse, timeParser, utcParser);
  if (has(data3, "columns")) delete data3.columns;
  return data3;
}
function parse(data3, types4, timeParser, utcParser) {
  if (!data3.length) return;
  const locale2 = timeFormatDefaultLocale();
  timeParser = timeParser || locale2.timeParse;
  utcParser = utcParser || locale2.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field3, i, j, n, m;
  if (types4 === "auto") types4 = inferTypes(data3, fields);
  fields = Object.keys(types4);
  const parsers = fields.map((field4) => {
    const type3 = types4[field4];
    let parts, pattern;
    if (type3 && (type3.startsWith("date:") || type3.startsWith("utc:"))) {
      parts = type3.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse7 = parts[0] === "utc" ? utcParser : timeParser;
      return parse7(pattern);
    }
    if (!typeParsers[type3]) {
      throw Error("Illegal format pattern: " + field4 + ":" + type3);
    }
    return typeParsers[type3];
  });
  for (i = 0, n = data3.length, m = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m; ++j) {
      field3 = fields[j];
      datum2[field3] = parsers[j](datum2[field3]);
    }
  }
}
var loader = loaderFactory(
  typeof fetch !== "undefined" && fetch,
  // use built-in fetch API
  null
  // no file system access
);

// node_modules/vega-dataflow/build/vega-dataflow.module.js
function UniqueList(idFunc) {
  const $2 = idFunc || identity2, list = [], ids = {};
  list.add = (_) => {
    const id2 = $2(_);
    if (!ids[id2]) {
      ids[id2] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id2 = $2(_);
    if (ids[id2]) {
      ids[id2] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0) list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
var TUPLE_ID_KEY = Symbol("vega_id");
var TUPLE_ID = 1;
function isTuple(t2) {
  return !!(t2 && tupleid(t2));
}
function tupleid(t2) {
  return t2[TUPLE_ID_KEY];
}
function setid(t2, id2) {
  t2[TUPLE_ID_KEY] = id2;
  return t2;
}
function ingest$1(datum2) {
  const t2 = datum2 === Object(datum2) ? datum2 : {
    data: datum2
  };
  return tupleid(t2) ? t2 : setid(t2, TUPLE_ID++);
}
function derive(t2) {
  return rederive(t2, ingest$1({}));
}
function rederive(t2, d) {
  for (const k2 in t2) d[k2] = t2[k2];
  return d;
}
function replace(t2, d) {
  return setid(d, tupleid(t2));
}
function stableCompare(cmp2, f) {
  return !cmp2 ? null : f ? (a, b2) => cmp2(a, b2) || tupleid(f(a)) - tupleid(f(b2)) : (a, b2) => cmp2(a, b2) || tupleid(a) - tupleid(b2);
}
function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add5 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t2) {
      const d = array(t2), n = d.length;
      for (let i = 0; i < n; ++i) add5.push(d[i]);
      return this;
    },
    remove(t2) {
      const a = isFunction(t2) ? remp : rem2, d = array(t2), n = d.length;
      for (let i = 0; i < n; ++i) a.push(d[i]);
      return this;
    },
    modify(t2, field3, value3) {
      const m = {
        field: field3,
        value: constant(value3)
      };
      if (isFunction(t2)) {
        m.filter = t2;
        modp.push(m);
      } else {
        m.tuple = t2;
        mod.push(m);
      }
      return this;
    },
    encode(t2, set5) {
      if (isFunction(t2)) modp.push({
        filter: t2,
        field: set5
      });
      else mod.push({
        tuple: t2,
        field: set5
      });
      return this;
    },
    clean(value3) {
      clean = value3;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m, f, t2, id2;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t2 = rem2[i];
        cur[tupleid(t2)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t3) => {
          if (f(t3)) cur[tupleid(t3)] = -1;
        });
      }
      for (i = 0, n = add5.length; i < n; ++i) {
        t2 = add5[i];
        id2 = tupleid(t2);
        if (cur[id2]) {
          cur[id2] = 1;
        } else {
          pulse2.add.push(ingest$1(add5[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t2 = tuples[i];
        if (cur[tupleid(t2)] < 0) pulse2.rem.push(t2);
      }
      function modify2(t3, f2, v) {
        if (v) {
          t3[f2] = v(t3);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2) out[tupleid(t3)] = t3;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m = mod[i];
        t2 = m.tuple;
        f = m.field;
        id2 = cur[tupleid(t2)];
        if (id2 > 0) {
          modify2(t2, f, m.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m = modp[i];
        f = m.filter;
        tuples.forEach((t3) => {
          if (f(t3) && cur[tupleid(t3)] > 0) {
            modify2(t3, m.field, m.value);
          }
        });
        pulse2.modifies(m.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t3) => cur[tupleid(t3)] > 0) : tuples.slice();
      } else {
        for (id2 in out) pulse2.mod.push(out[id2]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
var CACHE = "_:mod:_";
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name4, index3, value3, force) {
    const o = this, v = o[name4], mod = o[CACHE];
    if (index3 != null && index3 >= 0) {
      if (v[index3] !== value3 || force) {
        v[index3] = value3;
        mod[index3 + ":" + name4] = -1;
        mod[name4] = -1;
      }
    } else if (v !== value3 || force) {
      o[name4] = value3;
      mod[name4] = isArray(value3) ? 1 + value3.length : -1;
    }
    return o;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name4, index3) {
    const mod = this[CACHE];
    if (!arguments.length) {
      for (const k2 in mod) {
        if (mod[k2]) return true;
      }
      return false;
    } else if (isArray(name4)) {
      for (let k2 = 0; k2 < name4.length; ++k2) {
        if (mod[name4[k2]]) return true;
      }
      return false;
    }
    return index3 != null && index3 >= 0 ? index3 + 1 < mod[name4] || !!mod[index3 + ":" + name4] : !!mod[name4];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }
};
var OP_ID = 0;
var PULSE = "pulse";
var NO_PARAMS = new Parameters();
var SKIP$1 = 1;
var MODIFIED = 2;
function Operator(init2, update3, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update3) {
    this._update = update3;
  }
  if (params2) this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0) return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value3) {
    if (this.value !== value3) {
      this.value = value3;
      return 1;
    } else {
      return 0;
    }
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params2, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
    let name4, value3, n, i;
    const add5 = (name5, index3, value4) => {
      if (value4 instanceof Operator) {
        if (value4 !== this) {
          if (react) value4.targets().add(this);
          deps.push(value4);
        }
        argops.push({
          op: value4,
          name: name5,
          index: index3
        });
      } else {
        argval.set(name5, index3, value4);
      }
    };
    for (name4 in params2) {
      value3 = params2[name4];
      if (name4 === PULSE) {
        array(value3).forEach((op) => {
          if (!(op instanceof Operator)) {
            error("Pulse parameters must be operator instances.");
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value3;
      } else if (isArray(value3)) {
        argval.set(name4, -1, Array(n = value3.length));
        for (i = 0; i < n; ++i) add5(name4, i, value3[i]);
      } else {
        add5(name4, -1, value3);
      }
    }
    this.marshall().clear();
    if (initonly) argops.initonly = true;
    return deps;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS, argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }
    this.pulse = null;
    this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse2) {
    const update3 = this._update;
    if (update3) {
      const params2 = this.marshall(pulse2.stamp), v = update3.call(this, params2, pulse2);
      params2.clear();
      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse2.StopPropagation;
      }
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp) return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse2);
    }
    return this.pulse = rv || pulse2;
  }
};
function add(init2, update3, params2, react) {
  let shift = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction(init2)) {
    op = new Operator(null, init2);
  } else {
    shift = 0;
    op = new Operator(init2, update3);
  }
  this.rank(op);
  if (shift) {
    react = params2;
    params2 = update3;
  }
  if (params2) this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target2, sources) {
  const targetRank = target2.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target2);
      return;
    }
  }
}
var STREAM_ID = 0;
function EventStream(filter3, apply3, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive) this.receive = receive;
  if (filter3) this._filter = filter3;
  if (apply3) this._apply = apply3;
}
function stream(filter3, apply3, receive) {
  return new EventStream(filter3, apply3, receive);
}
EventStream.prototype = {
  _filter: truthy,
  _apply: identity2,
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  consume(_) {
    if (!arguments.length) return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i) trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter3) {
    const s = stream(filter3);
    this.targets().add(s);
    return s;
  },
  apply(apply3) {
    const s = stream(null, apply3);
    this.targets().add(s);
    return s;
  },
  merge() {
    const s = stream();
    this.targets().add(s);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }
    return s;
  },
  throttle(pause) {
    let t2 = -1;
    return this.filter(() => {
      const now = Date.now();
      if (now - t2 > pause) {
        t2 = now;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, debounce(delay, (e2) => {
      const df = e2.dataflow;
      s.receive(e2);
      if (df && df.run) df.run();
    })));
    return s;
  },
  between(a, b2) {
    let active = false;
    a.targets().add(stream(null, null, () => active = true));
    b2.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
    this._filter = truthy;
    this._targets = null;
  }
};
function events(source4, type3, filter3, apply3) {
  const df = this, s = stream(filter3, apply3), send = function(e2) {
    e2.dataflow = df;
    try {
      s.receive(e2);
    } catch (error2) {
      df.error(error2);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source4 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source4);
  } else {
    sources = array(source4);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type3, send);
  }
  return s;
}
function parse2(data3, format5) {
  const locale2 = this.locale();
  return read(data3, format5, locale2.timeParse, locale2.utcParse);
}
function ingest(target2, data3, format5) {
  data3 = this.parse(data3, format5);
  return this.pulse(target2, this.changeset().insert(data3));
}
async function request(url, format5) {
  const df = this;
  let status = 0, data3;
  try {
    data3 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format5 && format5.type)
    });
    try {
      data3 = df.parse(data3, format5);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data3,
    status
  };
}
async function preload(target2, url, format5) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format5);
  df.pulse(target2, df.changeset().remove(truthy).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a) => accept = a);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
var SKIP = {
  skip: true
};
function on(source4, target2, update3, params2, options) {
  const fn = source4 instanceof Operator ? onOperator : onStream;
  fn(this, source4, target2, update3, params2, options);
  return this;
}
function onStream(df, stream2, target2, update3, params2, options) {
  const opt = extend({}, options, SKIP);
  let func, op;
  if (!isFunction(target2)) target2 = constant(target2);
  if (update3 === void 0) {
    func = (e2) => df.touch(target2(e2));
  } else if (isFunction(update3)) {
    op = new Operator(null, update3, params2, false);
    func = (e2) => {
      op.evaluate(e2);
      const t2 = target2(e2), v = op.value;
      isChangeSet(v) ? df.pulse(t2, v, options) : df.update(t2, v, opt);
    };
  } else {
    func = (e2) => df.update(target2(e2), update3, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source4, target2, update3, params2, options) {
  if (update3 === void 0) {
    source4.targets().add(target2);
  } else {
    const opt = options || {}, op = new Operator(null, updater(target2, update3), params2, false);
    op.modified(opt.force);
    op.rank = source4.rank;
    source4.targets().add(op);
    if (target2) {
      op.skip(true);
      op.value = target2.value;
      op.targets().add(target2);
      df.connect(target2, [op]);
    }
  }
}
function updater(target2, update3) {
  update3 = isFunction(update3) ? update3 : constant(update3);
  return target2 ? function(_, pulse2) {
    const value3 = update3(_, pulse2);
    if (!target2.skip()) {
      target2.skip(value3 !== this.value).value = value3;
    }
    return value3;
  } : update3;
}
function rank(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op) error("Cycle detected in dataflow graph.");
      }
    }
  }
}
var StopPropagation = {};
var ADD = 1 << 0;
var REM = 1 << 1;
var MOD = 1 << 2;
var ADD_REM = ADD | REM;
var ADD_MOD = ADD | MOD;
var ALL = ADD | REM | MOD;
var REFLOW = 1 << 3;
var SOURCE = 1 << 4;
var NO_SOURCE = 1 << 5;
var NO_FIELDS = 1 << 6;
function Pulse(dataflow, stamp, encode2) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode2 || null;
}
function materialize(data3, filter3) {
  const out = [];
  visitArray(data3, filter3, (_) => out.push(_));
  return out;
}
function filter(pulse2, flags) {
  const map2 = {};
  pulse2.visit(flags, (t2) => {
    map2[tupleid(t2)] = 1;
  });
  return (t2) => map2[tupleid(t2)] ? null : t2;
}
function addFilter(a, b2) {
  return a ? (t2, i) => a(t2, i) && b2(t2, i) : b2;
}
Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source) p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = [];
      return p;
    }
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans) p.cleans = src.cleans;
    }
    return p;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork) return this.fork(ALL).reflow();
    const len = this.add.length, src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len) this.filter(MOD, filter(this, ADD));
    }
    return this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value3) {
    if (arguments.length) {
      this.cleans = !!value3;
      return this;
    } else {
      return this.cleans;
    }
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash2 = this.fields || (this.fields = {});
    if (isArray(_)) {
      _.forEach((f) => hash2[f] = true);
    } else {
      hash2[_] = true;
    }
    return this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter3) {
    const p = this;
    if (flags & ADD) p.addF = addFilter(p.addF, filter3);
    if (flags & REM) p.remF = addFilter(p.remF, filter3);
    if (flags & MOD) p.modF = addFilter(p.modF, filter3);
    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter3);
    return p;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this, v = visitor;
    if (flags & SOURCE) {
      visitArray(p.source, p.srcF, v);
      return p;
    }
    if (flags & ADD) visitArray(p.add, p.addF, v);
    if (flags & REM) visitArray(p.rem, p.remF, v);
    if (flags & MOD) visitArray(p.mod, p.modF, v);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum2 = p.add.length + p.mod.length;
      if (sum2 === src.length) ;
      else if (sum2) {
        visitArray(src, filter(p, ADD_MOD), v);
      } else {
        visitArray(src, p.srcF, v);
      }
    }
    return p;
  }
};
function MultiPulse(dataflow, stamp, pulses, encode2) {
  const p = this;
  let c = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode2 || null;
  this.pulses = pulses;
  for (const pulse2 of pulses) {
    if (pulse2.stamp !== stamp) continue;
    if (pulse2.fields) {
      const hash2 = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash2[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD)) c |= p.ADD;
    if (pulse2.changed(p.REM)) c |= p.REM;
    if (pulse2.changed(p.MOD)) c |= p.MOD;
  }
  this.changes = c;
}
inherits(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== void 0) {
      if (flags & p.ADD) this.visit(p.ADD, (t2) => p.add.push(t2));
      if (flags & p.REM) this.visit(p.REM, (t2) => p.rem.push(t2));
      if (flags & p.MOD) this.visit(p.MOD, (t2) => p.mod.push(t2));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this, fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter() {
    error("MultiPulse does not support filtering.");
  },
  materialize() {
    error("MultiPulse does not support materialization.");
  },
  visit(flags, visitor) {
    const p = this, pulses = p.pulses, n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});
async function evaluate(encode2, prerun, postrun) {
  const df = this, async2 = [];
  if (df._pulse) return reentrant(df);
  if (df._pending) await df._pending;
  if (prerun) await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode2);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id);
  let count = 0, op, next, error2;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next = op.run(df._getPulse(op, encode2));
      if (next.then) {
        next = await next;
      } else if (next.async) {
        async2.push(next.async);
        next = StopPropagation;
      }
      if (next !== StopPropagation) {
        if (op._targets) op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count;
    }
  } catch (err) {
    df._heap.clear();
    error2 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count} operators`);
  if (error2) {
    df._postrun = [];
    df.error(error2);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a, b2) => b2.priority - a.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun) await asyncCallback(df, postrun);
  if (async2.length) {
    Promise.all(async2).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode2, prerun, postrun) {
  while (this._running) await this._running;
  const clear2 = () => this._running = null;
  (this._running = this.evaluate(encode2, prerun, postrun)).then(clear2, clear2);
  return this._running;
}
function run(encode2, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q) op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode2) {
  const s = op.source, stamp = this._clock;
  return s && isArray(s) ? new MultiPulse(this, stamp, s.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}
function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }
  p = p.fork();
  if (s && s !== StopPropagation) {
    p.source = s.source;
  }
  return p;
}
var NO_OPT = {
  skip: false,
  force: false
};
function touch(op, options) {
  const opt = options || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip) op.skip(true);
  return this;
}
function update(op, value3, options) {
  const opt = options || NO_OPT;
  if (op.set(value3) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t2 = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t2);
  return this;
}
function Heap(cmp2) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x2) => {
      nodes.push(x2);
      return siftdown(nodes, 0, nodes.length - 1, cmp2);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp2);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array4, start, idx, cmp2) {
  let parent, pidx;
  const item = array4[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array4[pidx];
    if (cmp2(item, parent) < 0) {
      array4[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array4[idx] = item;
}
function siftup(array4, idx, cmp2) {
  const start = idx, end = array4.length, item = array4[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp2(array4[cidx], array4[ridx]) >= 0) {
      cidx = ridx;
    }
    array4[idx] = array4[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array4[idx] = item;
  return siftdown(array4, start, idx, cmp2);
}
function Dataflow() {
  this.logger(logger());
  this.logLevel(Error$1);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale();
  try {
    this._loader = loader();
  } catch (e2) {
  }
  this._touched = UniqueList(id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a, b2) => a.qrank - b2.qrank);
  this._postrun = [];
}
function logMethod(method2) {
  return function() {
    return this._log[method2].apply(this, arguments);
  };
}
Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger2) {
    if (arguments.length) {
      this._log = logger2;
      return this;
    } else {
      return this._log;
    }
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse: parse2,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
inherits(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp) return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse2);
    }
    rv = rv || pulse2;
    if (rv.then) {
      rv = rv.then((_) => this.pulse = _);
    } else if (rv !== pulse2.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse2) {
    const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
    params2.clear();
    return out;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
var transforms = {};
function definition(type3) {
  const t2 = transform(type3);
  return t2 && t2.Definition || null;
}
function transform(type3) {
  type3 = type3 && type3.toLowerCase();
  return has(transforms, type3) ? transforms[type3] : null;
}

// node_modules/vega-transforms/build/vega-transforms.module.js
var vega_transforms_module_exports = {};
__export(vega_transforms_module_exports, {
  aggregate: () => Aggregate,
  bin: () => Bin,
  collect: () => Collect,
  compare: () => Compare,
  countpattern: () => CountPattern,
  cross: () => Cross,
  density: () => Density,
  dotbin: () => DotBin,
  expression: () => Expression,
  extent: () => Extent,
  facet: () => Facet,
  field: () => Field,
  filter: () => Filter,
  flatten: () => Flatten,
  fold: () => Fold,
  formula: () => Formula,
  generate: () => Generate,
  impute: () => Impute,
  joinaggregate: () => JoinAggregate,
  kde: () => KDE,
  key: () => Key,
  load: () => Load,
  lookup: () => Lookup,
  multiextent: () => MultiExtent,
  multivalues: () => MultiValues,
  params: () => Params,
  pivot: () => Pivot,
  prefacet: () => PreFacet,
  project: () => Project,
  proxy: () => Proxy,
  quantile: () => Quantile,
  relay: () => Relay,
  sample: () => Sample,
  sequence: () => Sequence,
  sieve: () => Sieve,
  subflow: () => Subflow,
  timeunit: () => TimeUnit,
  tupleindex: () => TupleIndex,
  values: () => Values,
  window: () => Window
});

// node_modules/vega-statistics/build/vega-statistics.module.js
function* numbers(values5, valueof) {
  if (valueof == null) {
    for (let value3 of values5) {
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  } else {
    let index3 = -1;
    for (let value3 of values5) {
      value3 = valueof(value3, ++index3, values5);
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  }
}
function quantiles(array4, p, f) {
  const values5 = Float64Array.from(numbers(array4, f));
  values5.sort(ascending);
  return p.map((_) => quantileSorted(values5, _));
}
function quartiles(array4, f) {
  return quantiles(array4, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array4, f) {
  const n = array4.length, d = deviation(array4, f), q = quartiles(array4, f), h2 = (q[2] - q[0]) / 1.34, v = Math.min(d, h2) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}
function bin2(_) {
  const maxb = _.maxbins || 20, base = _.base || 10, logb = Math.log(base), div = _.divide || [5, 2];
  let min4 = _.extent[0], max4 = _.extent[1], step, level, minstep, v, i, n;
  const span2 = _.span || max4 - min4 || Math.abs(min4) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v = span2 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i) ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base, Math.round(Math.log(span2) / logb) - level));
    while (Math.ceil(span2 / step) > maxb) {
      step *= base;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span2 / v <= maxb) step = v;
    }
  }
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v = Math.floor(min4 / step + eps) * step;
    min4 = min4 < v ? v - step : v;
    max4 = Math.ceil(max4 / step) * step;
  }
  return {
    start: min4,
    stop: max4 === min4 ? min4 + step : max4,
    step
  };
}
var random = Math.random;
function setRandom(r2) {
  random = r2;
}
function bootstrapCI(array4, samples, alpha, f) {
  if (!array4.length) return [void 0, void 0];
  const values5 = Float64Array.from(numbers(array4, f)), n = values5.length, m = samples;
  let a, i, j, mu;
  for (j = 0, mu = Array(m); j < m; ++j) {
    for (a = 0, i = 0; i < n; ++i) {
      a += values5[~~(random() * n)];
    }
    mu[j] = a / n;
  }
  mu.sort(ascending);
  return [quantile(mu, alpha / 2), quantile(mu, 1 - alpha / 2)];
}
function dotbin(array4, step, smooth, f) {
  f = f || ((_) => _);
  const n = array4.length, v = new Float64Array(n);
  let i = 0, j = 1, a = f(array4[0]), b2 = a, w4 = a + step, x2;
  for (; j < n; ++j) {
    x2 = f(array4[j]);
    if (x2 >= w4) {
      b2 = (a + b2) / 2;
      for (; i < j; ++i) v[i] = b2;
      w4 = x2 + step;
      a = x2;
    }
    b2 = x2;
  }
  b2 = (a + b2) / 2;
  for (; i < j; ++i) v[i] = b2;
  return smooth ? smoothing(v, step + step / 4) : v;
}
function smoothing(v, thresh) {
  const n = v.length;
  let a = 0, b2 = 1, c, d;
  while (v[a] === v[b2]) ++b2;
  while (b2 < n) {
    c = b2 + 1;
    while (v[b2] === v[c]) ++c;
    if (v[b2] - v[b2 - 1] < thresh) {
      d = b2 + (a + c - b2 - b2 >> 1);
      while (d < b2) v[d++] = v[b2];
      while (d > b2) v[d--] = v[a];
    }
    a = b2;
    b2 = c;
  }
  return v;
}
function lcg(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min4, max4) {
  if (max4 == null) {
    max4 = min4;
    min4 = 0;
  }
  let a, b2, d;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        d = b2 - a;
        return dist;
      } else {
        return a;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ || 0;
        d = b2 - a;
        return dist;
      } else {
        return b2;
      }
    },
    sample() {
      return a + Math.floor(d * random());
    },
    pdf(x2) {
      return x2 === Math.floor(x2) && x2 >= a && x2 < b2 ? 1 / d : 0;
    },
    cdf(x2) {
      const v = Math.floor(x2);
      return v < a ? 0 : v >= b2 ? 1 : (v - a + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist.min(min4).max(max4);
}
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2 = Math.SQRT2;
var nextSample = NaN;
function sampleNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x2 = 0, y2 = 0, rds, c;
  if (nextSample === nextSample) {
    x2 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x2 = random() * 2 - 1;
      y2 = random() * 2 - 1;
      rds = x2 * x2 + y2 * y2;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2 * Math.log(rds) / rds);
    x2 *= c;
    nextSample = y2 * c;
  }
  return mean2 + x2 * stdev;
}
function densityNormal(value3, mean2, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - (mean2 || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value3, mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - mean2) / stdev, Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp4 = Math.exp(-Z * Z / 2);
    let sum2;
    if (Z < 7.07106781186547) {
      sum2 = 0.0352624965998911 * Z + 0.700383064443688;
      sum2 = sum2 * Z + 6.37396220353165;
      sum2 = sum2 * Z + 33.912866078383;
      sum2 = sum2 * Z + 112.079291497871;
      sum2 = sum2 * Z + 221.213596169931;
      sum2 = sum2 * Z + 220.206867912376;
      cd = exp4 * sum2;
      sum2 = 0.0883883476483184 * Z + 1.75566716318264;
      sum2 = sum2 * Z + 16.064177579207;
      sum2 = sum2 * Z + 86.7807322029461;
      sum2 = sum2 * Z + 296.564248779674;
      sum2 = sum2 * Z + 637.333633378831;
      sum2 = sum2 * Z + 793.826512519948;
      sum2 = sum2 * Z + 440.413735824752;
      cd = cd / sum2;
    } else {
      sum2 = Z + 0.65;
      sum2 = Z + 4 / sum2;
      sum2 = Z + 3 / sum2;
      sum2 = Z + 2 / sum2;
      sum2 = Z + 1 / sum2;
      cd = exp4 / sum2 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean2, stdev) {
  if (p < 0 || p > 1) return NaN;
  return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x2) {
  let w4 = -Math.log((1 - x2) * (1 + x2)), p;
  if (w4 < 6.25) {
    w4 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w4;
    p = 128584807152564e-32 + p * w4;
    p = 11157877678025181e-33 + p * w4;
    p = -1333171662854621e-31 + p * w4;
    p = 20972767875968562e-33 + p * w4;
    p = 6637638134358324e-30 + p * w4;
    p = -4054566272975207e-29 + p * w4;
    p = -8151934197605472e-29 + p * w4;
    p = 26335093153082323e-28 + p * w4;
    p = -12975133253453532e-27 + p * w4;
    p = -5415412054294628e-26 + p * w4;
    p = 10512122733215323e-25 + p * w4;
    p = -4112633980346984e-24 + p * w4;
    p = -29070369957882005e-24 + p * w4;
    p = 42347877827932404e-23 + p * w4;
    p = -13654692000834679e-22 + p * w4;
    p = -13882523362786469e-21 + p * w4;
    p = 18673420803405714e-20 + p * w4;
    p = -740702534166267e-18 + p * w4;
    p = -0.006033670871430149 + p * w4;
    p = 0.24015818242558962 + p * w4;
    p = 1.6536545626831027 + p * w4;
  } else if (w4 < 16) {
    w4 = Math.sqrt(w4) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w4;
    p = -27517406297064545e-23 + p * w4;
    p = 18239629214389228e-24 + p * w4;
    p = 15027403968909828e-22 + p * w4;
    p = -4013867526981546e-21 + p * w4;
    p = 29234449089955446e-22 + p * w4;
    p = 12475304481671779e-21 + p * w4;
    p = -47318229009055734e-21 + p * w4;
    p = 6828485145957318e-20 + p * w4;
    p = 24031110387097894e-21 + p * w4;
    p = -3550375203628475e-19 + p * w4;
    p = 9532893797373805e-19 + p * w4;
    p = -0.0016882755560235047 + p * w4;
    p = 0.002491442096107851 + p * w4;
    p = -0.003751208507569241 + p * w4;
    p = 0.005370914553590064 + p * w4;
    p = 1.0052589676941592 + p * w4;
    p = 3.0838856104922208 + p * w4;
  } else if (Number.isFinite(w4)) {
    w4 = Math.sqrt(w4) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w4;
    p = 15076572693500548e-25 + p * w4;
    p = -3789465440126737e-24 + p * w4;
    p = 761570120807834e-23 + p * w4;
    p = -1496002662714924e-23 + p * w4;
    p = 2914795345090108e-23 + p * w4;
    p = -6771199775845234e-23 + p * w4;
    p = 22900482228026655e-23 + p * w4;
    p = -99298272942317e-20 + p * w4;
    p = 4526062597223154e-21 + p * w4;
    p = -1968177810553167e-20 + p * w4;
    p = 7599527703001776e-20 + p * w4;
    p = -21503011930044477e-20 + p * w4;
    p = -13871931833623122e-20 + p * w4;
    p = 1.0103004648645344 + p * w4;
    p = 4.849906401408584 + p * w4;
  } else {
    p = Infinity;
  }
  return p * x2;
}
function gaussian(mean2, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value3) => densityNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeNormal(value3, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean2).stdev(stdev);
}
function kde(support, bandwidth2) {
  const kernel = gaussian();
  let n = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist.bandwidth(bandwidth2);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length) return bandwidth2;
      bandwidth2 = _;
      if (!bandwidth2 && support) bandwidth2 = estimateBandwidth(support);
      return dist;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth2 * kernel.sample();
    },
    pdf(x2) {
      let y2 = 0, i = 0;
      for (; i < n; ++i) {
        y2 += kernel.pdf((x2 - support[i]) / bandwidth2);
      }
      return y2 / bandwidth2 / n;
    },
    cdf(x2) {
      let y2 = 0, i = 0;
      for (; i < n; ++i) {
        y2 += kernel.cdf((x2 - support[i]) / bandwidth2);
      }
      return y2 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist.data(support);
}
function sampleLogNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean2 + sampleNormal() * stdev);
}
function densityLogNormal(value3, mean2, stdev) {
  if (value3 <= 0) return 0;
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value3) - mean2) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value3);
}
function cumulativeLogNormal(value3, mean2, stdev) {
  return cumulativeNormal(Math.log(value3), mean2, stdev);
}
function quantileLogNormal(p, mean2, stdev) {
  return Math.exp(quantileNormal(p, mean2, stdev));
}
function lognormal(mean2, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value3) => densityLogNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeLogNormal(value3, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist.mean(mean2).stdev(stdev);
}
function mixture(dists, weights) {
  let m = 0, w4;
  function normalize2(x2) {
    const w5 = [];
    let sum2 = 0, i;
    for (i = 0; i < m; ++i) {
      sum2 += w5[i] = x2[i] == null ? 1 : +x2[i];
    }
    for (i = 0; i < m; ++i) {
      w5[i] /= sum2;
    }
    return w5;
  }
  const dist = {
    weights(_) {
      if (arguments.length) {
        w4 = normalize2(weights = _ || []);
        return dist;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m = _.length;
          dists = _;
        } else {
          m = 0;
          dists = [];
        }
        return dist.weights(weights);
      }
      return dists;
    },
    sample() {
      const r2 = random();
      let d = dists[m - 1], v = w4[0], i = 0;
      for (; i < m - 1; v += w4[++i]) {
        if (r2 < v) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x2) {
      let p = 0, i = 0;
      for (; i < m; ++i) {
        p += w4[i] * dists[i].pdf(x2);
      }
      return p;
    },
    cdf(x2) {
      let p = 0, i = 0;
      for (; i < m; ++i) {
        p += w4[i] * dists[i].cdf(x2);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist.distributions(dists).weights(weights);
}
function sampleUniform(min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return min4 + (max4 - min4) * random();
}
function densityUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 >= min4 && value3 <= max4 ? 1 / (max4 - min4) : 0;
}
function cumulativeUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 < min4 ? 0 : value3 > max4 ? 1 : (value3 - min4) / (max4 - min4);
}
function quantileUniform(p, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return p >= 0 && p <= 1 ? min4 + p * (max4 - min4) : NaN;
}
function uniform(min4, max4) {
  let a, b2;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        return dist;
      } else {
        return a;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ == null ? 1 : _;
        return dist;
      } else {
        return b2;
      }
    },
    sample: () => sampleUniform(a, b2),
    pdf: (value3) => densityUniform(value3, a, b2),
    cdf: (value3) => cumulativeUniform(value3, a, b2),
    icdf: (p) => quantileUniform(p, a, b2)
  };
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return dist.min(min4).max(max4);
}
function constant2(data3, x2, y2) {
  let mean2 = 0, n = 0;
  for (const d of data3) {
    const val = y2(d);
    if (x2(d) == null || val == null || isNaN(val)) continue;
    mean2 += (val - mean2) / ++n;
  }
  return {
    coef: [mean2],
    predict: () => mean2,
    rSquared: 0
  };
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data3, x2, y2, sort3) {
  data3 = data3.filter((d2) => {
    let u = x2(d2), v = y2(d2);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });
  if (sort3) {
    data3.sort((a, b2) => x2(a) - x2(b2));
  }
  const n = data3.length, X3 = new Float64Array(n), Y3 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data3) {
    X3[i] = xv = +x2(d);
    Y3[i] = yv = +y2(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X3[i] -= ux;
    Y3[i] -= uy;
  }
  return [X3, Y3, ux, uy];
}
function visitPoints(data3, x2, y2, callback) {
  let i = -1, u, v;
  for (const d of data3) {
    u = x2(d);
    v = y2(d);
    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}
function rSquared(data3, x2, y2, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear2(data3, x2, y2) {
  let X3 = 0, Y3 = 0, XY = 0, X23 = 0, n = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    ++n;
    X3 += (dx - X3) / n;
    Y3 += (dy - Y3) / n;
    XY += (dx * dy - XY) / n;
    X23 += (dx * dx - X23) / n;
  });
  const coef = ols(X3, Y3, XY, X23), predict = (x3) => coef[0] + coef[1] * x3;
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x2, y2, Y3, predict)
  };
}
function log3(data3, x2, y2) {
  let X3 = 0, Y3 = 0, XY = 0, X23 = 0, n = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X3 += (dx - X3) / n;
    Y3 += (dy - Y3) / n;
    XY += (dx * dy - XY) / n;
    X23 += (dx * dx - X23) / n;
  });
  const coef = ols(X3, Y3, XY, X23), predict = (x3) => coef[0] + coef[1] * Math.log(x3);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x2, y2, Y3, predict)
  };
}
function exp2(data3, x2, y2) {
  const [xv, yv, ux, uy] = points(data3, x2, y2);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly2, xy;
  visitPoints(data3, x2, y2, (_, dy) => {
    dx = xv[n++];
    ly2 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly2 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly2 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x3) => Math.exp(c0 + c1 * (x3 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data3, x2, y2, uy, predict)
  };
}
function pow3(data3, x2, y2) {
  let X3 = 0, Y3 = 0, XY = 0, X23 = 0, YS = 0, n = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    const lx2 = Math.log(dx), ly2 = Math.log(dy);
    ++n;
    X3 += (lx2 - X3) / n;
    Y3 += (ly2 - Y3) / n;
    XY += (lx2 * ly2 - XY) / n;
    X23 += (lx2 * lx2 - X23) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X3, Y3, XY, X23), predict = (x3) => coef[0] * Math.pow(x3, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x2, y2, YS, predict)
  };
}
function quad(data3, x2, y2) {
  const [xv, yv, ux, uy] = points(data3, x2, y2), n = xv.length;
  let X23 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X23 += (x22 - X23) / i;
    X3 += (x22 * dx - X3) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X23 * X23, d = X23 * X2X2 - X3 * X3, a = (X2Y * X23 - XY * X3) / d, b2 = (XY * X2X2 - X2Y * X3) / d, c = -a * X23, predict = (x3) => {
    x3 = x3 - ux;
    return a * x3 * x3 + b2 * x3 + c + uy;
  };
  return {
    coef: [c - b2 * ux + a * ux * ux + uy, b2 - 2 * a * ux, a],
    predict,
    rSquared: rSquared(data3, x2, y2, uy, predict)
  };
}
function poly(data3, x2, y2, order) {
  if (order === 0) return constant2(data3, x2, y2);
  if (order === 1) return linear2(data3, x2, y2);
  if (order === 2) return quad(data3, x2, y2);
  const [xv, yv, ux, uy] = points(data3, x2, y2), n = xv.length, lhs = [], rhs = [], k2 = order + 1;
  let i, j, l, v, c;
  for (i = 0; i < k2; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c = new Float64Array(k2);
    for (j = 0; j < k2; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c[j] = v;
    }
    rhs.push(c);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x3) => {
    x3 -= ux;
    let y3 = uy + coef[0] + coef[1] * x3 + coef[2] * x3 * x3;
    for (i = 3; i < k2; ++i) y3 += coef[i] * Math.pow(x3, i);
    return y3;
  };
  return {
    coef: uncenter(k2, coef, -ux, uy),
    predict,
    rSquared: rSquared(data3, x2, y2, uy, predict)
  };
}
function uncenter(k2, a, x2, y2) {
  const z = Array(k2);
  let i, j, v, c;
  for (i = 0; i < k2; ++i) z[i] = 0;
  for (i = k2 - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x2, j) * c;
    }
  }
  z[0] += y2;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k2, r2, t2;
  for (i = 0; i < n; ++i) {
    r2 = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r2])) {
        r2 = j;
      }
    }
    for (k2 = i; k2 < n + 1; ++k2) {
      t2 = matrix[k2][i];
      matrix[k2][i] = matrix[k2][r2];
      matrix[k2][r2] = t2;
    }
    for (j = i + 1; j < n; ++j) {
      for (k2 = n; k2 >= i; k2--) {
        matrix[k2][j] -= matrix[k2][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t2 = 0;
    for (k2 = j + 1; k2 < n; ++k2) {
      t2 += matrix[k2][j] * coef[k2];
    }
    coef[j] = (matrix[n][j] - t2) / matrix[j][j];
  }
  return coef;
}
var maxiters = 2;
var epsilon = 1e-12;
function loess(data3, x2, y2, bandwidth2) {
  const [xv, yv, ux, uy] = points(data3, x2, y2, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval2 = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval2[0], i1 = interval2[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X3 = 0, Y3 = 0, XY = 0, X23 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k2 = i0; k2 <= i1; ++k2) {
        const xk = xv[k2], yk = yv[k2], w4 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k2], xkw = xk * w4;
        W += w4;
        X3 += xkw;
        Y3 += yk * w4;
        XY += yk * xkw;
        X23 += xk * xkw;
      }
      const [a, b2] = ols(X3 / W, Y3 / W, XY / W, X23 / W);
      yhat[i] = a + b2 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval2);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median(residuals);
    if (Math.abs(medianResidual) < epsilon) break;
    for (let i = 0, arg, w4; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon : (w4 = 1 - arg * arg) * w4;
    }
  }
  return output(xv, yhat, ux, uy);
}
function tricube(x2) {
  return (x2 = 1 - x2 * x2 * x2) * x2 * x2;
}
function updateInterval(xv, i, interval2) {
  const val = xv[i];
  let left = interval2[0], right = interval2[1] + 1;
  if (right >= xv.length) return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval2[0] = ++left;
    interval2[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
var MIN_RADIANS = 0.5 * Math.PI / 180;
function sampleCurve(f, extent2, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point5 = (x2) => [x2, f(x2)], minX = extent2[0], maxX = extent2[1], span2 = maxX - minX, stop3 = span2 / maxSteps, prev = [point5(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point5(minX + i / minSteps * span2));
    }
    prev.push(point5(maxX));
    return prev;
  } else {
    next.push(point5(maxX));
    for (let i = minSteps; --i > 0; ) {
      next.push(point5(minX + i / minSteps * span2));
    }
  }
  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span2;
  const sy = scaleY(p0[1], next);
  while (p1) {
    const pm = point5((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop3;
    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p0 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function scaleY(init2, points2) {
  let ymin = init2;
  let ymax = init2;
  const n = points2.length;
  for (let i = 0; i < n; ++i) {
    const y2 = points2[i][1];
    if (y2 < ymin) ymin = y2;
    if (y2 > ymax) ymax = y2;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r2, sx, sy) {
  const a0 = Math.atan2(sy * (r2[1] - p[1]), sx * (r2[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}

// node_modules/vega-transforms/build/vega-transforms.module.js
function multikey(f) {
  return (x2) => {
    const n = f.length;
    let i = 1, k2 = String(f[0](x2));
    for (; i < n; ++i) {
      k2 += "|" + f[i](x2);
    }
    return k2;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field3, as) {
  return as || op + (!field3 ? "" : "_" + field3);
}
var noop = () => {
};
var base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
var AggregateOps = {
  values: {
    init: (m) => m.cell.store = true,
    value: (m) => m.cell.data.values(),
    idx: -1
  },
  count: {
    value: (m) => m.cell.num
  },
  __count__: {
    value: (m) => m.missing + m.valid
  },
  missing: {
    value: (m) => m.missing
  },
  valid: {
    value: (m) => m.valid
  },
  sum: {
    init: (m) => m.sum = 0,
    value: (m) => m.valid ? m.sum : void 0,
    add: (m, v) => m.sum += +v,
    rem: (m, v) => m.sum -= v
  },
  product: {
    init: (m) => m.product = 1,
    value: (m) => m.valid ? m.product : void 0,
    add: (m, v) => m.product *= v,
    rem: (m, v) => m.product /= v
  },
  mean: {
    init: (m) => m.mean = 0,
    value: (m) => m.valid ? m.mean : void 0,
    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),
    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)
  },
  average: {
    value: (m) => m.valid ? m.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (m) => m.dev = 0,
    value: (m) => m.valid > 1 ? m.dev / (m.valid - 1) : void 0,
    add: (m, v) => m.dev += m.mean_d * (v - m.mean),
    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (m) => m.valid > 1 ? m.dev / m.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (m) => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (m) => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (m) => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (m) => m.cell.data.distinct(m.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (m) => m.cell.data.ci0(m.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (m) => m.cell.data.ci1(m.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (m) => m.cell.data.q2(m.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (m) => m.cell.data.q1(m.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (m) => m.cell.data.q3(m.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (m) => m.min = void 0,
    value: (m) => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,
    add: (m, v) => {
      if (v < m.min || m.min === void 0) m.min = v;
    },
    rem: (m, v) => {
      if (v <= m.min) m.min = NaN;
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (m) => m.max = void 0,
    value: (m) => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,
    add: (m, v) => {
      if (v > m.max || m.max === void 0) m.max = v;
    },
    rem: (m, v) => {
      if (v >= m.max) m.max = NaN;
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (m) => m.argmin = void 0,
    value: (m) => m.argmin || m.cell.data.argmin(m.get),
    add: (m, v, t2) => {
      if (v < m.min) m.argmin = t2;
    },
    rem: (m, v) => {
      if (v <= m.min) m.argmin = void 0;
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (m) => m.argmax = void 0,
    value: (m) => m.argmax || m.cell.data.argmax(m.get),
    add: (m, v, t2) => {
      if (v > m.max) m.argmax = t2;
    },
    rem: (m, v) => {
      if (v >= m.max) m.argmax = void 0;
    },
    req: ["max", "values"],
    idx: 3
  },
  exponential: {
    init: (m, r2) => {
      m.exp = 0;
      m.exp_r = r2;
    },
    value: (m) => m.valid ? m.exp * (1 - m.exp_r) / (1 - m.exp_r ** m.valid) : void 0,
    add: (m, v) => m.exp = m.exp_r * m.exp + v,
    rem: (m, v) => m.exp = (m.exp - v / m.exp_r ** (m.valid - 1)) / m.exp_r
  },
  exponentialb: {
    value: (m) => m.valid ? m.exp * (1 - m.exp_r) : void 0,
    req: ["exponential"],
    idx: 1
  }
};
var ValidAggregateOps = Object.keys(AggregateOps).filter((d) => d !== "__count__");
function measure(key2, value3) {
  return (out, aggregate_param) => extend({
    name: key2,
    aggregate_param,
    out: out || key2
  }, base_op, value3);
}
[...ValidAggregateOps, "__count__"].forEach((key2) => {
  AggregateOps[key2] = measure(key2, AggregateOps[key2]);
});
function createMeasure(op, param2, name4) {
  return AggregateOps[op](name4, param2);
}
function compareIndex(a, b2) {
  return a.idx - b2.idx;
}
function resolve(agg) {
  const map2 = {};
  agg.forEach((a) => map2[a.name] = a);
  const getreqs = (a) => {
    if (!a.req) return;
    a.req.forEach((key2) => {
      if (!map2[key2]) getreqs(map2[key2] = AggregateOps[key2]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map2).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.aggregate_param == null ? op.init(this) : op.init(this, op.aggregate_param));
}
function add2(v, t2) {
  if (v == null || v === "") {
    ++this.missing;
    return;
  }
  if (v !== v) return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v, t2));
}
function rem(v, t2) {
  if (v == null || v === "") {
    --this.missing;
    return;
  }
  if (v !== v) return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v, t2));
}
function set(t2) {
  this._out.forEach((op) => t2[op.out] = op.value(this));
  return t2;
}
function compileMeasures(agg, field3) {
  const get6 = field3 || identity2, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add2;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get6;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key2) {
  this._key = key2 ? field(key2) : tupleid;
  this.reset();
}
var prototype$1 = TupleStore.prototype;
prototype$1.reset = function() {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype$1.add = function(v) {
  this._add.push(v);
};
prototype$1.rem = function(v) {
  this._rem.push(v);
};
prototype$1.values = function() {
  this._get = null;
  if (this._rem.length === 0) return this._add;
  const a = this._add, r2 = this._rem, k2 = this._key, n = a.length, m = r2.length, x2 = Array(n - m), map2 = {};
  let i, j, v;
  for (i = 0; i < m; ++i) {
    map2[k2(r2[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map2[k2(v = a[i])]) {
      map2[k2(v)] = 0;
    } else {
      x2[j++] = v;
    }
  }
  this._rem = [];
  return this._add = x2;
};
prototype$1.distinct = function(get6) {
  const v = this.values(), map2 = {};
  let n = v.length, count = 0, s;
  while (--n >= 0) {
    s = get6(v[n]) + "";
    if (!has(map2, s)) {
      map2[s] = 1;
      ++count;
    }
  }
  return count;
};
prototype$1.extent = function(get6) {
  if (this._get !== get6 || !this._ext) {
    const v = this.values(), i = extentIndex(v, get6);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get6;
  }
  return this._ext;
};
prototype$1.argmin = function(get6) {
  return this.extent(get6)[0] || {};
};
prototype$1.argmax = function(get6) {
  return this.extent(get6)[1] || {};
};
prototype$1.min = function(get6) {
  const m = this.extent(get6)[0];
  return m != null ? get6(m) : void 0;
};
prototype$1.max = function(get6) {
  const m = this.extent(get6)[1];
  return m != null ? get6(m) : void 0;
};
prototype$1.quartile = function(get6) {
  if (this._get !== get6 || !this._q) {
    this._q = quartiles(this.values(), get6);
    this._get = get6;
  }
  return this._q;
};
prototype$1.q1 = function(get6) {
  return this.quartile(get6)[0];
};
prototype$1.q2 = function(get6) {
  return this.quartile(get6)[1];
};
prototype$1.q3 = function(get6) {
  return this.quartile(get6)[2];
};
prototype$1.ci = function(get6) {
  if (this._get !== get6 || !this._ci) {
    this._ci = bootstrapCI(this.values(), 1e3, 0.05, get6);
    this._get = get6;
  }
  return this._ci;
};
prototype$1.ci0 = function(get6) {
  return this.ci(get6)[0];
};
prototype$1.ci1 = function(get6) {
  return this.ci(get6)[1];
};
function Aggregate(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
Aggregate.Definition = {
  "type": "Aggregate",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "aggregate_params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "drop",
    "type": "boolean",
    "default": true
  }, {
    "name": "cross",
    "type": "boolean",
    "default": false
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Aggregate, Transform, {
  transform(_, pulse2) {
    const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : /* @__PURE__ */ Object.create(null);
      pulse2.visit(pulse2.SOURCE, (t2) => aggr.add(t2));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse2.visit(pulse2.REM, (t2) => aggr.rem(t2));
      pulse2.visit(pulse2.ADD, (t2) => aggr.add(t2));
    }
    out.modifies(aggr._outputs);
    aggr._drop = _.drop !== false;
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse2.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this, curr = aggr.value, dims = aggr._dnames, vals2 = dims.map(() => ({})), n = dims.length;
    function collect2(cells) {
      let key2, i, t2, v;
      for (key2 in cells) {
        t2 = cells[key2].tuple;
        for (i = 0; i < n; ++i) {
          vals2[i][v = t2[dims[i]]] = v;
        }
      }
    }
    collect2(aggr._prev);
    collect2(curr);
    function generate3(base, tuple, index3) {
      const name4 = dims[index3], v = vals2[index3++];
      for (const k2 in v) {
        const key2 = base ? base + "|" + k2 : k2;
        tuple[name4] = v[k2];
        if (index3 < n) generate3(key2, tuple, index3);
        else if (!curr[key2]) aggr.cell(key2, tuple);
      }
    }
    generate3("", {}, 0);
  },
  init(_) {
    const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
    function inputVisit(get6) {
      const fields2 = array(accessorFields(get6)), n2 = fields2.length;
      let i2 = 0, f;
      for (; i2 < n2; ++i2) {
        if (!inputMap[f = fields2[i2]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }
    this._dims = array(_.groupby);
    this._dnames = this._dims.map((d) => {
      const dname = accessorName(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null], ops2 = _.ops || ["count"], aggregate_params = _.aggregate_params || [null], as = _.as || [], n = fields.length, map2 = {};
    let field3, op, aggregate_param, m, mname, outname, i;
    if (n !== ops2.length) {
      error("Unmatched number of fields and aggregate ops.");
    }
    for (i = 0; i < n; ++i) {
      field3 = fields[i];
      op = ops2[i];
      aggregate_param = aggregate_params[i] || null;
      if (field3 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      mname = accessorName(field3);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === "count") {
        this._counts.push(outname);
        continue;
      }
      m = map2[mname];
      if (!m) {
        inputVisit(field3);
        m = map2[mname] = [];
        m.field = field3;
        this._measures.push(m);
      }
      if (op !== "count") this._countOnly = false;
      m.push(createMeasure(op, aggregate_param, outname));
    }
    this._measures = this._measures.map((m2) => compileMeasures(m2, m2.field));
    return /* @__PURE__ */ Object.create(null);
  },
  // -- Cell Management -----
  cellkey: groupkey(),
  cell(key2, t2) {
    let cell2 = this.value[key2];
    if (!cell2) {
      cell2 = this.value[key2] = this.newcell(key2, t2);
      this._adds[this._alen++] = cell2;
    } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._adds[this._alen++] = cell2;
    } else if (cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._mods[this._mlen++] = cell2;
    }
    return cell2;
  },
  newcell(key2, t2) {
    const cell2 = {
      key: key2,
      num: 0,
      agg: null,
      tuple: this.newtuple(t2, this._prev && this._prev[key2]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures, n = measures.length;
      cell2.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell2.agg[i] = new measures[i](cell2);
      }
    }
    if (cell2.store) {
      cell2.data = new TupleStore();
    }
    return cell2;
  },
  newtuple(t2, p) {
    const names = this._dnames, dims = this._dims, n = dims.length, x2 = {};
    for (let i = 0; i < n; ++i) {
      x2[names[i]] = dims[i](t2);
    }
    return p ? replace(p.tuple, x2) : ingest$1(x2);
  },
  clean() {
    const cells = this.value;
    for (const key2 in cells) {
      if (cells[key2].num === 0) {
        delete cells[key2];
      }
    }
  },
  // -- Process Tuples -----
  add(t2) {
    const key2 = this.cellkey(t2), cell2 = this.cell(key2, t2);
    cell2.num += 1;
    if (this._countOnly) return;
    if (cell2.store) cell2.data.add(t2);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t2), t2);
    }
  },
  rem(t2) {
    const key2 = this.cellkey(t2), cell2 = this.cell(key2, t2);
    cell2.num -= 1;
    if (this._countOnly) return;
    if (cell2.store) cell2.data.rem(t2);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t2), t2);
    }
  },
  celltuple(cell2) {
    const tuple = cell2.tuple, counts = this._counts;
    if (cell2.store) {
      cell2.data.values();
    }
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell2.num;
    }
    if (!this._countOnly) {
      const agg = cell2.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds, mods = this._mods, prev = this._prev, drop = this._drop, add5 = out.add, rem2 = out.rem, mod = out.mod;
    let cell2, key2, i, n;
    if (prev) for (key2 in prev) {
      cell2 = prev[key2];
      if (!drop || cell2.num) rem2.push(cell2.tuple);
    }
    for (i = 0, n = this._alen; i < n; ++i) {
      add5.push(this.celltuple(adds[i]));
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell2 = mods[i];
      (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
    this._prev = null;
    return out;
  }
});
var EPSILON$1 = 1e-14;
function Bin(params2) {
  Transform.call(this, null, params2);
}
Bin.Definition = {
  "type": "Bin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "anchor",
    "type": "number"
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 20
  }, {
    "name": "base",
    "type": "number",
    "default": 10
  }, {
    "name": "divide",
    "type": "number",
    "array": true,
    "default": [5, 2]
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "span",
    "type": "number"
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "steps",
    "type": "number",
    "array": true
  }, {
    "name": "minstep",
    "type": "number",
    "default": 0
  }, {
    "name": "nice",
    "type": "boolean",
    "default": true
  }, {
    "name": "name",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["bin0", "bin1"]
  }]
};
inherits(Bin, Transform, {
  transform(_, pulse2) {
    const band2 = _.interval !== false, bins2 = this._bins(_), start = bins2.start, step = bins2.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
    let flag2;
    if (_.modified()) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
    } else {
      flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
    }
    pulse2.visit(flag2, band2 ? (t2) => {
      const v = bins2(t2);
      t2[b0] = v;
      t2[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : (t2) => t2[b0] = bins2(t2));
    return pulse2.modifies(band2 ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field3 = _.field, bins2 = bin2(_), step = bins2.step;
    let start = bins2.start, stop3 = start + Math.ceil((bins2.stop - start) / step) * step, a, d;
    if ((a = _.anchor) != null) {
      d = a - (start + step * Math.floor((a - start) / step));
      start += d;
      stop3 += d;
    }
    const f = function(t2) {
      let v = toNumber(field3(t2));
      return v == null ? null : v < start ? -Infinity : v > stop3 ? Infinity : (v = Math.max(start, Math.min(v, stop3 - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };
    f.start = start;
    f.stop = bins2.stop;
    f.step = step;
    return this.value = accessor(f, accessorFields(field3), _.name || "bin_" + accessorName(field3));
  }
});
function SortedList(idFunc, source4, input) {
  const $2 = idFunc;
  let data3 = source4 || [], add5 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t2) => add5.push(t2),
    remove: (t2) => rem2[$2(t2)] = ++cnt,
    size: () => data3.length,
    data: (compare5, resort) => {
      if (cnt) {
        data3 = data3.filter((t2) => !rem2[$2(t2)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare5) {
        data3.sort(compare5);
      }
      if (add5.length) {
        data3 = compare5 ? merge(compare5, data3, add5.sort(compare5)) : data3.concat(add5);
        add5 = [];
      }
      return data3;
    }
  };
}
function Collect(params2) {
  Transform.call(this, [], params2);
}
Collect.Definition = {
  "type": "Collect",
  "metadata": {
    "source": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }]
};
inherits(Collect, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort3 = _.sort, mod = pulse2.changed() || sort3 && (_.modified("sort") || pulse2.modified(sort3.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data(stableCompare(sort3), mod);
    if (pulse2.source && pulse2.source.root) {
      this.value.root = pulse2.source.root;
    }
    return out;
  }
});
function Compare(params2) {
  Operator.call(this, null, update$5, params2);
}
inherits(Compare, Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : compare2(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
CountPattern.Definition = {
  "type": "CountPattern",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "case",
    "type": "enum",
    "values": ["upper", "lower", "mixed"],
    "default": "mixed"
  }, {
    "name": "pattern",
    "type": "string",
    "default": '[\\w"]+'
  }, {
    "name": "stopwords",
    "type": "string",
    "default": ""
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["text", "count"]
  }]
};
function tokenize(text4, tcase, match3) {
  switch (tcase) {
    case "upper":
      text4 = text4.toUpperCase();
      break;
    case "lower":
      text4 = text4.toLowerCase();
      break;
  }
  return text4.match(match3);
}
inherits(CountPattern, Transform, {
  transform(_, pulse2) {
    const process2 = (update3) => (tuple) => {
      var tokens = tokenize(get6(tuple), _.case, match3) || [], t2;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop3.test(t2 = tokens[i])) update3(t2);
      }
    };
    const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match3 = this._match, stop3 = this._stop, get6 = _.field, as = _.as || ["text", "count"], add5 = process2((t2) => counts[t2] = 1 + (counts[t2] || 0)), rem2 = process2((t2) => counts[t2] -= 1);
    if (init2) {
      pulse2.visit(pulse2.SOURCE, add5);
    } else {
      pulse2.visit(pulse2.ADD, add5);
      pulse2.visit(pulse2.REM, rem2);
    }
    return this._finish(pulse2, as);
  },
  _parameterCheck(_, pulse2) {
    let init2 = false;
    if (_.modified("stopwords") || !this._stop) {
      this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
      init2 = true;
    }
    if (_.modified("pattern") || !this._match) {
      this._match = new RegExp(_.pattern || "[\\w']+", "g");
      init2 = true;
    }
    if (_.modified("field") || pulse2.modified(_.field.fields)) {
      init2 = true;
    }
    if (init2) this._counts = {};
    return init2;
  },
  _finish(pulse2, as) {
    const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text4 = as[0], count = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    let w4, t2, c;
    for (w4 in counts) {
      t2 = tuples[w4];
      c = counts[w4] || 0;
      if (!t2 && c) {
        tuples[w4] = t2 = ingest$1({});
        t2[text4] = w4;
        t2[count] = c;
        out.add.push(t2);
      } else if (c === 0) {
        if (t2) out.rem.push(t2);
        counts[w4] = null;
        tuples[w4] = null;
      } else if (t2[count] !== c) {
        t2[count] = c;
        out.mod.push(t2);
      }
    }
    return out.modifies(as);
  }
});
function Cross(params2) {
  Transform.call(this, null, params2);
}
Cross.Definition = {
  "type": "Cross",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "filter",
    "type": "expr"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["a", "b"]
  }]
};
inherits(Cross, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a = as[0], b2 = as[1], reset4 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
    let data3 = this.value;
    if (reset4) {
      if (data3) out.rem = data3;
      data3 = pulse2.materialize(pulse2.SOURCE).source;
      out.add = this.value = cross(data3, a, b2, _.filter || truthy);
    } else {
      out.mod = data3;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross(input, a, b2, filter3) {
  var data3 = [], t2 = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t2[a] = left = input[i];
    for (j = 0; j < n; ++j) {
      t2[b2] = input[j];
      if (filter3(t2)) {
        data3.push(ingest$1(t2));
        t2 = {};
        t2[a] = left;
      }
    }
  }
  return data3;
}
var Distributions = {
  kde,
  mixture,
  normal: gaussian,
  lognormal,
  uniform
};
var DISTRIBUTIONS = "distributions";
var FUNCTION = "function";
var FIELD = "field";
function parse3(def2, data3) {
  const func = def2[FUNCTION];
  if (!has(Distributions, func)) {
    error("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name4 in def2) {
    if (name4 === FIELD) {
      d.data((def2.from || data3()).map(def2[name4]));
    } else if (name4 === DISTRIBUTIONS) {
      d[name4](def2[name4].map((_) => parse3(_, data3)));
    } else if (typeof d[name4] === FUNCTION) {
      d[name4](def2[name4]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
var distributions = [{
  "key": {
    "function": "normal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "lognormal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "uniform"
  },
  "params": [{
    "name": "min",
    "type": "number",
    "default": 0
  }, {
    "name": "max",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "kde"
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "from",
    "type": "data"
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }]
}];
var mixture2 = {
  "key": {
    "function": "mixture"
  },
  "params": [{
    "name": "distributions",
    "type": "param",
    "array": true,
    "params": distributions
  }, {
    "name": "weights",
    "type": "number",
    "array": true
  }]
};
Density.Definition = {
  "type": "Density",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "method",
    "type": "string",
    "default": "pdf",
    "values": ["pdf", "cdf"]
  }, {
    "name": "distribution",
    "type": "param",
    "params": distributions.concat(mixture2)
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(Density, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const dist = parse3(_.distribution, source(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      let method2 = _.method || "pdf";
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (!_.extent && !dist.data) {
        error("Missing density extent parameter.");
      }
      method2 = dist[method2];
      const as = _.as || ["value", "density"], domain4 = _.extent || extent(dist.data()), values5 = sampleCurve(method2, domain4, minsteps, maxsteps).map((v) => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return ingest$1(tuple);
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values5;
    }
    return out;
  }
});
function source(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields) return null;
  return fields.map((f, i) => as[i] || accessorName(f));
}
function partition$1(data3, groupby, field3) {
  const groups = [], get6 = (f) => f(t2);
  let map2, i, n, t2, k2, g;
  if (groupby == null) {
    groups.push(data3.map(field3));
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t2 = data3[i];
      k2 = groupby.map(get6);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        g.dims = k2;
        groups.push(g);
      }
      g.push(field3(t2));
    }
  }
  return groups;
}
var Output = "bin";
function DotBin(params2) {
  Transform.call(this, null, params2);
}
DotBin.Definition = {
  "type": "DotBin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": Output
  }]
};
var autostep = (data3, field3) => span(extent(data3, field3)) / 30;
inherits(DotBin, Transform, {
  transform(_, pulse2) {
    if (this.value && !(_.modified() || pulse2.changed())) {
      return pulse2;
    }
    const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(pulse2.source, _.groupby, identity2), smooth = _.smooth || false, field3 = _.field, step = _.step || autostep(source4, field3), sort3 = stableCompare((a, b2) => field3(a) - field3(b2)), as = _.as || Output, n = groups.length;
    let min4 = Infinity, max4 = -Infinity, i = 0, j;
    for (; i < n; ++i) {
      const g = groups[i].sort(sort3);
      j = -1;
      for (const v of dotbin(g, step, smooth, field3)) {
        if (v < min4) min4 = v;
        if (v > max4) max4 = v;
        g[++j][as] = v;
      }
    }
    this.value = {
      start: min4,
      stop: max4,
      step
    };
    return pulse2.reflow(true).modifies(as);
  }
});
function Expression(params2) {
  Operator.call(this, null, update$4, params2);
  this.modified(true);
}
inherits(Expression, Operator);
function update$4(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor((datum2) => expr2(datum2, _), accessorFields(expr2), accessorName(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
Extent.Definition = {
  "type": "Extent",
  "metadata": {},
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }]
};
inherits(Extent, Transform, {
  transform(_, pulse2) {
    const extent2 = this.value, field3 = _.field, mod = pulse2.changed() || pulse2.modified(field3.fields) || _.modified("field");
    let min4 = extent2[0], max4 = extent2[1];
    if (mod || min4 == null) {
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t2) => {
      const v = toNumber(field3(t2));
      if (v != null) {
        if (v < min4) min4 = v;
        if (v > max4) max4 = v;
      }
    });
    if (!Number.isFinite(min4) || !Number.isFinite(max4)) {
      let name4 = accessorName(field3);
      if (name4) name4 = ` for field "${name4}"`;
      pulse2.dataflow.warn(`Infinite extent${name4}: [${min4}, ${max4}]`);
      min4 = max4 = void 0;
    }
    this.value = [min4, max4];
  }
});
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
inherits(Subflow, Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target2) {
    this.detachSubflow = target2.detachSubflow;
    this.targets().add(target2);
    return target2.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t2) {
    this.count += 1;
    this.value.add.push(t2);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t2) {
    this.count -= 1;
    this.value.rem.push(t2);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t2) {
    this.value.mod.push(t2);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse2) {
    this.value.init(pulse2, pulse2.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function Facet(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap();
  const a = this._targets = [];
  a.active = 0;
  a.forEach = (f) => {
    for (let i = 0, n = a.active; i < n; ++i) {
      f(a[i], i, a);
    }
  };
}
inherits(Facet, Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  // parent argument provided by PreFacet subclass
  subflow(key2, flow, pulse2, parent) {
    const flows = this.value;
    let sf = has(flows, key2) && flows[key2], df, p;
    if (!sf) {
      p = parent || (p = this._group[key2]) && p.tuple;
      df = pulse2.dataflow;
      sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key2, p));
      flows[key2] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse2.stamp) {
      sf.init(pulse2);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    let detached = 0;
    for (const key2 in flows) {
      if (flows[key2].count === 0) {
        const detach = flows[key2].detachSubflow;
        if (detach) detach();
        delete flows[key2];
        ++detached;
      }
    }
    if (detached) {
      const active = this._targets.filter((sf) => sf && sf.count > 0);
      this.initTargets(active);
    }
  },
  initTargets(act) {
    const a = this._targets, n = a.length, m = act ? act.length : 0;
    let i = 0;
    for (; i < m; ++i) {
      a[i] = act[i];
    }
    for (; i < n && a[i] != null; ++i) {
      a[i] = null;
    }
    a.active = m;
  },
  transform(_, pulse2) {
    const df = pulse2.dataflow, key2 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key3) => this.subflow(key3, flow, pulse2);
    this._group = _.group || {};
    this.initTargets();
    pulse2.visit(pulse2.REM, (t2) => {
      const id2 = tupleid(t2), k2 = cache2.get(id2);
      if (k2 !== void 0) {
        cache2.delete(id2);
        subflow(k2).rem(t2);
      }
    });
    pulse2.visit(pulse2.ADD, (t2) => {
      const k2 = key2(t2);
      cache2.set(tupleid(t2), k2);
      subflow(k2).add(t2);
    });
    if (rekey || pulse2.modified(key2.fields)) {
      pulse2.visit(pulse2.MOD, (t2) => {
        const id2 = tupleid(t2), k0 = cache2.get(id2), k1 = key2(t2);
        if (k0 === k1) {
          subflow(k1).mod(t2);
        } else {
          cache2.set(id2, k1);
          subflow(k0).rem(t2);
          subflow(k1).add(t2);
        }
      });
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t2) => {
        subflow(cache2.get(tupleid(t2))).mod(t2);
      });
    }
    if (rekey) {
      pulse2.visit(pulse2.REFLOW, (t2) => {
        const id2 = tupleid(t2), k0 = cache2.get(id2), k1 = key2(t2);
        if (k0 !== k1) {
          cache2.set(id2, k1);
          subflow(k0).rem(t2);
          subflow(k1).add(t2);
        }
      });
    }
    if (pulse2.clean()) {
      df.runAfter(() => {
        this.clean();
        cache2.clean();
      });
    } else if (cache2.empty > df.cleanThreshold) {
      df.runAfter(cache2.clean);
    }
    return pulse2;
  }
});
function Field(params2) {
  Operator.call(this, null, update$3, params2);
}
inherits(Field, Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map((f) => field(f)) : field(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap(), params2);
}
Filter.Definition = {
  "type": "Filter",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }]
};
inherits(Filter, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, cache2 = this.value, output3 = pulse2.fork(), add5 = output3.add, rem2 = output3.rem, mod = output3.mod, test2 = _.expr;
    let isMod = true;
    pulse2.visit(pulse2.REM, (t2) => {
      const id2 = tupleid(t2);
      if (!cache2.has(id2)) rem2.push(t2);
      else cache2.delete(id2);
    });
    pulse2.visit(pulse2.ADD, (t2) => {
      if (test2(t2, _)) add5.push(t2);
      else cache2.set(tupleid(t2), 1);
    });
    function revisit(t2) {
      const id2 = tupleid(t2), b2 = test2(t2, _), s = cache2.get(id2);
      if (b2 && s) {
        cache2.delete(id2);
        add5.push(t2);
      } else if (!b2 && !s) {
        cache2.set(id2, 1);
        rem2.push(t2);
      } else if (isMod && b2 && !s) {
        mod.push(t2);
      }
    }
    pulse2.visit(pulse2.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse2.visit(pulse2.REFLOW, revisit);
    }
    if (cache2.empty > df.cleanThreshold) df.runAfter(cache2.clean);
    return output3;
  }
});
function Flatten(params2) {
  Transform.call(this, [], params2);
}
Flatten.Definition = {
  "type": "Flatten",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "index",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Flatten, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index3 = _.index || null, m = as.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t2) => {
      const arrays = fields.map((f) => f(t2)), maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
      let i = 0, j, d, v;
      for (; i < maxlen; ++i) {
        d = derive(t2);
        for (j = 0; j < m; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }
        if (index3) {
          d[index3] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index3) out.modifies(index3);
    return out.modifies(as);
  }
});
function Fold(params2) {
  Transform.call(this, [], params2);
}
Fold.Definition = {
  "type": "Fold",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["key", "value"]
  }]
};
inherits(Fold, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k2 = as[0], v = as[1], n = fields.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t2) => {
      for (let i = 0, d; i < n; ++i) {
        d = derive(t2);
        d[k2] = fnames[i];
        d[v] = fields[i](t2);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});
function Formula(params2) {
  Transform.call(this, null, params2);
}
Formula.Definition = {
  "type": "Formula",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "required": true
  }, {
    "name": "initonly",
    "type": "boolean"
  }]
};
inherits(Formula, Transform, {
  transform(_, pulse2) {
    const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
    if (mod) {
      pulse2 = pulse2.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse2.modifies(as);
    }
    return pulse2.visit(flag2, (t2) => t2[as] = func(t2, _));
  }
});
function Generate(params2) {
  Transform.call(this, [], params2);
}
inherits(Generate, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), gen = _.generator;
    let data3 = this.value, num = _.size - data3.length, add5, rem2, t2;
    if (num > 0) {
      for (add5 = []; --num >= 0; ) {
        add5.push(t2 = ingest$1(gen(_)));
        data3.push(t2);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add5) : add5;
    } else {
      rem2 = data3.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
      data3 = data3.slice(-num);
    }
    out.source = this.value = data3;
    return out;
  }
});
var Methods = {
  value: "value",
  median,
  mean,
  min,
  max
};
var Empty = [];
function Impute(params2) {
  Transform.call(this, [], params2);
}
Impute.Definition = {
  "type": "Impute",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "keyvals",
    "array": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "enum",
    "default": "value",
    "values": ["value", "mean", "median", "max", "min"]
  }, {
    "name": "value",
    "default": 0
  }]
};
function getValue(_) {
  var m = _.method || Methods.value, v;
  if (Methods[m] == null) {
    error("Unrecognized imputation method: " + m);
  } else if (m === Methods.value) {
    v = _.value !== void 0 ? _.value : 0;
    return () => v;
  } else {
    return Methods[m];
  }
}
function getField(_) {
  const f = _.field;
  return (t2) => t2 ? f(t2) : NaN;
}
inherits(Impute, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field3 = getField(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups = partition(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev = this.value, m = groups.domain.length, group2, value3, gVals, kVal, g, i, j, l, n, t2;
    for (g = 0, l = groups.length; g < l; ++g) {
      group2 = groups[g];
      gVals = group2.values;
      value3 = NaN;
      for (j = 0; j < m; ++j) {
        if (group2[j] != null) continue;
        kVal = groups.domain[j];
        t2 = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i) t2[gNames[i]] = gVals[i];
        t2[kName] = kVal;
        t2[fName] = Number.isNaN(value3) ? value3 = impute(group2, field3) : value3;
        curr.push(ingest$1(t2));
      }
    }
    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }
});
function partition(data3, groupby, key2, keyvals) {
  var get6 = (f) => f(t2), groups = [], domain4 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group2, i, j, k2, n, t2;
  domain4.forEach((k3, i2) => kMap[k3] = i2 + 1);
  for (i = 0, n = data3.length; i < n; ++i) {
    t2 = data3[i];
    k2 = key2(t2);
    j = kMap[k2] || (kMap[k2] = domain4.push(k2));
    gKey = (gVals = groupby ? groupby.map(get6) : Empty) + "";
    if (!(group2 = gMap[gKey])) {
      group2 = gMap[gKey] = [];
      groups.push(group2);
      group2.values = gVals;
    }
    group2[j - 1] = t2;
  }
  groups.domain = domain4;
  return groups;
}
function JoinAggregate(params2) {
  Aggregate.call(this, params2);
}
JoinAggregate.Definition = {
  "type": "JoinAggregate",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(JoinAggregate, Aggregate, {
  transform(_, pulse2) {
    const aggr = this, mod = _.modified();
    let cells;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t2) => aggr.add(t2));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse2.visit(pulse2.REM, (t2) => aggr.rem(t2));
      pulse2.visit(pulse2.ADD, (t2) => aggr.add(t2));
    }
    aggr.changes();
    pulse2.visit(pulse2.SOURCE, (t2) => {
      extend(t2, cells[aggr.cellkey(t2)].tuple);
    });
    return pulse2.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds, mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
  }
});
function KDE(params2) {
  Transform.call(this, null, params2);
}
KDE.Definition = {
  "type": "KDE",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "cumulative",
    "type": "boolean",
    "default": false
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(KDE, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source4, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth2 = _.bandwidth, method2 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values5 = [];
      let domain4 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (_.resolve === "shared") {
        if (!domain4) domain4 = extent(source4, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups.forEach((g) => {
        const density = kde(g, bandwidth2)[method2], scale6 = _.counts ? g.length : 1, local = domain4 || extent(g);
        sampleCurve(density, local, minsteps, maxsteps).forEach((v) => {
          const t2 = {};
          for (let i = 0; i < names.length; ++i) {
            t2[names[i]] = g.dims[i];
          }
          t2[as[0]] = v[0];
          t2[as[1]] = v[1] * scale6;
          values5.push(ingest$1(t2));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values5;
    }
    return out;
  }
});
function Key(params2) {
  Operator.call(this, null, update$2, params2);
}
inherits(Key, Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
}
function Load(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
inherits(Load, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow;
    if (this._pending) {
      return output2(this, pulse2, this._pending);
    }
    if (stop(_)) return pulse2.StopPropagation;
    if (_.values) {
      return output2(this, pulse2, df.parse(_.values, _.format));
    } else if (_.async) {
      const p = df.request(_.url, _.format).then((res) => {
        this._pending = array(res.data);
        return (df2) => df2.touch(this);
      });
      return {
        async: p
      };
    } else {
      return df.request(_.url, _.format).then((res) => output2(this, pulse2, array(res.data)));
    }
  }
});
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output2(op, pulse2, data3) {
  data3.forEach(ingest$1);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data3;
  op._pending = null;
  if (out.rem.length) out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
Lookup.Definition = {
  "type": "Lookup",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "index",
    "type": "index",
    "params": [{
      "name": "from",
      "type": "data",
      "required": true
    }, {
      "name": "key",
      "type": "field",
      "required": true
    }]
  }, {
    "name": "values",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }, {
    "name": "default",
    "default": null
  }]
};
inherits(Lookup, Transform, {
  transform(_, pulse2) {
    const keys5 = _.fields, index3 = _.index, values5 = _.values, defaultValue = _.default == null ? null : _.default, reset4 = _.modified(), n = keys5.length;
    let flag2 = reset4 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set5, m, mods;
    if (values5) {
      m = values5.length;
      if (n > 1 && !as) {
        error('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m) {
        error('The "as" parameter has too few output field names.');
      }
      as = as || values5.map(accessorName);
      set5 = function(t2) {
        for (var i = 0, k2 = 0, j, v; i < n; ++i) {
          v = index3.get(keys5[i](t2));
          if (v == null) for (j = 0; j < m; ++j, ++k2) t2[as[k2]] = defaultValue;
          else for (j = 0; j < m; ++j, ++k2) t2[as[k2]] = values5[j](v);
        }
      };
    } else {
      if (!as) {
        error("Missing output field names.");
      }
      set5 = function(t2) {
        for (var i = 0, v; i < n; ++i) {
          v = index3.get(keys5[i](t2));
          t2[as[i]] = v == null ? defaultValue : v;
        }
      };
    }
    if (reset4) {
      out = pulse2.reflow(true);
    } else {
      mods = keys5.some((k2) => pulse2.modified(k2.fields));
      flag2 |= mods ? pulse2.MOD : 0;
    }
    pulse2.visit(flag2, set5);
    return out.modifies(as);
  }
});
function MultiExtent(params2) {
  Operator.call(this, null, update$1, params2);
}
inherits(MultiExtent, Operator);
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min4 = Infinity, max4 = -Infinity, i, e2;
  for (i = 0; i < n; ++i) {
    e2 = ext[i];
    if (e2[0] < min4) min4 = e2[0];
    if (e2[1] > max4) max4 = e2[1];
  }
  return [min4, max4];
}
function MultiValues(params2) {
  Operator.call(this, null, update2, params2);
}
inherits(MultiValues, Operator);
function update2(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data3, _2) => data3.concat(_2), []);
}
function Params(params2) {
  Transform.call(this, null, params2);
}
inherits(Params, Transform, {
  transform(_, pulse2) {
    this.modified(_.modified());
    this.value = _;
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function Pivot(params2) {
  Aggregate.call(this, params2);
}
Pivot.Definition = {
  "type": "Pivot",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "value",
    "type": "field",
    "required": true
  }, {
    "name": "op",
    "type": "enum",
    "values": ValidAggregateOps,
    "default": "sum"
  }, {
    "name": "limit",
    "type": "number",
    "default": 0
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,
  transform(_, pulse2) {
    return this._transform(aggregateParams(_, pulse2), pulse2);
  }
});
function aggregateParams(_, pulse2) {
  const key2 = _.field, value3 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key2).concat(accessorFields(value3)), keys5 = pivotKeys(key2, _.limit || 0, pulse2);
  if (pulse2.changed()) _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys5.map(() => op),
    fields: keys5.map((k2) => get(k2, key2, value3, fields)),
    as: keys5.map((k2) => k2 + ""),
    modified: _.modified.bind(_)
  };
}
function get(k2, key2, value3, fields) {
  return accessor((d) => key2(d) === k2 ? value3(d) : NaN, fields, k2 + "");
}
function pivotKeys(key2, limit, pulse2) {
  const map2 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t2) => {
    const k2 = key2(t2);
    if (!map2[k2]) {
      map2[k2] = 1;
      list.push(k2);
    }
  });
  list.sort(ascending2);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet(params2) {
  Facet.call(this, params2);
}
inherits(PreFacet, Facet, {
  transform(_, pulse2) {
    const flow = _.subflow, field3 = _.field, subflow = (t2) => this.subflow(tupleid(t2), flow, pulse2, t2);
    if (_.modified("field") || field3 && pulse2.modified(accessorFields(field3))) {
      error("PreFacet does not support field modification.");
    }
    this.initTargets();
    if (field3) {
      pulse2.visit(pulse2.MOD, (t2) => {
        const sf = subflow(t2);
        field3(t2).forEach((_2) => sf.mod(_2));
      });
      pulse2.visit(pulse2.ADD, (t2) => {
        const sf = subflow(t2);
        field3(t2).forEach((_2) => sf.add(ingest$1(_2)));
      });
      pulse2.visit(pulse2.REM, (t2) => {
        const sf = subflow(t2);
        field3(t2).forEach((_2) => sf.rem(_2));
      });
    } else {
      pulse2.visit(pulse2.MOD, (t2) => subflow(t2).mod(t2));
      pulse2.visit(pulse2.ADD, (t2) => subflow(t2).add(t2));
      pulse2.visit(pulse2.REM, (t2) => subflow(t2).rem(t2));
    }
    if (pulse2.clean()) {
      pulse2.runAfter(() => this.clean());
    }
    return pulse2;
  }
});
function Project(params2) {
  Transform.call(this, null, params2);
}
Project.Definition = {
  "type": "Project",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }]
};
inherits(Project, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s, t2) => project(s, t2, fields, as) : rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    pulse2.visit(pulse2.REM, (t2) => {
      const id2 = tupleid(t2);
      out.rem.push(lut[id2]);
      lut[id2] = null;
    });
    pulse2.visit(pulse2.ADD, (t2) => {
      const dt = derive2(t2, ingest$1({}));
      lut[tupleid(t2)] = dt;
      out.add.push(dt);
    });
    pulse2.visit(pulse2.MOD, (t2) => {
      out.mod.push(derive2(t2, lut[tupleid(t2)]));
    });
    return out;
  }
});
function project(s, t2, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t2[as[i]] = fields[i](s);
  }
  return t2;
}
function Proxy(params2) {
  Transform.call(this, null, params2);
}
inherits(Proxy, Transform, {
  transform(_, pulse2) {
    this.value = _.value;
    return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function Quantile(params2) {
  Transform.call(this, null, params2);
}
Quantile.Definition = {
  "type": "Quantile",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "probs",
    "type": "number",
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 0.01
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["prob", "value"]
  }]
};
var EPSILON = 1e-14;
inherits(Quantile, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
    if (this.value && !_.modified() && !pulse2.changed()) {
      out.source = this.value;
      return out;
    }
    const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source4, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values5 = [], step = _.step || 0.01, p = _.probs || range(step / 2, 1 - EPSILON, step), n = p.length;
    groups.forEach((g) => {
      const q = quantiles(g, p);
      for (let i = 0; i < n; ++i) {
        const t2 = {};
        for (let i2 = 0; i2 < names.length; ++i2) {
          t2[names[i2]] = g.dims[i2];
        }
        t2[as[0]] = p[i];
        t2[as[1]] = q[i];
        values5.push(ingest$1(t2));
      }
    });
    if (this.value) out.rem = this.value;
    this.value = out.add = out.source = values5;
    return out;
  }
});
function Relay(params2) {
  Transform.call(this, null, params2);
}
inherits(Relay, Transform, {
  transform(_, pulse2) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse2.fork(pulse2.NO_SOURCE);
      pulse2.visit(pulse2.REM, (t2) => {
        const id2 = tupleid(t2);
        out.rem.push(lut[id2]);
        lut[id2] = null;
      });
      pulse2.visit(pulse2.ADD, (t2) => {
        const dt = derive(t2);
        lut[tupleid(t2)] = dt;
        out.add.push(dt);
      });
      pulse2.visit(pulse2.MOD, (t2) => {
        const dt = lut[tupleid(t2)];
        for (const k2 in t2) {
          dt[k2] = t2[k2];
          out.modifies(k2);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
Sample.Definition = {
  "type": "Sample",
  "metadata": {},
  "params": [{
    "name": "size",
    "type": "number",
    "default": 1e3
  }]
};
inherits(Sample, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map2 = this.value.reduce((m, t2) => (m[tupleid(t2)] = 1, m), {});
    let res = this.value, cnt = this.count, cap = 0;
    function update3(t2) {
      let p, idx;
      if (res.length < num) {
        res.push(t2);
      } else {
        idx = ~~((cnt + 1) * random());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map2[tupleid(p)]) out.rem.push(p);
          res[idx] = t2;
        }
      }
      ++cnt;
    }
    if (pulse2.rem.length) {
      pulse2.visit(pulse2.REM, (t2) => {
        const id2 = tupleid(t2);
        if (map2[id2]) {
          map2[id2] = -1;
          out.rem.push(t2);
        }
        --cnt;
      });
      res = res.filter((t2) => map2[tupleid(t2)] !== -1);
    }
    if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
      cap = cnt = res.length;
      pulse2.visit(pulse2.SOURCE, (t2) => {
        if (!map2[tupleid(t2)]) update3(t2);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map2[tupleid(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse2.mod.length) {
      pulse2.visit(pulse2.MOD, (t2) => {
        if (map2[tupleid(t2)]) out.mod.push(t2);
      });
    }
    if (pulse2.add.length) {
      pulse2.visit(pulse2.ADD, update3);
    }
    if (pulse2.add.length || cap < 0) {
      out.add = res.filter((t2) => !map2[tupleid(t2)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});
function Sequence(params2) {
  Transform.call(this, null, params2);
}
Sequence.Definition = {
  "type": "Sequence",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "start",
    "type": "number",
    "required": true
  }, {
    "name": "stop",
    "type": "number",
    "required": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "as",
    "type": "string",
    "default": "data"
  }]
};
inherits(Sequence, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) return;
    const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
    out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
    this.value = range(_.start, _.stop, _.step || 1).map((v) => {
      const t2 = {};
      t2[as] = v;
      return ingest$1(t2);
    });
    out.add = pulse2.add.concat(this.value);
    return out;
  }
});
function Sieve(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Sieve, Transform, {
  transform(_, pulse2) {
    this.value = pulse2.source;
    return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
var OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
  "type": "TimeUnit",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "units",
    "type": "enum",
    "values": TIME_UNITS,
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 40
  }, {
    "name": "extent",
    "type": "date",
    "array": true
  }, {
    "name": "timezone",
    "type": "enum",
    "default": "local",
    "values": ["local", "utc"]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": OUTPUT
  }]
};
inherits(TimeUnit, Transform, {
  transform(_, pulse2) {
    const field3 = _.field, band2 = _.interval !== false, utc = _.timezone === "utc", floor3 = this._floor(_, pulse2), offset4 = (utc ? utcInterval : timeInterval)(floor3.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor3.step;
    let min4 = floor3.start || Infinity, max4 = floor3.stop || -Infinity, flag2 = pulse2.ADD;
    if (_.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(field3))) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(flag2, (t2) => {
      const v = field3(t2);
      let a, b2;
      if (v == null) {
        t2[u0] = null;
        if (band2) t2[u1] = null;
      } else {
        t2[u0] = a = b2 = floor3(v);
        if (band2) t2[u1] = b2 = offset4(a, step);
        if (a < min4) min4 = a;
        if (b2 > max4) max4 = b2;
      }
    });
    floor3.start = min4;
    floor3.stop = max4;
    return pulse2.modifies(band2 ? as : u0);
  },
  _floor(_, pulse2) {
    const utc = _.timezone === "utc";
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : bin({
      extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
      maxbins: _.maxbins
    });
    const tunits = timeUnits(units), prev = this.value || {}, floor3 = (utc ? utcFloor : timeFloor)(tunits, step);
    floor3.unit = peek(tunits);
    floor3.units = tunits;
    floor3.step = step;
    floor3.start = prev.start;
    floor3.stop = prev.stop;
    return this.value = floor3;
  }
});
function TupleIndex(params2) {
  Transform.call(this, fastmap(), params2);
}
inherits(TupleIndex, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, field3 = _.field, index3 = this.value, set5 = (t2) => index3.set(field3(t2), t2);
    let mod = true;
    if (_.modified("field") || pulse2.modified(field3.fields)) {
      index3.clear();
      pulse2.visit(pulse2.SOURCE, set5);
    } else if (pulse2.changed()) {
      pulse2.visit(pulse2.REM, (t2) => index3.delete(field3(t2)));
      pulse2.visit(pulse2.ADD, set5);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index3.empty > df.cleanThreshold) df.runAfter(index3.clean);
    return pulse2.fork();
  }
});
function Values(params2) {
  Transform.call(this, null, params2);
}
inherits(Values, Transform, {
  transform(_, pulse2) {
    const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
    if (run2) {
      this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
    }
  }
});
function WindowOp(op, field3, param2, as) {
  const fn = WindowOps[op](field3, param2);
  return {
    init: fn.init || zero,
    update: function(w4, t2) {
      t2[as] = fn.next(w4);
    }
  };
}
var WindowOps = {
  row_number: function() {
    return {
      next: (w4) => w4.index + 1
    };
  },
  rank: function() {
    let rank2;
    return {
      init: () => rank2 = 1,
      next: (w4) => {
        const i = w4.index, data3 = w4.data;
        return i && w4.compare(data3[i - 1], data3[i]) ? rank2 = i + 1 : rank2;
      }
    };
  },
  dense_rank: function() {
    let drank;
    return {
      init: () => drank = 1,
      next: (w4) => {
        const i = w4.index, d = w4.data;
        return i && w4.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function() {
    const rank2 = WindowOps.rank(), next = rank2.next;
    return {
      init: rank2.init,
      next: (w4) => (next(w4) - 1) / (w4.data.length - 1)
    };
  },
  cume_dist: function() {
    let cume;
    return {
      init: () => cume = 0,
      next: (w4) => {
        const d = w4.data, c = w4.compare;
        let i = w4.index;
        if (cume < i) {
          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function(field3, num) {
    num = +num;
    if (!(num > 0)) error("ntile num must be greater than zero.");
    const cume = WindowOps.cume_dist(), next = cume.next;
    return {
      init: cume.init,
      next: (w4) => Math.ceil(num * next(w4))
    };
  },
  lag: function(field3, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w4) => {
        const i = w4.index - offset4;
        return i >= 0 ? field3(w4.data[i]) : null;
      }
    };
  },
  lead: function(field3, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w4) => {
        const i = w4.index + offset4, d = w4.data;
        return i < d.length ? field3(d[i]) : null;
      }
    };
  },
  first_value: function(field3) {
    return {
      next: (w4) => field3(w4.data[w4.i0])
    };
  },
  last_value: function(field3) {
    return {
      next: (w4) => field3(w4.data[w4.i1 - 1])
    };
  },
  nth_value: function(field3, nth) {
    nth = +nth;
    if (!(nth > 0)) error("nth_value nth must be greater than zero.");
    return {
      next: (w4) => {
        const i = w4.i0 + (nth - 1);
        return i < w4.i1 ? field3(w4.data[i]) : null;
      }
    };
  },
  prev_value: function(field3) {
    let prev;
    return {
      init: () => prev = null,
      next: (w4) => {
        const v = field3(w4.data[w4.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function(field3) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: (w4) => {
        const d = w4.data;
        return w4.index <= i ? v : (i = find(field3, d, w4.index)) < 0 ? (i = d.length, v = null) : v = field3(d[i]);
      }
    };
  }
};
function find(field3, data3, index3) {
  for (let n = data3.length; index3 < n; ++index3) {
    const v = field3(data3[index3]);
    if (v != null) return index3;
  }
  return -1;
}
var ValidWindowOps = Object.keys(WindowOps);
function WindowState(_) {
  const ops2 = array(_.ops), fields = array(_.fields), params2 = array(_.params), aggregate_params = array(_.aggregate_params), as = array(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map2 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field3 = fields[i], param2 = params2[i], aggregate_param = aggregate_params[i] || null, mname = accessorName(field3), name4 = measureName(op, mname, as[i]);
    visitInputs(field3);
    outputs.push(name4);
    if (has(WindowOps, op)) {
      windows.push(WindowOp(op, field3, param2, name4));
    } else {
      if (field3 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name4);
        return;
      }
      countOnly = false;
      let m = map2[mname];
      if (!m) {
        m = map2[mname] = [];
        m.field = field3;
        measures.push(m);
      }
      m.push(createMeasure(op, aggregate_param, name4));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
var prototype = WindowState.prototype;
prototype.init = function() {
  this.windows.forEach((_) => _.init());
  if (this.cell) this.cell.init();
};
prototype.update = function(w4, t2) {
  const cell2 = this.cell, wind = this.windows, data3 = w4.data, m = wind && wind.length;
  let j;
  if (cell2) {
    for (j = w4.p0; j < w4.i0; ++j) cell2.rem(data3[j]);
    for (j = w4.p1; j < w4.i1; ++j) cell2.add(data3[j]);
    cell2.set(t2);
  }
  for (j = 0; j < m; ++j) wind[j].update(w4, t2);
};
function cell(measures, counts, countOnly) {
  measures = measures.map((m) => compileMeasures(m, m.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i) a[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t2) {
    cell2.num += 1;
    if (countOnly) return;
    if (store) store.add(t2);
    for (let i2 = 0; i2 < n; ++i2) {
      a[i2].add(a[i2].get(t2), t2);
    }
  };
  cell2.rem = function(t2) {
    cell2.num -= 1;
    if (countOnly) return;
    if (store) store.rem(t2);
    for (let i2 = 0; i2 < n; ++i2) {
      a[i2].rem(a[i2].get(t2), t2);
    }
  };
  cell2.set = function(t2) {
    let i2, n2;
    if (store) store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2) t2[counts[i2]] = cell2.num;
    if (!countOnly) for (i2 = 0, n2 = a.length; i2 < n2; ++i2) a[i2].set(t2);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store) store.reset();
    for (let i2 = 0; i2 < n; ++i2) a[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  "type": "Window",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidWindowOps.concat(ValidAggregateOps)
  }, {
    "name": "params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "aggregate_params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "frame",
    "type": "number",
    "null": true,
    "array": true,
    "length": 2,
    "default": [null, 0]
  }, {
    "name": "ignorePeers",
    "type": "boolean",
    "default": false
  }]
};
inherits(Window, Transform, {
  transform(_, pulse2) {
    this.stamp = pulse2.stamp;
    const mod = _.modified(), cmp2 = stableCompare(_.sort), key2 = groupkey(_.groupby), group2 = (t2) => this.group(key2(t2));
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }
    if (mod || pulse2.modified(state.inputs)) {
      this.value = {};
      pulse2.visit(pulse2.SOURCE, (t2) => group2(t2).add(t2));
    } else {
      pulse2.visit(pulse2.REM, (t2) => group2(t2).remove(t2));
      pulse2.visit(pulse2.ADD, (t2) => group2(t2).add(t2));
    }
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp2, _);
    }
    this._mlen = 0;
    this._mods = [];
    return pulse2.reflow(mod).modifies(state.outputs);
  },
  group(key2) {
    let group2 = this.value[key2];
    if (!group2) {
      group2 = this.value[key2] = SortedList(tupleid);
      group2.stamp = -1;
    }
    if (group2.stamp < this.stamp) {
      group2.stamp = this.stamp;
      this._mods[this._mlen++] = group2;
    }
    return group2;
  }
});
function processPartition(list, state, cmp2, _) {
  const sort3 = _.sort, range6 = sort3 && !_.ignorePeers, frame = _.frame || [null, 0], data3 = list.data(cmp2), n = data3.length, b2 = range6 ? bisector(sort3) : null, w4 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data3,
    compare: sort3 || constant(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w4, frame, i, n);
    if (range6) adjustRange(w4, b2);
    state.update(w4, data3[i]);
  }
}
function setWindow(w4, f, i, n) {
  w4.p0 = w4.i0;
  w4.p1 = w4.i1;
  w4.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w4.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w4.index = i;
}
function adjustRange(w4, bisect2) {
  const r0 = w4.i0, r1 = w4.i1 - 1, c = w4.compare, d = w4.data, n = d.length - 1;
  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w4.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c(d[r1], d[r1 + 1])) w4.i1 = bisect2.right(d, d[r1]);
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var vega_view_transforms_module_exports = {};
__export(vega_view_transforms_module_exports, {
  bound: () => Bound,
  identifier: () => Identifier,
  mark: () => Mark,
  overlap: () => Overlap,
  render: () => Render,
  viewlayout: () => ViewLayout
});

// node_modules/vega-canvas/build/vega-canvas.browser.module.js
function domCanvas(w4, h2) {
  if (typeof document !== "undefined" && document.createElement) {
    const c = document.createElement("canvas");
    if (c && c.getContext) {
      c.width = w4;
      c.height = h2;
      return c;
    }
  }
  return null;
}
var domImage = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-scale/build/vega-scale.module.js
function bandSpace(count, paddingInner2, paddingOuter2) {
  const space = count - paddingInner2 + paddingOuter2 * 2;
  return count ? space > 0 ? space : 1 : 0;
}
var Identity = "identity";
var Linear = "linear";
var Log = "log";
var Pow = "pow";
var Sqrt = "sqrt";
var Symlog = "symlog";
var Time = "time";
var UTC = "utc";
var Sequential = "sequential";
var Diverging = "diverging";
var Quantile2 = "quantile";
var Quantize = "quantize";
var Threshold = "threshold";
var Ordinal = "ordinal";
var Point = "point";
var Band = "band";
var BinOrdinal = "bin-ordinal";
var Continuous = "continuous";
var Discrete = "discrete";
var Discretizing = "discretizing";
var Interpolating = "interpolating";
var Temporal = "temporal";
function invertRange(scale6) {
  return function(_) {
    let lo = _[0], hi = _[1], t2;
    if (hi < lo) {
      t2 = lo;
      lo = hi;
      hi = t2;
    }
    return [scale6.invert(lo), scale6.invert(hi)];
  };
}
function invertRangeExtent(scale6) {
  return function(_) {
    const range6 = scale6.range();
    let lo = _[0], hi = _[1], min4 = -1, max4, t2, i, n;
    if (hi < lo) {
      t2 = lo;
      lo = hi;
      hi = t2;
    }
    for (i = 0, n = range6.length; i < n; ++i) {
      if (range6[i] >= lo && range6[i] <= hi) {
        if (min4 < 0) min4 = i;
        max4 = i;
      }
    }
    if (min4 < 0) return void 0;
    lo = scale6.invertExtent(range6[min4]);
    hi = scale6.invertExtent(range6[max4]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band() {
  const scale6 = ordinal().unknown(void 0), domain4 = scale6.domain, ordinalRange = scale6.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale6.unknown;
  function rescale() {
    const n = domain4().length, reverse3 = range$1[1] < range$1[0], stop3 = range$1[1 - reverse3], space = bandSpace(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse3 - 0];
    step = (stop3 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop3 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values5 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse3 ? values5.reverse() : values5);
  }
  scale6.domain = function(_) {
    if (arguments.length) {
      domain4(_);
      return rescale();
    } else {
      return domain4();
    }
  };
  scale6.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale6.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale6.bandwidth = function() {
    return bandwidth2;
  };
  scale6.step = function() {
    return step;
  };
  scale6.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale6.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale6.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale6.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale6.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale6.invertRange = function(_) {
    if (_[0] == null || _[1] == null) return;
    const reverse3 = range$1[1] < range$1[0], values5 = reverse3 ? ordinalRange().reverse() : ordinalRange(), n = values5.length - 1;
    let lo = +_[0], hi = +_[1], a, b2, t2;
    if (lo !== lo || hi !== hi) return;
    if (hi < lo) {
      t2 = lo;
      lo = hi;
      hi = t2;
    }
    if (hi < values5[0] || lo > range$1[1 - reverse3]) return;
    a = Math.max(0, bisectRight(values5, lo) - 1);
    b2 = lo === hi ? a : bisectRight(values5, hi) - 1;
    if (lo - values5[a] > bandwidth2 + 1e-10) ++a;
    if (reverse3) {
      t2 = a;
      a = n - b2;
      b2 = n - t2;
    }
    return a > b2 ? void 0 : domain4().slice(a, b2 + 1);
  };
  scale6.invert = function(_) {
    const value3 = scale6.invertRange([_, _]);
    return value3 ? value3[0] : value3;
  };
  scale6.copy = function() {
    return band().domain(domain4()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish(scale6) {
  const copy2 = scale6.copy;
  scale6.padding = scale6.paddingOuter;
  delete scale6.paddingInner;
  scale6.copy = function() {
    return pointish(copy2());
  };
  return scale6;
}
function point() {
  return pointish(band().paddingInner(1));
}
var map = Array.prototype.map;
function numbers2(_) {
  return map.call(_, toNumber);
}
var slice = Array.prototype.slice;
function scaleBinOrdinal() {
  let domain4 = [], range6 = [];
  function scale6(x2) {
    return x2 == null || x2 !== x2 ? void 0 : range6[(bisect_default(domain4, x2) - 1) % range6.length];
  }
  scale6.domain = function(_) {
    if (arguments.length) {
      domain4 = numbers2(_);
      return scale6;
    } else {
      return domain4.slice();
    }
  };
  scale6.range = function(_) {
    if (arguments.length) {
      range6 = slice.call(_);
      return scale6;
    } else {
      return range6.slice();
    }
  };
  scale6.tickFormat = function(count, specifier) {
    return tickFormat(domain4[0], peek(domain4), count == null ? 10 : count, specifier);
  };
  scale6.copy = function() {
    return scaleBinOrdinal().domain(scale6.domain()).range(scale6.range());
  };
  return scale6;
}
var scales = /* @__PURE__ */ new Map();
var VEGA_SCALE = Symbol("vega_scale");
function registerScale(scale6) {
  scale6[VEGA_SCALE] = true;
  return scale6;
}
function isRegisteredScale(scale6) {
  return scale6 && scale6[VEGA_SCALE] === true;
}
function create(type3, constructor, metadata2) {
  const ctr = function scale6() {
    const s = constructor();
    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : void 0;
    }
    s.type = type3;
    return registerScale(s);
  };
  ctr.metadata = toSet(array(metadata2));
  return ctr;
}
function scale(type3, scale6, metadata2) {
  if (arguments.length > 1) {
    scales.set(type3, create(type3, scale6, metadata2));
    return this;
  } else {
    return isValidScaleType(type3) ? scales.get(type3) : void 0;
  }
}
scale(Identity, identity);
scale(Linear, linear, Continuous);
scale(Log, log, [Continuous, Log]);
scale(Pow, pow, Continuous);
scale(Sqrt, sqrt, Continuous);
scale(Symlog, symlog, Continuous);
scale(Time, time, [Continuous, Temporal]);
scale(UTC, utcTime, [Continuous, Temporal]);
scale(Sequential, sequential, [Continuous, Interpolating]);
scale(`${Sequential}-${Linear}`, sequential, [Continuous, Interpolating]);
scale(`${Sequential}-${Log}`, sequentialLog, [Continuous, Interpolating, Log]);
scale(`${Sequential}-${Pow}`, sequentialPow, [Continuous, Interpolating]);
scale(`${Sequential}-${Sqrt}`, sequentialSqrt, [Continuous, Interpolating]);
scale(`${Sequential}-${Symlog}`, sequentialSymlog, [Continuous, Interpolating]);
scale(`${Diverging}-${Linear}`, diverging, [Continuous, Interpolating]);
scale(`${Diverging}-${Log}`, divergingLog, [Continuous, Interpolating, Log]);
scale(`${Diverging}-${Pow}`, divergingPow, [Continuous, Interpolating]);
scale(`${Diverging}-${Sqrt}`, divergingSqrt, [Continuous, Interpolating]);
scale(`${Diverging}-${Symlog}`, divergingSymlog, [Continuous, Interpolating]);
scale(Quantile2, quantile2, [Discretizing, Quantile2]);
scale(Quantize, quantize, Discretizing);
scale(Threshold, threshold, Discretizing);
scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, ordinal, Discrete);
scale(Band, band, Discrete);
scale(Point, point, Discrete);
function isValidScaleType(type3) {
  return scales.has(type3);
}
function hasType(key2, type3) {
  const s = scales.get(key2);
  return s && s.metadata[type3];
}
function isContinuous(key2) {
  return hasType(key2, Continuous);
}
function isDiscrete(key2) {
  return hasType(key2, Discrete);
}
function isDiscretizing(key2) {
  return hasType(key2, Discretizing);
}
function isLogarithmic(key2) {
  return hasType(key2, Log);
}
function isTemporal(key2) {
  return hasType(key2, Temporal);
}
function isInterpolating(key2) {
  return hasType(key2, Interpolating);
}
function isQuantile(key2) {
  return hasType(key2, Quantile2);
}
var scaleProps = ["clamp", "base", "constant", "exponent"];
function interpolateRange(interpolator, range6) {
  const start = range6[0], span2 = peek(range6) - start;
  return function(i) {
    return interpolator(start + i * span2);
  };
}
function interpolateColors(colors2, type3, gamma) {
  return piecewise(interpolate(type3 || "rgb", gamma), colors2);
}
function quantizeInterpolator(interpolator, count) {
  const samples = new Array(count), n = count + 1;
  for (let i = 0; i < count; ) samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$12, min4, max4) {
  const delta = max4 - min4;
  let i, t2, s;
  if (!delta || !Number.isFinite(delta)) {
    return constant(0.5);
  } else {
    i = (t2 = scale$12.type).indexOf("-");
    t2 = i < 0 ? t2 : t2.slice(i + 1);
    s = scale(t2)().domain([min4, max4]).range([0, 1]);
    scaleProps.forEach((m) => scale$12[m] ? s[m](scale$12[m]()) : 0);
    return s;
  }
}
function interpolate(type3, gamma) {
  const interp = src_exports[method(type3)];
  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;
}
function method(type3) {
  return "interpolate" + type3.toLowerCase().split("-").map((s) => s[0].toUpperCase() + s.slice(1)).join("");
}
var continuous = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors(palette) {
  if (isArray(palette)) return palette;
  const n = palette.length / 6 | 0, c = new Array(n);
  for (let i = 0; i < n; ) {
    c[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c;
}
function apply(_, f) {
  for (const k2 in _) scheme(k2, f(_[k2]));
}
var schemes = {};
apply(discrete, colors);
apply(continuous, (_) => interpolateColors(colors(_)));
function scheme(name4, scheme3) {
  name4 = name4 && name4.toLowerCase();
  if (arguments.length > 1) {
    schemes[name4] = scheme3;
    return this;
  } else {
    return schemes[name4];
  }
}
var SymbolLegend = "symbol";
var DiscreteLegend = "discrete";
var GradientLegend = "gradient";
var defaultFormatter = (value3) => isArray(value3) ? value3.map((v) => String(v)) : String(value3);
var ascending3 = (a, b2) => a[1] - b2[1];
var descending = (a, b2) => b2[1] - a[1];
function tickCount(scale6, count, minStep) {
  let step;
  if (isNumber(count)) {
    if (scale6.bins) {
      count = Math.max(count, scale6.bins.length);
    }
    if (minStep != null) {
      count = Math.min(count, Math.floor(span(scale6.domain()) / minStep || 1) + 1);
    }
  }
  if (isObject(count)) {
    step = count.step;
    count = count.interval;
  }
  if (isString(count)) {
    count = scale6.type === Time ? timeInterval(count) : scale6.type == UTC ? utcInterval(count) : error("Only time and utc scales accept interval strings.");
    if (step) count = count.every(step);
  }
  return count;
}
function validTicks(scale6, ticks, count) {
  let range6 = scale6.range(), lo = range6[0], hi = peek(range6), cmp2 = ascending3;
  if (lo > hi) {
    range6 = hi;
    hi = lo;
    lo = range6;
    cmp2 = descending;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks = ticks.map((v) => [v, scale6(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp2).map((_) => _[0]);
  if (count > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], peek(ticks)];
    while (ticks.length > count && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }
    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }
  return ticks;
}
function tickValues(scale6, count) {
  return scale6.bins ? validTicks(scale6, scale6.bins, count) : scale6.ticks ? scale6.ticks(count) : scale6.domain();
}
function tickFormat2(locale2, scale6, count, specifier, formatType, noSkip) {
  const type3 = scale6.type;
  let format5 = defaultFormatter;
  if (type3 === Time || formatType === Time) {
    format5 = locale2.timeFormat(specifier);
  } else if (type3 === UTC || formatType === UTC) {
    format5 = locale2.utcFormat(specifier);
  } else if (isLogarithmic(type3)) {
    const varfmt = locale2.formatFloat(specifier);
    if (noSkip || scale6.bins) {
      format5 = varfmt;
    } else {
      const test2 = tickLog(scale6, count, false);
      format5 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale6.tickFormat) {
    const d = scale6.domain();
    format5 = locale2.formatSpan(d[0], d[d.length - 1], count, specifier);
  } else if (specifier) {
    format5 = locale2.format(specifier);
  }
  return format5;
}
function tickLog(scale6, count, values5) {
  const ticks = tickValues(scale6, count), base = scale6.base(), logb = Math.log(base), k2 = Math.max(1, base * count / ticks.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5) i *= base;
    return i <= k2;
  };
  return values5 ? ticks.filter(test2) : test2;
}
var symbols = {
  [Quantile2]: "quantiles",
  [Quantize]: "thresholds",
  [Threshold]: "domain"
};
var formats2 = {
  [Quantile2]: "quantiles",
  [Quantize]: "domain"
};
function labelValues(scale6, count) {
  return scale6.bins ? binValues(scale6.bins) : scale6.type === Log ? tickLog(scale6, count, true) : symbols[scale6.type] ? thresholdValues(scale6[symbols[scale6.type]]()) : tickValues(scale6, count);
}
function thresholdFormat(locale2, scale6, specifier) {
  const _ = scale6[formats2[scale6.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale2.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values5 = [-Infinity].concat(thresholds);
  values5.max = Infinity;
  return values5;
}
function binValues(bins2) {
  const values5 = bins2.slice(0, -1);
  values5.max = peek(bins2);
  return values5;
}
var isDiscreteRange = (scale6) => symbols[scale6.type] || scale6.bins;
function labelFormat(locale2, scale6, count, type3, specifier, formatType, noSkip) {
  const format5 = formats2[scale6.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale2, scale6, specifier) : tickFormat2(locale2, scale6, count, specifier, formatType, noSkip);
  return type3 === SymbolLegend && isDiscreteRange(scale6) ? formatRange(format5) : type3 === DiscreteLegend ? formatDiscrete(format5) : formatPoint(format5);
}
var formatRange = (format5) => (value3, index3, array4) => {
  const limit = get2(array4[index3 + 1], get2(array4.max, Infinity)), lo = formatValue(value3, format5), hi = formatValue(limit, format5);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get2 = (value3, dflt) => value3 != null ? value3 : dflt;
var formatDiscrete = (format5) => (value3, index3) => index3 ? format5(value3) : null;
var formatPoint = (format5) => (value3) => format5(value3);
var formatValue = (value3, format5) => Number.isFinite(value3) ? format5(value3) : null;
function labelFraction(scale6) {
  const domain4 = scale6.domain(), count = domain4.length - 1;
  let lo = +domain4[0], hi = +peek(domain4), span2 = hi - lo;
  if (scale6.type === Threshold) {
    const adjust = count ? span2 / count : 0.1;
    lo -= adjust;
    hi += adjust;
    span2 = hi - lo;
  }
  return (value3) => (value3 - lo) / span2;
}
function format3(locale2, scale6, specifier, formatType) {
  const type3 = formatType || scale6.type;
  if (isString(specifier) && isTemporal(type3)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type3 === Time ? locale2.timeFormat("%A, %d %B %Y, %X") : !specifier && type3 === UTC ? locale2.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale2, scale6, 5, null, specifier, formatType, true);
}
function domainCaption(locale2, scale6, opt) {
  opt = opt || {};
  const max4 = Math.max(3, opt.maxlen || 7), fmt = format3(locale2, scale6, opt.format, opt.formatType);
  if (isDiscretizing(scale6.type)) {
    const v = labelValues(scale6).slice(1).map(fmt), n = v.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v.join(", ")}`;
  } else if (isDiscrete(scale6.type)) {
    const d = scale6.domain(), n = d.length, v = n > max4 ? d.slice(0, max4 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v}`;
  } else {
    const d = scale6.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek(d))}`;
  }
}

// node_modules/vega-scenegraph/build/vega-scenegraph.module.js
var gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
var patternPrefix = "p_";
function isGradient(value3) {
  return value3 && value3.gradient;
}
function gradientRef(g, defs, base) {
  const type3 = g.gradient;
  let id2 = g.id, prefix = type3 === "radial" ? patternPrefix : "";
  if (!id2) {
    id2 = g.id = "gradient_" + gradient_id++;
    if (type3 === "radial") {
      g.x1 = get3(g.x1, 0.5);
      g.y1 = get3(g.y1, 0.5);
      g.r1 = get3(g.r1, 0);
      g.x2 = get3(g.x2, 0.5);
      g.y2 = get3(g.y2, 0.5);
      g.r2 = get3(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get3(g.x1, 0);
      g.y1 = get3(g.y1, 0);
      g.x2 = get3(g.x2, 1);
      g.y2 = get3(g.y2, 0);
    }
  }
  defs[id2] = g;
  return "url(" + (base || "") + "#" + prefix + id2 + ")";
}
function get3(val, def2) {
  return val != null ? val : def2;
}
function Gradient(p0, p1) {
  var stops = [], gradient4;
  return gradient4 = {
    gradient: "linear",
    x1: p0 ? p0[0] : 0,
    y1: p0 ? p0[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset4, color4) {
      stops.push({
        offset: offset4,
        color: color4
      });
      return gradient4;
    }
  };
}
var lookup = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves(type3, orientation, tension) {
  var entry2 = has(lookup, type3) && lookup[type3], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern = /^((\s+,?\s*)|(,\s*))/;
var flagPattern = /^[01]/;
function parse4(path3) {
  const commands = [];
  const matches = path3.match(commandPattern) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type3 = cmd.toLowerCase();
    const paramCount = paramCounts[type3];
    const params2 = parseParams(type3, paramCount, str.slice(1).trim());
    const count = params2.length;
    if (count < paramCount || count && count % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count === paramCount) {
      return;
    }
    if (type3 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams(type3, paramCount, segment) {
  const params2 = [];
  for (let index3 = 0; paramCount && index3 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type3 === "a" && (i === 3 || i === 4) ? flagPattern : numberPattern;
      const match3 = segment.slice(index3).match(pattern);
      if (match3 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index3 += match3[0].length;
      params2.push(+match3[0]);
      const ws = segment.slice(index3).match(spacePattern);
      if (ws !== null) {
        index3 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad = Math.PI / 180;
var Epsilon = 1e-14;
var HalfPi = Math.PI / 2;
var Tau = Math.PI * 2;
var HalfSqrt3 = Math.sqrt(3) / 2;
var segmentCache = {};
var bezierCache = {};
var join = [].join;
function segments(x2, y2, rx, ry, large, sweep, rotateX, ox, oy) {
  const key2 = join.call(arguments);
  if (segmentCache[key2]) {
    return segmentCache[key2];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px2 = cos_th * (ox - x2) * 0.5 + sin_th * (oy - y2) * 0.5;
  const py2 = cos_th * (oy - y2) * 0.5 - sin_th * (ox - x2) * 0.5;
  let pl = px2 * px2 / (rx * rx) + py2 * py2 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x02 = a00 * ox + a01 * oy;
  const y02 = a10 * ox + a11 * oy;
  const x12 = a00 * x2 + a01 * y2;
  const y12 = a10 * x2 + a11 * y2;
  const d = (x12 - x02) * (x12 - x02) + (y12 - y02) * (y12 - y02);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  const xc = 0.5 * (x02 + x12) - sfactor * (y12 - y02);
  const yc = 0.5 * (y02 + y12) + sfactor * (x12 - x02);
  const th0 = Math.atan2(y02 - yc, x02 - xc);
  const th1 = Math.atan2(y12 - yc, x12 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key2] = result;
}
function bezier(params2) {
  const key2 = join.call(params2);
  if (bezierCache[key2]) {
    return bezierCache[key2];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t2 = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x12 = cx + cos_th0 - t2 * sin_th0;
  const y12 = cy + sin_th0 + t2 * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t2 * sin_th1;
  const y2 = y3 - t2 * cos_th1;
  return bezierCache[key2] = [a00 * x12 + a01 * y12, a10 * x12 + a11 * y12, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1(current2, sX, sY) {
  const c = temp[0] = current2[0];
  if (c === "a" || c === "A") {
    temp[1] = sX * current2[1];
    temp[2] = sY * current2[2];
    temp[3] = current2[3];
    temp[4] = current2[4];
    temp[5] = current2[5];
    temp[6] = sX * current2[6];
    temp[7] = sY * current2[7];
  } else if (c === "h" || c === "H") {
    temp[1] = sX * current2[1];
  } else if (c === "v" || c === "V") {
    temp[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp;
}
function pathRender(context3, path3, l, t2, sX, sY) {
  var current2, previous = null, x2 = 0, y2 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null) l = 0;
  if (t2 == null) t2 = 0;
  if (sX == null) sX = 1;
  if (sY == null) sY = sX;
  if (context3.beginPath) context3.beginPath();
  for (var i = 0, len = path3.length; i < len; ++i) {
    current2 = path3[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$1(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x2 += current2[1];
        y2 += current2[2];
        context3.lineTo(x2 + l, y2 + t2);
        break;
      case "L":
        x2 = current2[1];
        y2 = current2[2];
        context3.lineTo(x2 + l, y2 + t2);
        break;
      case "h":
        x2 += current2[1];
        context3.lineTo(x2 + l, y2 + t2);
        break;
      case "H":
        x2 = current2[1];
        context3.lineTo(x2 + l, y2 + t2);
        break;
      case "v":
        y2 += current2[1];
        context3.lineTo(x2 + l, y2 + t2);
        break;
      case "V":
        y2 = current2[1];
        context3.lineTo(x2 + l, y2 + t2);
        break;
      case "m":
        x2 += current2[1];
        y2 += current2[2];
        anchorX = x2;
        anchorY = y2;
        context3.moveTo(x2 + l, y2 + t2);
        break;
      case "M":
        x2 = current2[1];
        y2 = current2[2];
        anchorX = x2;
        anchorY = y2;
        context3.moveTo(x2 + l, y2 + t2);
        break;
      case "c":
        tempX = x2 + current2[5];
        tempY = y2 + current2[6];
        controlX = x2 + current2[3];
        controlY = y2 + current2[4];
        context3.bezierCurveTo(
          x2 + current2[1] + l,
          // x1
          y2 + current2[2] + t2,
          // y1
          controlX + l,
          // x2
          controlY + t2,
          // y2
          tempX + l,
          tempY + t2
        );
        x2 = tempX;
        y2 = tempY;
        break;
      case "C":
        x2 = current2[5];
        y2 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context3.bezierCurveTo(current2[1] + l, current2[2] + t2, controlX + l, controlY + t2, x2 + l, y2 + t2);
        break;
      case "s":
        tempX = x2 + current2[3];
        tempY = y2 + current2[4];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t2, x2 + current2[1] + l, y2 + current2[2] + t2, tempX + l, tempY + t2);
        controlX = x2 + current2[1];
        controlY = y2 + current2[2];
        x2 = tempX;
        y2 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t2, current2[1] + l, current2[2] + t2, tempX + l, tempY + t2);
        x2 = tempX;
        y2 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x2 + current2[3];
        tempY = y2 + current2[4];
        controlX = x2 + current2[1];
        controlY = y2 + current2[2];
        context3.quadraticCurveTo(controlX + l, controlY + t2, tempX + l, tempY + t2);
        x2 = tempX;
        y2 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context3.quadraticCurveTo(current2[1] + l, current2[2] + t2, tempX + l, tempY + t2);
        x2 = tempX;
        y2 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x2 + current2[1];
        tempY = y2 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x2;
          controlY = y2;
        } else if (previous[0] === "t") {
          controlX = 2 * x2 - tempControlX;
          controlY = 2 * y2 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x2 - controlX;
          controlY = 2 * y2 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t2, tempX + l, tempY + t2);
        x2 = tempX;
        y2 = tempY;
        controlX = x2 + current2[1];
        controlY = y2 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t2, tempX + l, tempY + t2);
        x2 = tempX;
        y2 = tempY;
        break;
      case "a":
        drawArc(context3, x2 + l, y2 + t2, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x2 + l, current2[7] + y2 + t2]);
        x2 += current2[6];
        y2 += current2[7];
        break;
      case "A":
        drawArc(context3, x2 + l, y2 + t2, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t2]);
        x2 = current2[6];
        y2 = current2[7];
        break;
      case "z":
      case "Z":
        x2 = anchorX;
        y2 = anchorY;
        context3.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc(context3, x2, y2, coords) {
  const seg = segments(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x2,
    y2
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context3.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan30 = 0.5773502691896257;
var builtins = {
  "circle": {
    draw: function(context3, size) {
      const r2 = Math.sqrt(size) / 2;
      context3.moveTo(r2, 0);
      context3.arc(0, 0, r2, 0, Tau);
    }
  },
  "cross": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, s = r2 / 2.5;
      context3.moveTo(-r2, -s);
      context3.lineTo(-r2, s);
      context3.lineTo(-s, s);
      context3.lineTo(-s, r2);
      context3.lineTo(s, r2);
      context3.lineTo(s, s);
      context3.lineTo(r2, s);
      context3.lineTo(r2, -s);
      context3.lineTo(s, -s);
      context3.lineTo(s, -r2);
      context3.lineTo(-s, -r2);
      context3.lineTo(-s, -s);
      context3.closePath();
    }
  },
  "diamond": {
    draw: function(context3, size) {
      const r2 = Math.sqrt(size) / 2;
      context3.moveTo(-r2, 0);
      context3.lineTo(0, -r2);
      context3.lineTo(r2, 0);
      context3.lineTo(0, r2);
      context3.closePath();
    }
  },
  "square": {
    draw: function(context3, size) {
      var w4 = Math.sqrt(size), x2 = -w4 / 2;
      context3.rect(x2, x2, w4, w4);
    }
  },
  "arrow": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, s = r2 / 7, t2 = r2 / 2.5, v = r2 / 8;
      context3.moveTo(-s, r2);
      context3.lineTo(s, r2);
      context3.lineTo(s, -v);
      context3.lineTo(t2, -v);
      context3.lineTo(0, -r2);
      context3.lineTo(-t2, -v);
      context3.lineTo(-s, -v);
      context3.closePath();
    }
  },
  "wedge": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2, o = h2 - r2 * Tan30, b2 = r2 / 4;
      context3.moveTo(0, -h2 - o);
      context3.lineTo(-b2, h2 - o);
      context3.lineTo(b2, h2 - o);
      context3.closePath();
    }
  },
  "triangle": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2, o = h2 - r2 * Tan30;
      context3.moveTo(0, -h2 - o);
      context3.lineTo(-r2, h2 - o);
      context3.lineTo(r2, h2 - o);
      context3.closePath();
    }
  },
  "triangle-up": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context3.moveTo(0, -h2);
      context3.lineTo(-r2, h2);
      context3.lineTo(r2, h2);
      context3.closePath();
    }
  },
  "triangle-down": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context3.moveTo(0, h2);
      context3.lineTo(-r2, -h2);
      context3.lineTo(r2, -h2);
      context3.closePath();
    }
  },
  "triangle-right": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context3.moveTo(h2, 0);
      context3.lineTo(-h2, -r2);
      context3.lineTo(-h2, r2);
      context3.closePath();
    }
  },
  "triangle-left": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r2;
      context3.moveTo(-h2, 0);
      context3.lineTo(h2, -r2);
      context3.lineTo(h2, r2);
      context3.closePath();
    }
  },
  "stroke": {
    draw: function(context3, size) {
      const r2 = Math.sqrt(size) / 2;
      context3.moveTo(-r2, 0);
      context3.lineTo(r2, 0);
    }
  }
};
function symbols2(_) {
  return has(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom = {};
function customSymbol(path3) {
  if (!has(custom, path3)) {
    const parsed = parse4(path3);
    custom[path3] = {
      draw: function(context3, size) {
        pathRender(context3, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom[path3];
}
var C = 0.448084975506;
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp(value3, min4, max4) {
  return Math.max(min4, Math.min(value3, max4));
}
function vg_rect() {
  var x2 = rectangleX, y2 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number(0), crTR = crTL, crBL = crTL, crBR = crTL, context3 = null;
  function rectangle2(_, x02, y02) {
    var buffer, x12 = x02 != null ? x02 : +x2.call(this, _), y12 = y02 != null ? y02 : +y2.call(this, _), w4 = +width2.call(this, _), h2 = +height2.call(this, _), s = Math.min(w4, h2) / 2, tl2 = clamp(+crTL.call(this, _), 0, s), tr2 = clamp(+crTR.call(this, _), 0, s), bl2 = clamp(+crBL.call(this, _), 0, s), br2 = clamp(+crBR.call(this, _), 0, s);
    if (!context3) context3 = buffer = path();
    if (tl2 <= 0 && tr2 <= 0 && bl2 <= 0 && br2 <= 0) {
      context3.rect(x12, y12, w4, h2);
    } else {
      var x22 = x12 + w4, y22 = y12 + h2;
      context3.moveTo(x12 + tl2, y12);
      context3.lineTo(x22 - tr2, y12);
      context3.bezierCurveTo(x22 - C * tr2, y12, x22, y12 + C * tr2, x22, y12 + tr2);
      context3.lineTo(x22, y22 - br2);
      context3.bezierCurveTo(x22, y22 - C * br2, x22 - C * br2, y22, x22 - br2, y22);
      context3.lineTo(x12 + bl2, y22);
      context3.bezierCurveTo(x12 + C * bl2, y22, x12, y22 - C * bl2, x12, y22 - bl2);
      context3.lineTo(x12, y12 + tl2);
      context3.bezierCurveTo(x12, y12 + C * tl2, x12 + C * tl2, y12, x12 + tl2, y12);
      context3.closePath();
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  rectangle2.x = function(_) {
    if (arguments.length) {
      x2 = number(_);
      return rectangle2;
    } else {
      return x2;
    }
  };
  rectangle2.y = function(_) {
    if (arguments.length) {
      y2 = number(_);
      return rectangle2;
    } else {
      return y2;
    }
  };
  rectangle2.width = function(_) {
    if (arguments.length) {
      width2 = number(_);
      return rectangle2;
    } else {
      return width2;
    }
  };
  rectangle2.height = function(_) {
    if (arguments.length) {
      height2 = number(_);
      return rectangle2;
    } else {
      return height2;
    }
  };
  rectangle2.cornerRadius = function(tl2, tr2, br2, bl2) {
    if (arguments.length) {
      crTL = number(tl2);
      crTR = tr2 != null ? number(tr2) : crTL;
      crBR = br2 != null ? number(br2) : crTL;
      crBL = bl2 != null ? number(bl2) : crTR;
      return rectangle2;
    } else {
      return crTL;
    }
  };
  rectangle2.context = function(_) {
    if (arguments.length) {
      context3 = _ == null ? null : _;
      return rectangle2;
    } else {
      return context3;
    }
  };
  return rectangle2;
}
function vg_trail() {
  var x2, y2, size, defined2, context3 = null, ready, x12, y12, r1;
  function point5(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y12 - y22, uy = x22 - x12;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t2 = Math.atan2(uy, ux);
        context3.moveTo(x12 - rx, y12 - ry);
        context3.lineTo(x22 - ux * r2, y22 - uy * r2);
        context3.arc(x22, y22, r2, t2 - Math.PI, t2);
        context3.lineTo(x12 + rx, y12 + ry);
        context3.arc(x12, y12, r1, t2, t2 + Math.PI);
      } else {
        context3.arc(x22, y22, r2, 0, Tau);
      }
      context3.closePath();
    } else {
      ready = 1;
    }
    x12 = x22;
    y12 = y22;
    r1 = r2;
  }
  function trail3(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context3 == null) context3 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0) ready = 0;
      }
      if (defined0) point5(+x2(d, i, data3), +y2(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  trail3.x = function(_) {
    if (arguments.length) {
      x2 = _;
      return trail3;
    } else {
      return x2;
    }
  };
  trail3.y = function(_) {
    if (arguments.length) {
      y2 = _;
      return trail3;
    } else {
      return y2;
    }
  };
  trail3.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail3;
    } else {
      return size;
    }
  };
  trail3.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail3;
    } else {
      return defined2;
    }
  };
  trail3.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context3 = null;
      } else {
        context3 = _;
      }
      return trail3;
    } else {
      return context3;
    }
  };
  return trail3;
}
function value$1(a, b2) {
  return a != null ? a : b2;
}
var x = (item) => item.x || 0;
var y = (item) => item.y || 0;
var w = (item) => item.width || 0;
var h = (item) => item.height || 0;
var xw = (item) => (item.x || 0) + (item.width || 0);
var yh = (item) => (item.y || 0) + (item.height || 0);
var sa = (item) => item.startAngle || 0;
var ea = (item) => item.endAngle || 0;
var pa = (item) => item.padAngle || 0;
var ir = (item) => item.innerRadius || 0;
var or = (item) => item.outerRadius || 0;
var cr = (item) => item.cornerRadius || 0;
var tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz = (item) => value$1(item.size, 64);
var ts = (item) => item.size || 1;
var def = (item) => !(item.defined === false);
var type = (item) => symbols2(item.shape || "circle");
var arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr);
var areavShape = area_default2().x(x).y1(y).y0(yh).defined(def);
var areahShape = area_default2().y(y).x1(x).x0(xw).defined(def);
var lineShape = line_default().x(x).y(y).defined(def);
var rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl);
var symbolShape = Symbol2().type(type).size(sz);
var trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context3, item) {
  return arcShape.context(context3)(item);
}
function area$1(context3, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context3)(items);
}
function line$1(context3, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context3)(items);
}
function rectangle(context3, item, x2, y2) {
  return rectShape.context(context3)(item, x2, y2);
}
function shape$1(context3, item) {
  return (item.mark.shape || item.shape).context(context3)(item);
}
function symbol$1(context3, item) {
  return symbolShape.context(context3)(item);
}
function trail$1(context3, items) {
  return trailShape.context(context3)(items);
}
var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1(renderer, item, size) {
  var clip3 = item.clip, defs = renderer._defs, id2 = item.clip_id || (item.clip_id = "clip" + clip_id++), c = defs.clipping[id2] || (defs.clipping[id2] = {
    id: id2
  });
  if (isFunction(clip3)) {
    c.path = clip3(null);
  } else if (hasCornerRadius(size)) {
    c.path = rectangle(null, size, 0, 0);
  } else {
    c.width = size.width || 0;
    c.height = size.height || 0;
  }
  return "url(#" + id2 + ")";
}
function Bounds(b2) {
  this.clear();
  if (b2) this.union(b2);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  },
  set(x12, y12, x2, y2) {
    if (x2 < x12) {
      this.x2 = x12;
      this.x1 = x2;
    } else {
      this.x1 = x12;
      this.x2 = x2;
    }
    if (y2 < y12) {
      this.y2 = y12;
      this.y1 = y2;
    } else {
      this.y1 = y12;
      this.y2 = y2;
    }
    return this;
  },
  add(x2, y2) {
    if (x2 < this.x1) this.x1 = x2;
    if (y2 < this.y1) this.y1 = y2;
    if (x2 > this.x2) this.x2 = x2;
    if (y2 > this.y2) this.y2 = y2;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle, x2, y2) {
    const p = this.rotatedPoints(angle, x2, y2);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle, x2, y2) {
    var {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = this, cos2 = Math.cos(angle), sin2 = Math.sin(angle), cx = x2 - x2 * cos2 + y2 * sin2, cy = y2 - x2 * sin2 - y2 * cos2;
    return [cos2 * x12 - sin2 * y12 + cx, sin2 * x12 + cos2 * y12 + cy, cos2 * x12 - sin2 * y22 + cx, sin2 * x12 + cos2 * y22 + cy, cos2 * x22 - sin2 * y12 + cx, sin2 * x22 + cos2 * y12 + cy, cos2 * x22 - sin2 * y22 + cx, sin2 * x22 + cos2 * y22 + cy];
  },
  union(b2) {
    if (b2.x1 < this.x1) this.x1 = b2.x1;
    if (b2.y1 < this.y1) this.y1 = b2.y1;
    if (b2.x2 > this.x2) this.x2 = b2.x2;
    if (b2.y2 > this.y2) this.y2 = b2.y2;
    return this;
  },
  intersect(b2) {
    if (b2.x1 > this.x1) this.x1 = b2.x1;
    if (b2.y1 > this.y1) this.y1 = b2.y1;
    if (b2.x2 < this.x2) this.x2 = b2.x2;
    if (b2.y2 < this.y2) this.y2 = b2.y2;
    return this;
  },
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  },
  alignsWith(b2) {
    return b2 && (this.x1 == b2.x1 || this.x2 == b2.x2 || this.y1 == b2.y1 || this.y2 == b2.y2);
  },
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  },
  contains(x2, y2) {
    return !(x2 < this.x1 || x2 > this.x2 || y2 < this.y1 || y2 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item(mark2) {
  this.mark = mark2;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark2) {
  Item.call(this, mark2);
  this.items = this.items || [];
}
inherits(GroupItem, Item);
var ResourceLoader = class {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || loader();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader2 = this;
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement(loader2);
      return opt;
    }).catch(() => {
      decrement(loader2);
      return null;
    });
  }
  loadImage(uri) {
    const loader2 = this, Image2 = domImage();
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2) throw {
        url
      };
      const img = new Image2();
      const cors = has(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null) img.crossOrigin = cors;
      img.onload = () => decrement(loader2);
      img.onerror = () => decrement(loader2);
      img.src = url;
      return img;
    }).catch((e2) => {
      decrement(loader2);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e2 && e2.url || ""
      };
    });
  }
  ready() {
    const loader2 = this;
    return new Promise((accept) => {
      function poll(value3) {
        if (!loader2.pending()) accept(value3);
        else setTimeout(() => {
          poll(true);
        }, 10);
      }
      poll(false);
    });
  }
};
function increment(loader2) {
  loader2._pending += 1;
}
function decrement(loader2) {
  loader2._pending -= 1;
}
function boundStroke(bounds2, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds2.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds2;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold = Tau - 1e-8;
var bounds;
var lx;
var ly;
var rot;
var ma;
var mb;
var mc;
var md;
var add3 = (x2, y2) => bounds.add(x2, y2);
var addL = (x2, y2) => add3(lx = x2, ly = y2);
var addX = (x2) => add3(x2, bounds.y1);
var addY = (y2) => add3(bounds.x1, y2);
var px = (x2, y2) => ma * x2 + mc * y2;
var py = (x2, y2) => mb * x2 + md * y2;
var addp = (x2, y2) => add3(px(x2, y2), py(x2, y2));
var addpL = (x2, y2) => addL(px(x2, y2), py(x2, y2));
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
var context$1 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL,
  lineTo: addpL,
  rect(x2, y2, w4, h2) {
    if (rot) {
      addp(x2 + w4, y2);
      addp(x2 + w4, y2 + h2);
      addp(x2, y2 + h2);
      addpL(x2, y2);
    } else {
      add3(x2 + w4, y2 + h2);
      addL(x2, y2);
    }
  },
  quadraticCurveTo(x12, y12, x2, y2) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },
  bezierCurveTo(x12, y12, x2, y2, x3, y3) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2), px3 = px(x3, y3), py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },
  arc(cx, cy, r2, sa2, ea2, ccw) {
    sa2 += rot;
    ea2 += rot;
    lx = r2 * Math.cos(ea2) + cx;
    ly = r2 * Math.sin(ea2) + cy;
    if (Math.abs(ea2 - sa2) > circleThreshold) {
      add3(cx - r2, cy - r2);
      add3(cx + r2, cy + r2);
    } else {
      const update3 = (a) => add3(r2 * Math.cos(a) + cx, r2 * Math.sin(a) + cy);
      let s, i;
      update3(sa2);
      update3(ea2);
      if (ea2 !== sa2) {
        sa2 = sa2 % Tau;
        if (sa2 < 0) sa2 += Tau;
        ea2 = ea2 % Tau;
        if (ea2 < 0) ea2 += Tau;
        if (ea2 < sa2) {
          ccw = !ccw;
          s = sa2;
          sa2 = ea2;
          ea2 = s;
        }
        if (ccw) {
          ea2 -= Tau;
          s = sa2 - sa2 % HalfPi;
          for (i = 0; i < 4 && s > ea2; ++i, s -= HalfPi) update3(s);
        } else {
          s = sa2 - sa2 % HalfPi + HalfPi;
          for (i = 0; i < 4 && s < ea2; ++i, s = s + HalfPi) update3(s);
        }
      }
    }
  }
};
function quadExtrema(x02, x12, x2, cb) {
  const t2 = (x02 - x12) / (x02 + x2 - 2 * x12);
  if (0 < t2 && t2 < 1) cb(x02 + (x12 - x02) * t2);
}
function cubicExtrema(x02, x12, x2, x3, cb) {
  const a = x3 - x02 + 3 * x12 - 3 * x2, b2 = x02 + x2 - 2 * x12, c = x02 - x12;
  let t02 = 0, t1 = 0, r2;
  if (Math.abs(a) > Epsilon) {
    r2 = b2 * b2 + c * a;
    if (r2 >= 0) {
      r2 = Math.sqrt(r2);
      t02 = (-b2 + r2) / a;
      t1 = (-b2 - r2) / a;
    }
  } else {
    t02 = 0.5 * c / b2;
  }
  if (0 < t02 && t02 < 1) cb(cubic(t02, x02, x12, x2, x3));
  if (0 < t1 && t1 < 1) cb(cubic(t1, x02, x12, x2, x3));
}
function cubic(t2, x02, x12, x2, x3) {
  const s = 1 - t2, s2 = s * s, t22 = t2 * t2;
  return s2 * s * x02 + 3 * s2 * t2 * x12 + 3 * s * t22 * x2 + t22 * t2 * x3;
}
var context = (context = domCanvas(1, 1)) ? context.getContext("2d") : null;
var b = new Bounds();
function intersectPath(draw3) {
  return function(item, brush) {
    if (!context) return true;
    draw3(context, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x12,
      y1: y12,
      x2,
      y2
    } = b;
    for (let y3 = y12; y3 <= y2; ++y3) {
      for (let x3 = x12; x3 <= x2; ++x3) {
        if (context.isPointInPath(x3, y3)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x2 = item.x || 0, y2 = item.y || 0, w4 = item.width || 0, h2 = item.height || 0;
  return box.intersects(b.set(x2, y2, x2 + w4, y2 + h2));
}
function intersectRule(item, box) {
  const x2 = item.x || 0, y2 = item.y || 0, x22 = item.x2 != null ? item.x2 : x2, y22 = item.y2 != null ? item.y2 : y2;
  return intersectBoxLine(box, x2, y2, x22, y22);
}
function intersectBoxLine(box, x2, y2, u, v) {
  const {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  } = box, dx = u - x2, dy = v - y2;
  let t02 = 0, t1 = 1, p, q, r2, e2;
  for (e2 = 0; e2 < 4; ++e2) {
    if (e2 === 0) {
      p = -dx;
      q = -(x12 - x2);
    }
    if (e2 === 1) {
      p = dx;
      q = x22 - x2;
    }
    if (e2 === 2) {
      p = -dy;
      q = -(y12 - y2);
    }
    if (e2 === 3) {
      p = dy;
      q = y22 - y2;
    }
    if (Math.abs(p) < 1e-10 && q < 0) return false;
    r2 = q / p;
    if (p < 0) {
      if (r2 > t1) return false;
      else if (r2 > t02) t02 = r2;
    } else if (p > 0) {
      if (r2 < t02) return false;
      else if (r2 < t1) t1 = r2;
    }
  }
  return true;
}
function blend(context3, item) {
  context3.globalCompositeOperation = item.blend || "source-over";
}
function value(value3, dflt) {
  return value3 == null ? dflt : value3;
}
function addStops(gradient4, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient4.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient4;
}
function gradient(context3, spec, bounds2) {
  const w4 = bounds2.width(), h2 = bounds2.height();
  let gradient4;
  if (spec.gradient === "radial") {
    gradient4 = context3.createRadialGradient(bounds2.x1 + value(spec.x1, 0.5) * w4, bounds2.y1 + value(spec.y1, 0.5) * h2, Math.max(w4, h2) * value(spec.r1, 0), bounds2.x1 + value(spec.x2, 0.5) * w4, bounds2.y1 + value(spec.y2, 0.5) * h2, Math.max(w4, h2) * value(spec.r2, 0.5));
  } else {
    const x12 = value(spec.x1, 0), y12 = value(spec.y1, 0), x2 = value(spec.x2, 1), y2 = value(spec.y2, 0);
    if (x12 === x2 || y12 === y2 || w4 === h2) {
      gradient4 = context3.createLinearGradient(bounds2.x1 + x12 * w4, bounds2.y1 + y12 * h2, bounds2.x1 + x2 * w4, bounds2.y1 + y2 * h2);
    } else {
      const image3 = domCanvas(Math.ceil(w4), Math.ceil(h2)), ictx = image3.getContext("2d");
      ictx.scale(w4, h2);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x12, y12, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w4, h2);
      return context3.createPattern(image3, "no-repeat");
    }
  }
  return addStops(gradient4, spec.stops);
}
function color(context3, item, value3) {
  return isGradient(value3) ? gradient(context3, value3, item.bounds) : value3;
}
function fill(context3, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context3.globalAlpha = opacity2;
    context3.fillStyle = color(context3, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty2 = [];
function stroke(context3, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0) return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context3.globalAlpha = opacity2;
    context3.strokeStyle = color(context3, item, item.stroke);
    context3.lineWidth = lw;
    context3.lineCap = item.strokeCap || "butt";
    context3.lineJoin = item.strokeJoin || "miter";
    context3.miterLimit = item.strokeMiterLimit || 10;
    if (context3.setLineDash) {
      context3.setLineDash(item.strokeDash || Empty2);
      context3.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare3(a, b2) {
  return a.zindex - b2.zindex || a.index - b2.index;
}
function zorder(scene) {
  if (!scene.zdirty) return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex) output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare3);
}
function visit(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length) return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex) visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items, hit2, i;
  if (!items || !items.length) return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length) items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit2 = visitor(items[i])) return hit2;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit2 = visitor(items[i])) return hit2;
      }
    }
  }
  return null;
}
function drawAll(path3) {
  return function(context3, scene, bounds2) {
    visit(scene, (item) => {
      if (!bounds2 || bounds2.intersects(item.bounds)) {
        drawPath(path3, context3, item, item);
      }
    });
  };
}
function drawOne(path3) {
  return function(context3, scene, bounds2) {
    if (scene.items.length && (!bounds2 || bounds2.intersects(scene.bounds))) {
      drawPath(path3, context3, scene.items[0], scene.items);
    }
  };
}
function drawPath(path3, context3, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0) return;
  if (path3(context3, items)) return;
  blend(context3, item);
  if (item.fill && fill(context3, item, opacity2)) {
    context3.fill();
  }
  if (item.stroke && stroke(context3, item, opacity2)) {
    context3.stroke();
  }
}
function pick$1(test2) {
  test2 = test2 || truthy;
  return function(context3, scene, x2, y2, gx, gy) {
    x2 *= context3.pixelRatio;
    y2 *= context3.pixelRatio;
    return pickVisit(scene, (item) => {
      const b2 = item.bounds;
      if (b2 && !b2.contains(gx, gy) || !b2) return;
      if (test2(context3, item, x2, y2, gx, gy)) return item;
    });
  };
}
function hitPath(path3, filled) {
  return function(context3, o, x2, y2) {
    var item = Array.isArray(o) ? o[0] : o, fill2 = filled == null ? item.fill : filled, stroke2 = item.stroke && context3.isPointInStroke, lw, lc;
    if (stroke2) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context3.lineWidth = lw != null ? lw : 1;
      context3.lineCap = lc != null ? lc : "butt";
    }
    return path3(context3, o) ? false : fill2 && context3.isPointInPath(x2, y2) || stroke2 && context3.isPointInStroke(x2, y2);
  };
}
function pickPath(path3) {
  return pick$1(hitPath(path3));
}
function translate(x2, y2) {
  return "translate(" + x2 + "," + y2 + ")";
}
function rotate(a) {
  return "rotate(" + a + ")";
}
function scale2(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale2(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type3, shape2, isect) {
  function attr2(emit2, item) {
    emit2("transform", rotateItem(item));
    emit2("d", shape2(null, item));
  }
  function bound2(bounds2, item) {
    shape2(boundContext(bounds2, item.angle), item);
    return boundStroke(bounds2, item).translate(item.x || 0, item.y || 0);
  }
  function draw3(context3, item) {
    var x2 = item.x || 0, y2 = item.y || 0, a = item.angle || 0;
    context3.translate(x2, y2);
    if (a) context3.rotate(a *= DegToRad);
    context3.beginPath();
    shape2(context3, item);
    if (a) context3.rotate(-a);
    context3.translate(-x2, -y2);
  }
  return {
    type: type3,
    tag: "path",
    nested: false,
    attr: attr2,
    bound: bound2,
    draw: drawAll(draw3),
    pick: pickPath(draw3),
    isect: isect || intersectPath(draw3)
  };
}
var arc = markItemPath("arc", arc$1);
function pickArea(a, p) {
  var v = a[0].orient === "horizontal" ? p[1] : p[0], z = a[0].orient === "horizontal" ? "y" : "x", i = a.length, min4 = Infinity, hit2, d;
  while (--i >= 0) {
    if (a[i].defined === false) continue;
    d = Math.abs(a[i][z] - v);
    if (d < min4) {
      min4 = d;
      hit2 = a[i];
    }
  }
  return hit2;
}
function pickLine(a, p) {
  var t2 = Math.pow(a[0].strokeWidth || 1, 2), i = a.length, dx, dy, dd;
  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t2) return a[i];
  }
  return null;
}
function pickTrail(a, p) {
  var i = a.length, dx, dy, dd;
  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a[i].size || 1;
    if (dd < dx * dx) return a[i];
  }
  return null;
}
function markMultiItemPath(type3, shape2, tip) {
  function attr2(emit2, item) {
    var items = item.mark.items;
    if (items.length) emit2("d", shape2(null, items));
  }
  function bound2(bounds2, mark2) {
    var items = mark2.items;
    if (items.length === 0) {
      return bounds2;
    } else {
      shape2(boundContext(bounds2), items);
      return boundStroke(bounds2, items[0]);
    }
  }
  function draw3(context3, items) {
    context3.beginPath();
    shape2(context3, items);
  }
  const hit2 = hitPath(draw3);
  function pick3(context3, scene, x2, y2, gx, gy) {
    var items = scene.items, b2 = scene.bounds;
    if (!items || !items.length || b2 && !b2.contains(gx, gy)) {
      return null;
    }
    x2 *= context3.pixelRatio;
    y2 *= context3.pixelRatio;
    return hit2(context3, items, x2, y2) ? items[0] : null;
  }
  return {
    type: type3,
    tag: "path",
    nested: true,
    attr: attr2,
    bound: bound2,
    draw: drawOne(draw3),
    pick: pick3,
    isect: intersectPoint,
    tip
  };
}
var area = markMultiItemPath("area", area$1, pickArea);
function clip(context3, scene) {
  var clip3 = scene.clip;
  context3.save();
  if (isFunction(clip3)) {
    context3.beginPath();
    clip3(context3);
    context3.clip();
  } else {
    clipGroup(context3, scene.group);
  }
}
function clipGroup(context3, group2) {
  context3.beginPath();
  hasCornerRadius(group2) ? rectangle(context3, group2, 0, 0) : context3.rect(0, 0, group2.width || 0, group2.height || 0);
  context3.clip();
}
function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit2, item) {
  emit2("transform", translateItem(item));
}
function emitRectangle(emit2, item) {
  const off = offset$1(item);
  emit2("d", rectangle(null, item, off, off));
}
function background(emit2, item) {
  emit2("class", "background");
  emit2("aria-hidden", true);
  emitRectangle(emit2, item);
}
function foreground(emit2, item) {
  emit2("class", "foreground");
  emit2("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit2, item);
  } else {
    emit2("d", "");
  }
}
function content(emit2, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit2("clip-path", url);
}
function bound$5(bounds2, group2) {
  if (!group2.clip && group2.items) {
    const items = group2.items, m = items.length;
    for (let j = 0; j < m; ++j) {
      bounds2.union(items[j].bounds);
    }
  }
  if ((group2.clip || group2.width || group2.height) && !group2.noBound) {
    bounds2.add(0, 0).add(group2.width || 0, group2.height || 0);
  }
  boundStroke(bounds2, group2);
  return bounds2.translate(group2.x || 0, group2.y || 0);
}
function rectanglePath(context3, group2, x2, y2) {
  const off = offset$1(group2);
  context3.beginPath();
  rectangle(context3, group2, (x2 || 0) + off, (y2 || 0) + off);
}
var hitBackground = hitPath(rectanglePath);
var hitForeground = hitPath(rectanglePath, false);
var hitCorner = hitPath(rectanglePath, true);
function draw$4(context3, scene, bounds2, markTypes) {
  visit(scene, (group2) => {
    const gx = group2.x || 0, gy = group2.y || 0, fore = group2.strokeForeground, opacity2 = group2.opacity == null ? 1 : group2.opacity;
    if ((group2.stroke || group2.fill) && opacity2) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (group2.fill && fill(context3, group2, opacity2)) {
        context3.fill();
      }
      if (group2.stroke && !fore && stroke(context3, group2, opacity2)) {
        context3.stroke();
      }
    }
    context3.save();
    context3.translate(gx, gy);
    if (group2.clip) clipGroup(context3, group2);
    if (bounds2) bounds2.translate(-gx, -gy);
    visit(group2, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context3, item, bounds2, markTypes);
      }
    });
    if (bounds2) bounds2.translate(gx, gy);
    context3.restore();
    if (fore && group2.stroke && opacity2) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (stroke(context3, group2, opacity2)) {
        context3.stroke();
      }
    }
  });
}
function pick(context3, scene, x2, y2, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x2 * context3.pixelRatio, cy = y2 * context3.pixelRatio;
  return pickVisit(scene, (group2) => {
    let hit2, dx, dy;
    const b2 = group2.bounds;
    if (b2 && !b2.contains(gx, gy)) return;
    dx = group2.x || 0;
    dy = group2.y || 0;
    const dw = dx + (group2.width || 0), dh = dy + (group2.height || 0), c = group2.clip;
    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;
    context3.save();
    context3.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c && hasCornerRadius(group2) && !hitCorner(context3, group2, cx, cy)) {
      context3.restore();
      return null;
    }
    const fore = group2.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group2.stroke && hitForeground(context3, group2, cx, cy)) {
      context3.restore();
      return group2;
    }
    hit2 = pickVisit(group2, (mark2) => pickMark(mark2, dx, dy) ? this.pick(mark2, x2, y2, dx, dy) : null);
    if (!hit2 && ix && (group2.fill || !fore && group2.stroke) && hitBackground(context3, group2, cx, cy)) {
      hit2 = group2;
    }
    context3.restore();
    return hit2 || null;
  });
}
function pickMark(mark2, x2, y2) {
  return (mark2.interactive !== false || mark2.marktype === "group") && mark2.bounds && mark2.bounds.contains(x2, y2);
}
var group = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick,
  isect: intersectRect,
  content,
  background,
  foreground
};
var metadata = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage(item, renderer) {
  var image3 = item.image;
  if (!image3 || item.url && item.url !== image3.url) {
    image3 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image4) => {
      item.image = image4;
      item.image.url = item.url;
    });
  }
  return image3;
}
function imageWidth(item, image3) {
  return item.width != null ? item.width : !image3 || !image3.width ? 0 : item.aspect !== false && item.height ? item.height * image3.width / image3.height : image3.width;
}
function imageHeight(item, image3) {
  return item.height != null ? item.height : !image3 || !image3.height ? 0 : item.aspect !== false && item.width ? item.width * image3.height / image3.width : image3.height;
}
function imageXOffset(align2, w4) {
  return align2 === "center" ? w4 / 2 : align2 === "right" ? w4 : 0;
}
function imageYOffset(baseline3, h2) {
  return baseline3 === "middle" ? h2 / 2 : baseline3 === "bottom" ? h2 : 0;
}
function attr$4(emit2, item, renderer) {
  const img = getImage(item, renderer), w4 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w4), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit2("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit2("transform", translate(x2, y2));
  emit2("width", w4);
  emit2("height", h2);
  emit2("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$4(bounds2, item) {
  const img = item.image, w4 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w4), y2 = (item.y || 0) - imageYOffset(item.baseline, h2);
  return bounds2.set(x2, y2, x2 + w4, y2 + h2);
}
function draw$3(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds)) return;
    const img = getImage(item, this);
    let w4 = imageWidth(item, img);
    let h2 = imageHeight(item, img);
    if (w4 === 0 || h2 === 0) return;
    let x2 = (item.x || 0) - imageXOffset(item.align, w4), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), opacity2, ar0, ar1, t2;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t2 = w4 / ar0;
          y2 += (h2 - t2) / 2;
          h2 = t2;
        } else {
          t2 = h2 * ar0;
          x2 += (w4 - t2) / 2;
          w4 = t2;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context3, item);
      context3.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context3.imageSmoothingEnabled = item.smooth !== false;
      context3.drawImage(img, x2, y2, w4, h2);
    }
  });
}
var image = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};
var line = markMultiItemPath("line", line$1, pickLine);
function attr$3(emit2, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit2("vector-effect", "non-scaling-stroke");
  }
  emit2("transform", transformItem(item));
  emit2("d", item.path);
}
function path$1(context3, item) {
  var path3 = item.path;
  if (path3 == null) return true;
  var x2 = item.x || 0, y2 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path3) {
    (item.pathCache = cache2 = parse4(path3)).path = path3;
  }
  if (a && context3.rotate && context3.translate) {
    context3.translate(x2, y2);
    context3.rotate(a);
    pathRender(context3, cache2, 0, 0, sx, sy);
    context3.rotate(-a);
    context3.translate(-x2, -y2);
  } else {
    pathRender(context3, cache2, x2, y2, sx, sy);
  }
}
function bound$3(bounds2, item) {
  return path$1(boundContext(bounds2, item.angle), item) ? bounds2.set(0, 0, 0, 0) : boundStroke(bounds2, item, true);
}
var path$2 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};
function attr$2(emit2, item) {
  emit2("d", rectangle(null, item));
}
function bound$2(bounds2, item) {
  var x2, y2;
  return boundStroke(bounds2.set(x2 = item.x || 0, y2 = item.y || 0, x2 + item.width || 0, y2 + item.height || 0), item);
}
function draw$2(context3, item) {
  context3.beginPath();
  rectangle(context3, item);
}
var rect = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};
function attr$1(emit2, item) {
  emit2("transform", translateItem(item));
  emit2("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit2("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds2, item) {
  var x12, y12;
  return boundStroke(bounds2.set(x12 = item.x || 0, y12 = item.y || 0, item.x2 != null ? item.x2 : x12, item.y2 != null ? item.y2 : y12), item);
}
function path2(context3, item, opacity2) {
  var x12, y12, x2, y2;
  if (item.stroke && stroke(context3, item, opacity2)) {
    x12 = item.x || 0;
    y12 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x12;
    y2 = item.y2 != null ? item.y2 : y12;
    context3.beginPath();
    context3.moveTo(x12, y12);
    context3.lineTo(x2, y2);
    return true;
  }
  return false;
}
function draw$1(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds)) return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path2(context3, item, opacity2)) {
      blend(context3, item);
      context3.stroke();
    }
  });
}
function hit$1(context3, item, x2, y2) {
  if (!context3.isPointInStroke) return false;
  return path2(context3, item, 1) && context3.isPointInStroke(x2, y2);
}
var rule = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};
var shape = markItemPath("shape", shape$1);
var symbol = markItemPath("symbol", symbol$1, intersectPoint);
var widthCache = lruCache();
var textMetrics = {
  height: fontSize,
  measureWidth,
  estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
}
function estimateWidth(item, text4) {
  return _estimateWidth(textValue(item, text4), fontSize(item));
}
function _estimateWidth(text4, currentFontHeight) {
  return ~~(0.8 * text4.length * currentFontHeight);
}
function measureWidth(item, text4) {
  return fontSize(item) <= 0 || !(text4 = textValue(item, text4)) ? 0 : _measureWidth(text4, font(item));
}
function _measureWidth(text4, currentFont) {
  const key2 = `(${currentFont}) ${text4}`;
  let width2 = widthCache.get(key2);
  if (width2 === void 0) {
    context.font = currentFont;
    width2 = context.measureText(text4).width;
    widthCache.set(key2, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl2 = textLines(item);
  return (isArray(tl2) ? tl2.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line4) {
  const text4 = line4 == null ? "" : (line4 + "").trim();
  return item.limit > 0 && text4.length ? truncate2(item, text4) : text4;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font(item);
    return (text4) => _measureWidth(text4, currentFont);
  } else if (textMetrics.width === estimateWidth) {
    const currentFontHeight = fontSize(item);
    return (text4) => _estimateWidth(text4, currentFontHeight);
  } else {
    return (text4) => textMetrics.width(item, text4);
  }
}
function truncate2(item, text4) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text4) < limit) return text4;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text4.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text4.slice(mid)) > limit) lo = mid + 1;
      else hi = mid;
    }
    return ellipsis + text4.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text4.slice(0, mid)) < limit) lo = mid;
      else hi = mid - 1;
    }
    return text4.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font3 = item.font;
  return (quote && font3 ? String(font3).replace(/"/g, "'") : font3) || "sans-serif";
}
function font(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset2(item) {
  var baseline3 = item.baseline, h2 = fontSize(item);
  return Math.round(baseline3 === "top" ? 0.79 * h2 : baseline3 === "middle" ? 0.3 * h2 : baseline3 === "bottom" ? -0.21 * h2 : baseline3 === "line-top" ? 0.29 * h2 + 0.5 * lineHeight(item) : baseline3 === "line-bottom" ? 0.29 * h2 - 0.5 * lineHeight(item) : 0);
}
var textAlign = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds = new Bounds();
function anchorPoint(item) {
  var x2 = item.x || 0, y2 = item.y || 0, r2 = item.radius || 0, t2;
  if (r2) {
    t2 = (item.theta || 0) - HalfPi;
    x2 += r2 * Math.cos(t2);
    y2 += r2 * Math.sin(t2);
  }
  tempBounds.x1 = x2;
  tempBounds.y1 = y2;
  return tempBounds;
}
function attr(emit2, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset2(item), p = anchorPoint(item), x2 = p.x1, y2 = p.y1, a = item.angle || 0, t2;
  emit2("text-anchor", textAlign[item.align] || "start");
  if (a) {
    t2 = translate(x2, y2) + " " + rotate(a);
    if (dx || dy) t2 += " " + translate(dx, dy);
  } else {
    t2 = translate(x2 + dx, y2 + dy);
  }
  emit2("transform", t2);
}
function bound(bounds2, item, mode) {
  var h2 = textMetrics.height(item), a = item.align, p = anchorPoint(item), x2 = p.x1, y2 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset2(item) - Math.round(0.8 * h2), tl2 = textLines(item), w4;
  if (isArray(tl2)) {
    h2 += lineHeight(item) * (tl2.length - 1);
    w4 = tl2.reduce((w5, t2) => Math.max(w5, textMetrics.width(item, t2)), 0);
  } else {
    w4 = textMetrics.width(item, tl2);
  }
  if (a === "center") {
    dx -= w4 / 2;
  } else if (a === "right") {
    dx -= w4;
  } else ;
  bounds2.set(dx += x2, dy += y2, dx + w4, dy + h2);
  if (item.angle && !mode) {
    bounds2.rotate(item.angle * DegToRad, x2, y2);
  } else if (mode === 2) {
    return bounds2.rotatedPoints(item.angle * DegToRad, x2, y2);
  }
  return bounds2;
}
function draw(context3, scene, bounds2) {
  visit(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x2, y2, i, lh, tl2, str;
    if (bounds2 && !bounds2.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
    context3.font = font(item);
    context3.textAlign = item.align || "left";
    p = anchorPoint(item);
    x2 = p.x1, y2 = p.y1;
    if (item.angle) {
      context3.save();
      context3.translate(x2, y2);
      context3.rotate(item.angle * DegToRad);
      x2 = y2 = 0;
    }
    x2 += item.dx || 0;
    y2 += (item.dy || 0) + offset2(item);
    tl2 = textLines(item);
    blend(context3, item);
    if (isArray(tl2)) {
      lh = lineHeight(item);
      for (i = 0; i < tl2.length; ++i) {
        str = textValue(item, tl2[i]);
        if (item.fill && fill(context3, item, opacity2)) {
          context3.fillText(str, x2, y2);
        }
        if (item.stroke && stroke(context3, item, opacity2)) {
          context3.strokeText(str, x2, y2);
        }
        y2 += lh;
      }
    } else {
      str = textValue(item, tl2);
      if (item.fill && fill(context3, item, opacity2)) {
        context3.fillText(str, x2, y2);
      }
      if (item.stroke && stroke(context3, item, opacity2)) {
        context3.strokeText(str, x2, y2);
      }
    }
    if (item.angle) context3.restore();
  });
}
function hit(context3, item, x2, y2, gx, gy) {
  if (item.fontSize <= 0) return false;
  if (!item.angle) return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b2 = bound(tempBounds, item, 1), a = -item.angle * DegToRad, cos2 = Math.cos(a), sin2 = Math.sin(a), px2 = cos2 * gx - sin2 * gy + (ax - cos2 * ax + sin2 * ay), py2 = sin2 * gx + cos2 * gy + (ay - sin2 * ax - cos2 * ay);
  return b2.contains(px2, py2);
}
function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text = {
  type: "text",
  tag: "text",
  nested: false,
  attr,
  bound,
  draw,
  pick: pick$1(hit),
  isect: intersectText
};
var trail = markMultiItemPath("trail", trail$1, pickTrail);
var Marks = {
  arc,
  area,
  group,
  image,
  line,
  path: path$2,
  rect,
  rule,
  shape,
  symbol,
  text,
  trail
};
function boundItem(item, func, opt) {
  var type3 = Marks[item.mark.marktype], bound2 = func || type3.bound;
  if (type3.nested) item = item.mark;
  return bound2(item.bounds || (item.bounds = new Bounds()), item, opt);
}
var DUMMY = {
  mark: null
};
function boundMark(mark2, bounds2, opt) {
  var type3 = Marks[mark2.marktype], bound2 = type3.bound, items = mark2.items, hasItems = items && items.length, i, n, item, b2;
  if (type3.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      DUMMY.mark = mark2;
      item = DUMMY;
    }
    b2 = boundItem(item, bound2, opt);
    bounds2 = bounds2 && bounds2.union(b2) || b2;
    return bounds2;
  }
  bounds2 = bounds2 || mark2.bounds && mark2.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds2.union(boundItem(items[i], bound2, opt));
    }
  }
  return mark2.bounds = bounds2;
}
var keys = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json2) {
  const scene = typeof json2 === "string" ? JSON.parse(json2) : json2;
  return initialize(scene);
}
function initialize(scene) {
  var type3 = scene.marktype, items = scene.items, parent, i, n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type3 ? "mark" : "group";
      items[i][parent] = scene;
      if (items[i].zindex) items[i][parent].zdirty = true;
      if ("group" === (type3 || parent)) initialize(items[i]);
    }
  }
  if (type3) boundMark(scene);
  return scene;
}
var Scenegraph = class {
  constructor(scene) {
    if (arguments.length) {
      this.root = sceneFromJSON(scene);
    } else {
      this.root = createMark({
        marktype: "group",
        name: "root",
        role: "frame"
      });
      this.root.items = [new GroupItem(this.root)];
    }
  }
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  }
  mark(markdef, group2, index3) {
    group2 = group2 || this.root.items[0];
    const mark2 = createMark(markdef, group2);
    group2.items[index3] = mark2;
    if (mark2.zindex) mark2.group.zdirty = true;
    return mark2;
  }
};
function createMark(def2, group2) {
  const mark2 = {
    bounds: new Bounds(),
    clip: !!def2.clip,
    group: group2,
    interactive: def2.interactive === false ? false : true,
    items: [],
    marktype: def2.marktype,
    name: def2.name || void 0,
    role: def2.role || void 0,
    zindex: def2.zindex || 0
  };
  if (def2.aria != null) {
    mark2.aria = def2.aria;
  }
  if (def2.description) {
    mark2.description = def2.description;
  }
  return mark2;
}
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
    return nodes[i];
  }
}
function domChild(el, index3, tag, ns) {
  var a = el.childNodes[index3], b2;
  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
    b2 = a || null;
    a = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a, b2);
  }
  return a;
}
function domClear(el, index3) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index3) el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark2) {
  return "mark-" + mark2.marktype + (mark2.role ? " role-" + mark2.role : "") + (mark2.name ? " " + mark2.name : "");
}
function point2(event2, el) {
  const rect3 = el.getBoundingClientRect();
  return [event2.clientX - rect3.left - (el.clientLeft || 0), event2.clientY - rect3.top - (el.clientTop || 0)];
}
function resolveItem(item, event2, el, origin) {
  var mark2 = item && item.mark, mdef, p;
  if (mark2 && (mdef = Marks[mark2.marktype]).tip) {
    p = point2(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark2.items, p);
  }
  return item;
}
var Handler = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || loader();
    this._tooltip = customTooltip || defaultTooltip;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length) return this._scene;
    this._scene = scene;
    return this;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h2, type3, handler) {
    for (let i = h2 ? h2.length : 0; --i >= 0; ) {
      if (h2[i].type === type3 && (!handler || h2[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type3) {
    const h2 = this._handlers, a = [];
    if (type3) {
      a.push(...h2[this.eventName(type3)]);
    } else {
      for (const k2 in h2) {
        a.push(...h2[k2]);
      }
    }
    return a;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name4) {
    const i = name4.indexOf(".");
    return i < 0 ? name4 : name4.slice(0, i);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href2) {
    this._loader.sanitize(href2, {
      context: "href"
    }).then((opt) => {
      const e2 = new MouseEvent(event2.type, event2), a = domCreate(null, "a");
      for (const name4 in opt) a.setAttribute(name4, opt[name4]);
      a.dispatchEvent(e2);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event2, this.canvas(), this._origin);
      const value3 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value3);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el) return;
    const rect3 = el.getBoundingClientRect(), origin = this._origin, bounds2 = item.bounds, width2 = bounds2.width(), height2 = bounds2.height();
    let x2 = bounds2.x1 + origin[0] + rect3.left, y2 = bounds2.y1 + origin[1] + rect3.top;
    while (item.mark && (item = item.mark.group)) {
      x2 += item.x || 0;
      y2 += item.y || 0;
    }
    return {
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      left: x2,
      top: y2,
      right: x2 + width2,
      bottom: y2 + height2
    };
  }
};
function defaultTooltip(handler, event2, item, value3) {
  handler.element().setAttribute("title", value3 || "");
}
var Renderer = class {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader2) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader(loader2);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0) return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r2 = this;
    r2._call = function() {
      r2._render(scene, markTypes);
    };
    r2._call();
    r2._call = null;
    return r2;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r2 = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r2) : Promise.resolve(r2);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method2, uri) {
    var r2 = this, p = r2._loader[method2](uri);
    if (!r2._ready) {
      const call = r2._call;
      r2._ready = r2._loader.ready().then((redraw) => {
        if (redraw) call();
        r2._ready = null;
      });
    }
    return p;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent = "keydown";
var KeyPressEvent = "keypress";
var KeyUpEvent = "keyup";
var DragEnterEvent = "dragenter";
var DragLeaveEvent = "dragleave";
var DragOverEvent = "dragover";
var PointerDownEvent = "pointerdown";
var PointerUpEvent = "pointerup";
var PointerMoveEvent = "pointermove";
var PointerOutEvent = "pointerout";
var PointerOverEvent = "pointerover";
var MouseDownEvent = "mousedown";
var MouseUpEvent = "mouseup";
var MouseMoveEvent = "mousemove";
var MouseOutEvent = "mouseout";
var MouseOverEvent = "mouseover";
var ClickEvent = "click";
var DoubleClickEvent = "dblclick";
var WheelEvent = "wheel";
var MouseWheelEvent = "mousewheel";
var TouchStartEvent = "touchstart";
var TouchMoveEvent = "touchmove";
var TouchEndEvent = "touchend";
var Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
var TooltipShowEvent = PointerMoveEvent;
var TooltipHideEvent = MouseOutEvent;
var HrefEvent = ClickEvent;
var CanvasHandler = class extends Handler {
  constructor(loader2, tooltip2) {
    super(loader2, tooltip2);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};
    this.events = Events;
    this.pointermove = move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]);
    this.dragover = move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]), this.pointerout = inactive([PointerOutEvent, MouseOutEvent]);
    this.dragleave = inactive([DragLeaveEvent]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, "canvas");
    [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach((type3) => eventListenerCheck(this, type3));
    return super.initialize(el, origin, obj);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  }
  // fire an event
  fire(type3, evt, touch2) {
    const a = touch2 ? this._touch : this._active, h2 = this._handlers[type3];
    evt.vegaType = type3;
    if (type3 === HrefEvent && a && a.href) {
      this.handleHref(evt, a, a.href);
    } else if (type3 === TooltipShowEvent || type3 === TooltipHideEvent) {
      this.handleTooltip(evt, a, type3 !== TooltipHideEvent);
    }
    if (h2) {
      for (let i = 0, len = h2.length; i < len; ++i) {
        h2[i].handler.call(this._obj, evt, a);
      }
    }
  }
  // add an event handler
  on(type3, handler) {
    const name4 = this.eventName(type3), h2 = this._handlers, i = this._handlerIndex(h2[name4], type3, handler);
    if (i < 0) {
      eventListenerCheck(this, type3);
      (h2[name4] || (h2[name4] = [])).push({
        type: type3,
        handler
      });
    }
    return this;
  }
  // remove an event handler
  off(type3, handler) {
    const name4 = this.eventName(type3), h2 = this._handlers[name4], i = this._handlerIndex(h2, type3, handler);
    if (i >= 0) {
      h2.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point2(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x2, y2, gx, gy) {
    const g = this.context(), mark2 = Marks[scene.marktype];
    return mark2.pick.call(this, g, scene, x2, y2, gx, gy);
  }
};
var eventBundle = (type3) => type3 === TouchStartEvent || type3 === TouchMoveEvent || type3 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type3];
function eventListenerCheck(handler, type3) {
  eventBundle(type3).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type3) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type3]) {
    handler._events[type3] = 1;
    canvas.addEventListener(type3, handler[type3] ? (evt) => handler[type3](evt) : (evt) => handler.fire(type3, evt));
  }
}
function fireAll(handler, types4, event2) {
  types4.forEach((type3) => handler.fire(type3, event2));
}
function move(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a = this._active, p = this.pickEvent(evt);
    if (p === a) {
      fireAll(this, moveEvents, evt);
    } else {
      if (!a || !a.exit) {
        fireAll(this, outEvents, evt);
      }
      this._active = p;
      fireAll(this, overEvents, evt);
      fireAll(this, moveEvents, evt);
    }
  };
}
function inactive(types4) {
  return function(evt) {
    fireAll(this, types4, evt);
    this._active = null;
  };
}
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context3 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key2 in opt) {
    context3[key2] = opt[key2];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context3.pixelRatio = ratio;
  context3.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
var CanvasRenderer = class extends Renderer {
  constructor(loader2) {
    super(loader2);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds();
    this._tempb = new Bounds();
  }
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx) error("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(item) {
    const b2 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b2.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b2);
  }
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w4 = this._width, h2 = this._height, db = this._dirty, vb = viewBounds(o, w4, h2);
    g.save();
    const b2 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w4, h2);
    this.draw(g, scene, b2, markTypes);
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds2, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark2 = Marks[scene.marktype];
    if (scene.clip) clip(ctx, scene);
    mark2.draw.call(this, ctx, scene, bounds2, markTypes);
    if (scene.clip) ctx.restore();
  }
  clear(x2, y2, w4, h2) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x2, y2, w4, h2);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x2, y2, w4, h2);
    }
  }
};
var viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds(g, b2, origin) {
  b2.expand(1).round();
  if (g.pixelRatio % 1) {
    b2.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b2.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b2.x1, b2.y1, b2.width(), b2.height());
  g.clip();
  return b2;
}
var SVGHandler = class extends Handler {
  constructor(loader2, tooltip2) {
    super(loader2, tooltip2);
    const h2 = this;
    h2._hrefHandler = listener(h2, (evt, item) => {
      if (item && item.href) h2.handleHref(evt, item, item.href);
    });
    h2._tooltipHandler = listener(h2, (evt, item) => {
      h2.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(type3, handler) {
    const name4 = this.eventName(type3), h2 = this._handlers, i = this._handlerIndex(h2[name4], type3, handler);
    if (i < 0) {
      const x2 = {
        type: type3,
        handler,
        listener: listener(this, handler)
      };
      (h2[name4] || (h2[name4] = [])).push(x2);
      if (this._svg) {
        this._svg.addEventListener(name4, x2.listener);
      }
    }
    return this;
  }
  // remove an event handler
  off(type3, handler) {
    const name4 = this.eventName(type3), h2 = this._handlers[name4], i = this._handlerIndex(h2, type3, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name4, h2[i].listener);
      }
      h2.splice(i, 1);
    }
    return this;
  }
};
var listener = (context3, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context3._obj, evt, item);
};
var ARIA_HIDDEN = "aria-hidden";
var ARIA_LABEL = "aria-label";
var ARIA_ROLE = "role";
var ARIA_ROLEDESCRIPTION = "aria-roledescription";
var GRAPHICS_OBJECT = "graphics-object";
var GRAPHICS_SYMBOL = "graphics-symbol";
var bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || void 0
});
var AriaIgnore = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides = {
  "axis": {
    desc: "axis",
    caption: axisCaption
  },
  "legend": {
    desc: "legend",
    caption: legendCaption
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption(item)}'`
  }
};
var AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit2, item) {
  const hide = item.aria === false;
  emit2(ARIA_HIDDEN, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit2(AriaEncode[prop], void 0);
    }
  } else {
    const type3 = item.mark.marktype;
    emit2(ARIA_LABEL, item.description);
    emit2(ARIA_ROLE, item.ariaRole || (type3 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit2(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type3} mark`);
  }
}
function ariaMarkAttributes(mark2) {
  return mark2.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark2.role] ? null : AriaGuides[mark2.role] ? ariaGuide(mark2, AriaGuides[mark2.role]) : ariaMark(mark2);
}
function ariaMark(mark2) {
  const type3 = mark2.marktype;
  const recurse2 = type3 === "group" || type3 === "text" || mark2.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse2 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type3} mark container`, mark2.description);
}
function ariaGuide(mark2, opt) {
  try {
    const item = mark2.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array(item.text).join(" ");
}
function axisCaption(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle(item) : null, ctx = item.context, scale6 = ctx.scales[datum2.scale].value, locale2 = ctx.dataflow.locale(), type3 = scale6.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete(type3) ? "discrete" : type3} scale with ${domainCaption(locale2, scale6, item)}`;
}
function legendCaption(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle(item) : null, type3 = `${datum2.type || ""} legend`.trim(), scales2 = datum2.scales, props = Object.keys(scales2), ctx = item.context, scale6 = ctx.scales[scales2[props[0]]].value, locale2 = ctx.dataflow.locale();
  return capitalize(type3) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption(props)} with ${domainCaption(locale2, scale6, item)}`;
}
function extractTitle(item) {
  try {
    return array(peek(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek(props);
}
function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}
var innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
  let buf = "", outer = "", inner = "";
  const stack2 = [], clear2 = () => outer = inner = "", push2 = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack2.push(tag);
  }, attr2 = (name4, value3) => {
    if (value3 != null) outer += ` ${name4}="${attrText(value3)}"`;
    return m;
  }, m = {
    open(tag) {
      push2(tag);
      outer = "<" + tag;
      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        attrs[_key - 1] = arguments[_key];
      }
      for (const set5 of attrs) {
        for (const key2 in set5) attr2(key2, set5[key2]);
      }
      return m;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m;
    },
    attr: attr2,
    text: (t2) => (inner += innerText(t2), m),
    toString: () => buf
  };
  return m;
}
var serializeXML = (node) => _serialize(markup(), node) + "";
function _serialize(m, node) {
  m.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children4 = node.childNodes;
    for (const child of children4) {
      child.nodeType === 3 ? m.text(child.nodeValue) : _serialize(m, child);
    }
  }
  return m.close();
}
var stylesAttr = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss = {
  blend: "mix-blend-mode"
};
var rootAttributes = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex = 0;
var xmlns = "http://www.w3.org/2000/xmlns/";
var svgns = metadata.xmlns;
var SVGRenderer = class extends Renderer {
  constructor(loader2) {
    super(loader2);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, "svg", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata["version"]);
      this._svg.setAttribute("class", "marks");
      domClear(el, 1);
      this._root = domChild(this._svg, RootIndex, "g", svgns);
      setAttributes(this._root, rootAttributes);
      domClear(this._svg, RootIndex + 1);
    }
    this.background(this._bgcolor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg) return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild(svg, RootIndex, "rect", svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text4 = serializeXML(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text4;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll) this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID) return true;
    const id2 = ++this._dirtyID;
    let item, mark2, type3, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark2 = item.mark;
      if (mark2.marktype !== type3) {
        type3 = mark2.marktype;
        mdef = Marks[type3];
      }
      if (mark2.zdirty && mark2.dirty !== id2) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
        mark2.items.forEach((i2) => {
          i2.dirty = id2;
        });
      }
      if (mark2.zdirty) continue;
      if (item.exit) {
        if (mdef.nested && mark2.items.length) {
          o = mark2.items[0];
          if (o._svg) this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o) o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark2.items[0] : item;
      if (item._update === id2) continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id2;
    }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks[markType2], events4 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass(scene));
    const aria2 = ariaMarkAttributes(scene);
    for (const key2 in aria2) setAttribute(parent, key2, aria2[key2]);
    if (!isGroup) {
      setAttribute(parent, "pointer-events", events4);
    }
    setAttribute(parent, "clip-path", scene.clip ? clip$1(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup) recurse(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length) process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    domClear(parent, i);
    return parent;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element = el;
    values = el.__values__;
    ariaItemAttributes(emit, item);
    mdef.attr(emit, item, this);
    const extra = mark_extras[mdef.type];
    if (extra) extra.call(this, mdef, el, item);
    if (element) this.style(element, item);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null) return;
    for (const prop in stylesAttr) {
      let value3 = prop === "font" ? fontFamily(item) : item[prop];
      if (value3 === values[prop]) continue;
      const name4 = stylesAttr[prop];
      if (value3 == null) {
        el.removeAttribute(name4);
      } else {
        if (isGradient(value3)) {
          value3 = gradientRef(value3, this._defs.gradient, href());
        }
        el.setAttribute(name4, value3 + "");
      }
      values[prop] = value3;
    }
    for (const prop in stylesCss) {
      setStyle(el, stylesCss[prop], item[prop]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index3 = 0;
    for (const id2 in defs.gradient) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index3 = updateGradient(el, defs.gradient[id2], index3);
    }
    for (const id2 in defs.clipping) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index3 = updateClipping(el, defs.clipping[id2], index3);
    }
    if (el) {
      index3 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index3);
    }
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def2 = this._defs;
    def2.gradient = {};
    def2.clipping = {};
  }
};
function dirtyParents(item, id2) {
  for (; item && item.dirty !== id2; item = item.mark.group) {
    item.dirty = id2;
    if (item.mark && item.mark.dirty !== id2) {
      item.mark.dirty = id2;
    } else return;
  }
}
function updateGradient(el, grad, index3) {
  let i, n, stop3;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index3++, "pattern", svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index3++, "radialGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index3++, "linearGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop3 = domChild(el, i, "stop", svgns);
    stop3.setAttribute("offset", grad.stops[i].offset);
    stop3.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index3;
}
function updateClipping(el, clip3, index3) {
  let mask;
  el = domChild(el, index3, "clipPath", svgns);
  el.setAttribute("id", clip3.id);
  if (clip3.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip3.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip3.width,
      height: clip3.height
    });
  }
  domClear(el, 1);
  return index3 + 1;
}
function recurse(renderer, el, group2, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit(group2, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element = null;
var values = null;
var mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__;
    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value3 = item.mark.interactive === false ? "none" : null;
    if (value3 !== values.events) {
      setAttribute(fg, "pointer-events", value3);
      setAttribute(bg, "pointer-events", value3);
      values.events = value3;
    }
    if (item.strokeForeground && item.stroke) {
      const fill2 = item.fill;
      setAttribute(fg, "display", null);
      this.style(bg, item);
      setAttribute(bg, "stroke", null);
      if (fill2) item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill2) item.fill = fill2;
      element = null;
    } else {
      setAttribute(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, "image-rendering", "optimizeSpeed");
      setStyle(el, "image-rendering", "pixelated");
    } else {
      setStyle(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl2 = textLines(item);
    let key2, value3, doc, lh;
    if (isArray(tl2)) {
      value3 = tl2.map((_) => textValue(item, _));
      key2 = value3.join("\n");
      if (key2 !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value3.forEach((t2, i) => {
          const ts2 = domCreate(doc, "tspan", svgns);
          ts2.__data__ = item;
          ts2.textContent = t2;
          if (i) {
            ts2.setAttribute("x", 0);
            ts2.setAttribute("dy", lh);
          }
          el.appendChild(ts2);
        });
        values.text = key2;
      }
    } else {
      value3 = textValue(item, tl2);
      if (value3 !== values.text) {
        el.textContent = value3;
        values.text = value3;
      }
    }
    setAttribute(el, "font-family", fontFamily(item));
    setAttribute(el, "font-size", fontSize(item) + "px");
    setAttribute(el, "font-style", item.fontStyle);
    setAttribute(el, "font-variant", item.fontVariant);
    setAttribute(el, "font-weight", item.fontWeight);
  }
};
function emit(name4, value3, ns) {
  if (value3 === values[name4]) return;
  if (ns) {
    setAttributeNS(element, name4, value3, ns);
  } else {
    setAttribute(element, name4, value3);
  }
  values[name4] = value3;
}
function setStyle(el, name4, value3) {
  if (value3 !== values[name4]) {
    if (value3 == null) {
      el.style.removeProperty(name4);
    } else {
      el.style.setProperty(name4, value3 + "");
    }
    values[name4] = value3;
  }
}
function setAttributes(el, attrs) {
  for (const key2 in attrs) {
    setAttribute(el, key2, attrs[key2]);
  }
}
function setAttribute(el, name4, value3) {
  if (value3 != null) {
    el.setAttribute(name4, value3);
  } else {
    el.removeAttribute(name4);
  }
}
function setAttributeNS(el, name4, value3, ns) {
  if (value3 != null) {
    el.setAttributeNS(ns, name4, value3);
  } else {
    el.removeAttributeNS(ns, name4);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
var SVGStringRenderer = class extends Renderer {
  constructor(loader2) {
    super(loader2);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m = markup();
    m.open("svg", extend({}, metadata, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m.open("g", rootAttributes, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m, scene);
    m.close();
    this.defs(m);
    this._text = m.close() + "";
    return this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m, scene) {
    const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
    m.open("g", {
      "class": cssClass(scene),
      "clip-path": scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href2 = this.href(item);
      if (href2) m.open("a", href2);
      m.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl2 = textLines(item);
        if (isArray(tl2)) {
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl2.length; ++i) {
            m.open("tspan", i ? attrs : null).text(textValue(item, tl2[i])).close();
          }
        } else {
          m.text(textValue(item, tl2));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill2 = item.fill, stroke2 = item.stroke;
        if (fore && stroke2) {
          item.stroke = null;
        }
        m.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m.open("g", this.attr(scene, item, mdef.content));
        visit(item, (scene2) => this.mark(m, scene2));
        m.close();
        if (fore && stroke2) {
          if (fill2) item.fill = null;
          item.stroke = stroke2;
          m.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill2) item.fill = fill2;
        } else {
          m.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m.close();
      if (href2) m.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length) process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    return m.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href2 = item.href;
    let attr2;
    if (href2) {
      if (attr2 = this._hrefs && this._hrefs[href2]) {
        return attr2;
      } else {
        this.sanitizeURL(href2).then((attr3) => {
          attr3["xlink:href"] = attr3.href;
          attr3.href = null;
          (this._hrefs || (this._hrefs = {}))[href2] = attr3;
        });
      }
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit2 = (name4, value3, ns, prefixed) => {
      object2[prefixed || name4] = value3;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit2, item, this));
    } else {
      attrs(emit2, item, this);
    }
    if (tag) {
      style(object2, item, scene, tag, this._defs);
    }
    return object2;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m) {
    const gradient4 = this._defs.gradient, clipping = this._defs.clipping, count = Object.keys(gradient4).length + Object.keys(clipping).length;
    if (count === 0) return;
    m.open("defs");
    for (const id2 in gradient4) {
      const def2 = gradient4[id2], stops = def2.stops;
      if (def2.gradient === "radial") {
        m.open("pattern", {
          id: patternPrefix + id2,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id2 + ")"
        }).close();
        m.close();
        m.open("radialGradient", {
          id: id2,
          fx: def2.x1,
          fy: def2.y1,
          fr: def2.r1,
          cx: def2.x2,
          cy: def2.y2,
          r: def2.r2
        });
      } else {
        m.open("linearGradient", {
          id: id2,
          x1: def2.x1,
          x2: def2.x2,
          y1: def2.y1,
          y2: def2.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m.close();
    }
    for (const id2 in clipping) {
      const def2 = clipping[id2];
      m.open("clipPath", {
        id: id2
      });
      if (def2.path) {
        m.open("path", {
          d: def2.path
        }).close();
      } else {
        m.open("rect", {
          x: 0,
          y: 0,
          width: def2.width,
          height: def2.height
        }).close();
      }
      m.close();
    }
    m.close();
  }
};
function style(s, item, scene, tag, defs) {
  let styleList;
  if (item == null) return s;
  if (tag === "bgrect" && scene.interactive === false) {
    s["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s["pointer-events"] = "none";
    }
    s.display = "none";
    if (item.fill !== null) return s;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s["font-family"] = fontFamily(item);
    s["font-size"] = fontSize(item) + "px";
    s["font-style"] = item.fontStyle;
    s["font-variant"] = item.fontVariant;
    s["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr) {
    let value3 = item[prop];
    const name4 = stylesAttr[prop];
    if (value3 === "transparent" && (name4 === "fill" || name4 === "stroke")) ;
    else if (value3 != null) {
      if (isGradient(value3)) {
        value3 = gradientRef(value3, defs.gradient, "");
      }
      s[name4] = value3;
    }
  }
  for (const prop in stylesCss) {
    const value3 = item[prop];
    if (value3 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss[prop]}: ${value3};`);
    }
  }
  if (styleList) {
    s.style = styleList.join(" ");
  }
  return s;
}
var OPTS = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
function setHybridRendererOptions(options) {
  OPTS["svgMarkTypes"] = options.svgMarkTypes ?? ["text"];
  OPTS["svgOnTop"] = options.svgOnTop ?? true;
  OPTS["debug"] = options.debug ?? false;
}
var HybridRenderer = class extends Renderer {
  constructor(loader2) {
    super(loader2);
    this._svgRenderer = new SVGRenderer(loader2);
    this._canvasRenderer = new CanvasRenderer(loader2);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild(el, 0, "div");
    const bottomEl = domChild(this._root_el, 0, "div");
    const topEl = domChild(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m) => !OPTS.svgMarkTypes.includes(m));
    this._svgRenderer.render(scene, OPTS.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    if (OPTS.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
};
var HybridHandler = class extends CanvasHandler {
  constructor(loader2, tooltip2) {
    super(loader2, tooltip2);
  }
  initialize(el, origin, obj) {
    const canvas = domChild(domChild(el, 0, "div"), OPTS.svgOnTop ? 0 : 1, "div");
    return super.initialize(canvas, origin, obj);
  }
};
var Canvas = "canvas";
var Hybrid = "hybrid";
var PNG = "png";
var SVG = "svg";
var None2 = "none";
var RenderType = {
  Canvas,
  PNG,
  SVG,
  Hybrid,
  None: None2
};
var modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[Hybrid] = {
  renderer: HybridRenderer,
  headless: HybridRenderer,
  handler: HybridHandler
};
modules[None2] = {};
function renderModule(name4, _) {
  name4 = String(name4 || "").toLowerCase();
  if (arguments.length > 1) {
    modules[name4] = _;
    return this;
  } else {
    return modules[name4];
  }
}
function intersect(scene, bounds2, filter3) {
  const hits = [], box = new Bounds().union(bounds2), type3 = scene.marktype;
  return type3 ? intersectMark(scene, box, filter3, hits) : type3 === "group" ? intersectGroup(scene, box, filter3, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark2, box, filter3, hits) {
  if (visitMark(mark2, box, filter3)) {
    const items = mark2.items, type3 = mark2.marktype, n = items.length;
    let i = 0;
    if (type3 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter3, hits);
      }
    } else {
      for (const test2 = Marks[type3].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test2)) hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark2, box, filter3) {
  return mark2.bounds && box.intersects(mark2.bounds) && (mark2.marktype === "group" || mark2.interactive !== false && (!filter3 || filter3(mark2)));
}
function intersectGroup(group2, box, filter3, hits) {
  if (filter3 && filter3(group2.mark) && intersectItem(group2, box, Marks.group.isect)) {
    hits.push(group2);
  }
  const marks = group2.items, n = marks && marks.length;
  if (n) {
    const x2 = group2.x || 0, y2 = group2.y || 0;
    box.translate(-x2, -y2);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter3, hits);
    }
    box.translate(x2, y2);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds2 = item.bounds;
  return box.encloses(bounds2) || box.intersects(bounds2) && test2(item, box);
}
var clipBounds = new Bounds();
function boundClip(mark2) {
  const clip3 = mark2.clip;
  if (isFunction(clip3)) {
    clip3(boundContext(clipBounds.clear()));
  } else if (clip3) {
    clipBounds.set(0, 0, mark2.group.width, mark2.group.height);
  } else return;
  mark2.bounds.intersect(clipBounds);
}
var TOLERANCE = 1e-9;
function sceneEqual(a, b2, key2) {
  return a === b2 ? true : key2 === "path" ? pathEqual(a, b2) : a instanceof Date && b2 instanceof Date ? +a === +b2 : isNumber(a) && isNumber(b2) ? Math.abs(a - b2) <= TOLERANCE : !a || !b2 || !isObject(a) && !isObject(b2) ? a == b2 : objectEqual(a, b2);
}
function pathEqual(a, b2) {
  return sceneEqual(parse4(a), parse4(b2));
}
function objectEqual(a, b2) {
  var ka = Object.keys(a), kb = Object.keys(b2), key2, i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key2 = ka[i];
    if (!sceneEqual(a[key2], b2[key2], key2)) return false;
  }
  return typeof a === typeof b2;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var Top = "top";
var Left = "left";
var Right = "right";
var Bottom = "bottom";
var TopLeft = "top-left";
var TopRight = "top-right";
var BottomLeft = "bottom-left";
var BottomRight = "bottom-right";
var Start = "start";
var Middle = "middle";
var End = "end";
var X = "x";
var Y = "y";
var Group = "group";
var AxisRole = "axis";
var TitleRole = "title";
var FrameRole = "frame";
var ScopeRole = "scope";
var LegendRole = "legend";
var RowHeader = "row-header";
var RowFooter = "row-footer";
var RowTitle = "row-title";
var ColHeader = "column-header";
var ColFooter = "column-footer";
var ColTitle = "column-title";
var Padding = "padding";
var Symbols = "symbol";
var Fit = "fit";
var FitX = "fit-x";
var FitY = "fit-y";
var Pad = "pad";
var None3 = "none";
var All = "all";
var Each = "each";
var Flush = "flush";
var Column = "column";
var Row = "row";
function Bound(params2) {
  Transform.call(this, null, params2);
}
inherits(Bound, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow, mark2 = _.mark, type3 = mark2.marktype, entry2 = Marks[type3], bound2 = entry2.bound;
    let markBounds = mark2.bounds, rebound;
    if (entry2.nested) {
      if (mark2.items.length) view.dirty(mark2.items[0]);
      markBounds = boundItem2(mark2, bound2);
      mark2.items.forEach((item) => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type3 === Group || _.modified()) {
      pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
      markBounds.clear();
      mark2.items.forEach((item) => markBounds.union(boundItem2(item, bound2)));
      switch (mark2.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse2.reflow();
      }
    } else {
      rebound = pulse2.changed(pulse2.REM);
      pulse2.visit(pulse2.ADD, (item) => {
        markBounds.union(boundItem2(item, bound2));
      });
      pulse2.visit(pulse2.MOD, (item) => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem2(item, bound2));
      });
      if (rebound) {
        markBounds.clear();
        mark2.items.forEach((item) => markBounds.union(item.bounds));
      }
    }
    boundClip(mark2);
    return pulse2.modifies("bounds");
  }
});
function boundItem2(item, bound2, opt) {
  return bound2(item.bounds.clear(), item, opt);
}
var COUNTER_NAME = ":vega_identifier:";
function Identifier(params2) {
  Transform.call(this, 0, params2);
}
Identifier.Definition = {
  "type": "Identifier",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "as",
    "type": "string",
    "required": true
  }]
};
inherits(Identifier, Transform, {
  transform(_, pulse2) {
    const counter = getCounter(pulse2.dataflow), as = _.as;
    let id2 = counter.value;
    pulse2.visit(pulse2.ADD, (t2) => t2[as] = t2[as] || ++id2);
    counter.set(this.value = id2);
    return pulse2;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark(params2) {
  Transform.call(this, null, params2);
}
inherits(Mark, Transform, {
  transform(_, pulse2) {
    let mark2 = this.value;
    if (!mark2) {
      mark2 = pulse2.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);
      mark2.group.context = _.context;
      if (!_.context.group) _.context.group = mark2.group;
      mark2.source = this.source;
      mark2.clip = _.clip;
      mark2.interactive = _.interactive;
      this.value = mark2;
    }
    const Init = mark2.marktype === Group ? GroupItem : Item;
    pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark2));
    if (_.modified("clip") || _.modified("interactive")) {
      mark2.clip = _.clip;
      mark2.interactive = !!_.interactive;
      mark2.zdirty = true;
      pulse2.reflow();
    }
    mark2.items = pulse2.source;
    return pulse2;
  }
});
function lookup$1(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap(params2) {
  Transform.call(this, null, params2);
}
var methods = {
  parity: (items) => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a;
    return items.filter((b2, i) => !i || !intersect2(a.bounds, b2.bounds, sep) ? (a = b2, 1) : b2.opacity = 0);
  }
};
var intersect2 = (a, b2, sep) => sep > Math.max(b2.x1 - a.x2, a.x1 - b2.x2, b2.y1 - a.y2, a.y1 - b2.y2);
var hasOverlap = (items, pad2) => {
  for (var i = 1, n = items.length, a = items[0].bounds, b2; i < n; a = b2, ++i) {
    if (intersect2(a, b2 = items[i].bounds, pad2)) return true;
  }
};
var hasBounds = (item) => {
  const b2 = item.bounds;
  return b2.width() > 1 && b2.height() > 1;
};
var boundTest = (scale6, orient2, tolerance) => {
  var range6 = scale6.range(), b2 = new Bounds();
  if (orient2 === Top || orient2 === Bottom) {
    b2.set(range6[0], -Infinity, range6[1], Infinity);
  } else {
    b2.set(-Infinity, range6[0], Infinity, range6[1]);
  }
  b2.expand(tolerance || 1);
  return (item) => b2.encloses(item.bounds);
};
var reset = (source4) => {
  source4.forEach((item) => item.opacity = 1);
  return source4;
};
var reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
inherits(Overlap, Transform, {
  transform(_, pulse2) {
    const reduce2 = methods[_.method] || methods.parity, sep = _.separation || 0;
    let source4 = pulse2.materialize(pulse2.SOURCE).source, items, test2;
    if (!source4 || !source4.length) return;
    if (!_.method) {
      if (_.modified("method")) {
        reset(source4);
        pulse2 = reflow(pulse2, _);
      }
      return pulse2;
    }
    source4 = source4.filter(hasBounds);
    if (!source4.length) return;
    if (_.sort) {
      source4 = source4.slice().sort(_.sort);
    }
    items = reset(source4);
    pulse2 = reflow(pulse2, _);
    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce2(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));
      if (items.length < 3 && !peek(source4).opacity) {
        if (items.length > 1) peek(items).opacity = 0;
        peek(source4).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source4.forEach((item) => {
        if (!test2(item)) item.opacity = 0;
      });
    }
    const bounds2 = items[0].mark.bounds.clear();
    source4.forEach((item) => {
      if (item.opacity) bounds2.union(item.bounds);
    });
    return pulse2;
  }
});
function Render(params2) {
  Transform.call(this, null, params2);
}
inherits(Render, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
    if (pulse2.fields && pulse2.fields["zindex"]) {
      const item = pulse2.source && pulse2.source[0];
      if (item) item.mark.zdirty = true;
    }
  }
});
var tempBounds2 = new Bounds();
function set2(item, property2, value3) {
  return item[property2] === value3 ? 0 : (item[property2] = value3, 1);
}
function isYAxis(mark2) {
  var orient2 = mark2.items[0].orient;
  return orient2 === Left || orient2 === Right;
}
function axisIndices(datum2) {
  let index3 = +datum2.grid;
  return [
    datum2.ticks ? index3++ : -1,
    // ticks index
    datum2.labels ? index3++ : -1,
    // labels index
    index3 + +datum2.domain
    // title index
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient2 = item.orient, indices = axisIndices(datum2), range6 = item.range, offset4 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title2 = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds2 = item.bounds, dl = title2 && multiLineOffset(title2), x2 = 0, y2 = 0, i, s;
  tempBounds2.clear().union(bounds2);
  bounds2.clear();
  if ((i = indices[0]) > -1) bounds2.union(item.items[i].bounds);
  if ((i = indices[1]) > -1) bounds2.union(item.items[i].bounds);
  switch (orient2) {
    case Top:
      x2 = position2 || 0;
      y2 = -offset4;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.y1));
      bounds2.add(0, -s).add(range6, 0);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, dl, 0, -1, bounds2);
      break;
    case Left:
      x2 = -offset4;
      y2 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.x1));
      bounds2.add(-s, 0).add(0, range6);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, dl, 1, -1, bounds2);
      break;
    case Right:
      x2 = width2 + offset4;
      y2 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.x2));
      bounds2.add(0, 0).add(s, range6);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, dl, 1, 1, bounds2);
      break;
    case Bottom:
      x2 = position2 || 0;
      y2 = height2 + offset4;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.y2));
      bounds2.add(0, 0).add(range6, s);
      if (title2) axisTitleLayout(view, title2, s, titlePadding, 0, 0, 1, bounds2);
      break;
    default:
      x2 = item.x;
      y2 = item.y;
  }
  boundStroke(bounds2.translate(x2, y2), item);
  if (set2(item, "x", x2 + delta) | set2(item, "y", y2 + delta)) {
    item.bounds = tempBounds2;
    view.dirty(item);
    item.bounds = bounds2;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds2);
}
function axisTitleLayout(view, title2, offset4, pad2, dl, isYAxis2, sign2, bounds2) {
  const b2 = title2.bounds;
  if (title2.auto) {
    const v = sign2 * (offset4 + dl + pad2);
    let dx = 0, dy = 0;
    view.dirty(title2);
    isYAxis2 ? dx = (title2.x || 0) - (title2.x = v) : dy = (title2.y || 0) - (title2.y = v);
    title2.mark.bounds.clear().union(b2.translate(-dx, -dy));
    view.dirty(title2);
  }
  bounds2.union(b2);
}
var min2 = (a, b2) => Math.floor(Math.min(a, b2));
var max2 = (a, b2) => Math.ceil(Math.max(a, b2));
function gridLayoutGroups(group2) {
  var groups = group2.items, n = groups.length, i = 0, mark2, items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark2 = groups[i];
    items = mark2.items;
    if (mark2.marktype === Group) {
      switch (mark2.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items);
          break;
        case RowFooter:
          views.rowfooters.push(...items);
          break;
        case ColHeader:
          views.colheaders.push(...items);
          break;
        case ColFooter:
          views.colfooters.push(...items);
          break;
        case RowTitle:
          views.rowtitle = items[0];
          break;
        case ColTitle:
          views.coltitle = items[0];
          break;
        default:
          views.marks.push(...items);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b2 = item.bounds.clone();
  return b2.empty() ? b2.set(0, 0, 0, 0) : b2.translate(-(item.x || 0), -(item.y || 0));
}
function get4(opt, key2, d) {
  const v = isObject(opt) ? opt[key2] : opt;
  return v != null ? v : d !== void 0 ? d : 0;
}
function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds2 = tempBounds2.set(0, 0, 0, 0), alignCol = get4(opt.align, Column), alignRow = get4(opt.align, Row), padCol = get4(opt.padding, Column), padRow = get4(opt.padding, Row), ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), n = groups.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m, i, c, r2, b2, g, px2, py2, x2, y2, offset4;
  for (i = 0; i < ncols; ++i) xExtent[i] = 0;
  for (i = 0; i < nrows; ++i) yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups[i];
    b2 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c = i % ncols;
    r2 = ~~(i / ncols);
    xMax = Math.max(xMax, px2 = Math.ceil(b2.x2));
    yMax = Math.max(yMax, py2 = Math.ceil(b2.y2));
    xExtent[c] = Math.max(xExtent[c], px2);
    yExtent[r2] = Math.max(yExtent[r2], py2);
    xOffset[i] = padCol + offsetValue(b2.x1);
    yOffset[i] = padRow + offsetValue(b2.y1);
    if (dirty) view.dirty(groups[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0) xOffset[i] = 0;
    if (i < ncols) yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c = 1; c < ncols; ++c) {
      for (offset4 = 0, i = c; i < n; i += ncols) {
        if (offset4 < xOffset[i]) offset4 = xOffset[i];
      }
      for (i = c; i < n; i += ncols) {
        xOffset[i] = offset4 + xExtent[c - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset4 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset4 < xOffset[i]) offset4 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols) xOffset[i] = offset4 + xMax;
    }
  } else {
    for (alignCol = false, c = 1; c < ncols; ++c) {
      for (i = c; i < n; i += ncols) {
        xOffset[i] += xExtent[c - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r2 = 1; r2 < nrows; ++r2) {
      for (offset4 = 0, i = r2 * ncols, m = i + ncols; i < m; ++i) {
        if (offset4 < yOffset[i]) offset4 = yOffset[i];
      }
      for (i = r2 * ncols; i < m; ++i) {
        yOffset[i] = offset4 + yExtent[r2 - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset4 = 0, i = ncols; i < n; ++i) {
      if (offset4 < yOffset[i]) offset4 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset4 + yMax;
    }
  } else {
    for (alignRow = false, r2 = 1; r2 < nrows; ++r2) {
      for (i = r2 * ncols, m = i + ncols; i < m; ++i) {
        yOffset[i] += yExtent[r2 - 1];
      }
    }
  }
  for (x2 = 0, i = 0; i < n; ++i) {
    x2 = xOffset[i] + (i % ncols ? x2 : 0);
    dx[i] += x2 - groups[i].x;
  }
  for (c = 0; c < ncols; ++c) {
    for (y2 = 0, i = c; i < n; i += ncols) {
      y2 += yOffset[i];
      dy[i] += y2 - groups[i].y;
    }
  }
  if (alignCol && get4(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignCol === All ? xMax : xExtent[i % ncols];
      x2 = b2 - boxes[i].x2 - groups[i].x - dx[i];
      if (x2 > 0) dx[i] += x2 / 2;
    }
  }
  if (alignRow && get4(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y2 = b2 - boxes[i].y2 - groups[i].y - dy[i];
      if (y2 > 0) dy[i] += y2 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds2.union(boxes[i].translate(dx[i], dy[i]));
  }
  x2 = get4(opt.anchor, X);
  y2 = get4(opt.anchor, Y);
  switch (get4(opt.anchor, Column)) {
    case End:
      x2 -= bounds2.width();
      break;
    case Middle:
      x2 -= bounds2.width() / 2;
  }
  switch (get4(opt.anchor, Row)) {
    case End:
      y2 -= bounds2.height();
      break;
    case Middle:
      y2 -= bounds2.height() / 2;
  }
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  bounds2.clear();
  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x2;
    g.y += dy[i] += y2;
    bounds2.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty) view.dirty(g);
  }
  return bounds2;
}
function trellisLayout(view, group2, opt) {
  var views = gridLayoutGroups(group2), groups = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), cells = nrows * ncols, x2, y2, x22, y22, anchor, band2, offset4;
  const bounds2 = gridLayout(view, groups, opt);
  if (bounds2.empty()) bounds2.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band2 = get4(opt.headerBand, Row, null);
    x2 = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get4(off, "rowHeader"), min2, 0, bbox, "x1", 0, ncols, 1, band2);
  }
  if (views.colheaders) {
    band2 = get4(opt.headerBand, Column, null);
    y2 = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get4(off, "columnHeader"), min2, 1, bbox, "y1", 0, 1, ncols, band2);
  }
  if (views.rowfooters) {
    band2 = get4(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get4(off, "rowFooter"), max2, 0, bbox, "x2", ncols - 1, ncols, 1, band2);
  }
  if (views.colfooters) {
    band2 = get4(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get4(off, "columnFooter"), max2, 1, bbox, "y2", cells - ncols, 1, ncols, band2);
  }
  if (views.rowtitle) {
    anchor = get4(opt.titleAnchor, Row);
    offset4 = get4(off, "rowTitle");
    offset4 = anchor === End ? x22 + offset4 : x2 - offset4;
    band2 = get4(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset4, 0, bounds2, band2);
  }
  if (views.coltitle) {
    anchor = get4(opt.titleAnchor, Column);
    offset4 = get4(off, "columnTitle");
    offset4 = anchor === End ? y22 + offset4 : y2 - offset4;
    band2 = get4(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset4, 1, bounds2, band2);
  }
}
function boundFlush(item, field3) {
  return field3 === "x1" ? item.x || 0 : field3 === "y1" ? item.y || 0 : field3 === "x2" ? (item.x || 0) + (item.width || 0) : field3 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field3) {
  return item.bounds[field3];
}
function layoutHeaders(view, headers, groups, ncols, limit, offset4, agg, isX2, bound2, bf, start, stride, back, band2) {
  var n = groups.length, init2 = 0, edge = 0, i, j, k2, m, b2, h2, g, x2, y2;
  if (!n) return init2;
  for (i = start; i < n; i += stride) {
    if (groups[i]) init2 = agg(init2, bound2(groups[i], bf));
  }
  if (!headers.length) return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset4;
  for (j = 0, m = headers.length; j < m; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {
    h2 = headers[j];
    b2 = h2.mark.bounds;
    for (k2 = i; k2 >= 0 && (g = groups[k2]) == null; k2 -= back) ;
    if (isX2) {
      x2 = band2 == null ? g.x : Math.round(g.bounds.x1 + band2 * g.bounds.width());
      y2 = init2;
    } else {
      x2 = init2;
      y2 = band2 == null ? g.y : Math.round(g.bounds.y1 + band2 * g.bounds.height());
    }
    b2.union(h2.bounds.translate(x2 - (h2.x || 0), y2 - (h2.y || 0)));
    h2.x = x2;
    h2.y = y2;
    view.dirty(h2);
    edge = agg(edge, b2[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset4, isX2, bounds2, band2) {
  if (!g) return;
  view.dirty(g);
  var x2 = offset4, y2 = offset4;
  isX2 ? x2 = Math.round(bounds2.x1 + band2 * bounds2.width()) : y2 = Math.round(bounds2.y1 + band2 * bounds2.height());
  g.bounds.translate(x2 - (g.x || 0), y2 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x2;
  g.y = y2;
  view.dirty(g);
}
function lookup2(config, orient2) {
  const opt = config[orient2] || {};
  return (key2, d) => opt[key2] != null ? opt[key2] : config[key2] != null ? config[key2] : d;
}
function offsets(legends, value3) {
  let max4 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null) max4 = Math.max(max4, item.offset);
  });
  return max4 > -Infinity ? max4 : value3;
}
function legendParams(g, orient2, config, xb, yb, w4, h2) {
  const _ = lookup2(config, orient2), offset4 = offsets(g, _("offset", 0)), anchor = _("anchor", Start), mult2 = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient2) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset4,
        column: End,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset4,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset4,
        row: End,
        x: mult2 * (w4 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset4,
        x: mult2 * (w4 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset4,
        y: offset4
      };
      break;
    case TopRight:
      p.anchor = {
        x: w4 - offset4,
        y: offset4,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset4,
        y: h2 - offset4,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w4 - offset4,
        y: h2 - offset4,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum2 = item.datum, orient2 = item.orient, bounds2 = item.bounds, x2 = item.x, y2 = item.y, w4, h2;
  item._bounds ? item._bounds.clear().union(bounds2) : item._bounds = bounds2.clone();
  bounds2.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds2 = legendBounds(item, bounds2);
  w4 = 2 * item.padding;
  h2 = 2 * item.padding;
  if (!bounds2.empty()) {
    w4 = Math.ceil(bounds2.width() + w4);
    h2 = Math.ceil(bounds2.height() + h2);
  }
  if (datum2.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient2 !== None3) {
    item.x = x2 = 0;
    item.y = y2 = 0;
  }
  item.width = w4;
  item.height = h2;
  boundStroke(bounds2.set(x2, y2, x2 + w4, y2 + h2), item);
  item.mark.bounds.clear().union(bounds2);
  return item;
}
function legendBounds(item, b2) {
  item.items.forEach((_) => b2.union(_.bounds));
  b2.x1 = item.padding;
  b2.y1 = item.padding;
  return b2;
}
function legendGroupLayout(view, item, entry2) {
  var pad2 = item.padding, ex = pad2 - entry2.x, ey = pad2 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey) translate2(view, entry2, ex, ey);
  } else {
    var title2 = item.items[1].items[0], anchor = title2.anchor, tpad = item.titlePadding || 0, tx = pad2 - title2.x, ty = pad2 - title2.y;
    switch (title2.orient) {
      case Left:
        ex += Math.ceil(title2.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title2.bounds.height() + tpad;
    }
    if (ex || ey) translate2(view, entry2, ex, ey);
    switch (title2.orient) {
      case Left:
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry2, title2, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title2, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
    }
    if (tx || ty) translate2(view, title2, tx, ty);
    if ((tx = Math.round(title2.bounds.x1 - pad2)) < 0) {
      translate2(view, entry2, -tx, 0);
      translate2(view, title2, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title2, anchor, y2, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title2.datum.vgrad, e2 = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s = e2.bounds[y2 ? "y2" : "x2"] - item.padding, u = vgrad && lr ? s : 0, v = vgrad && lr ? 0 : s, o = y2 <= 0 ? 0 : multiLineOffset(title2);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}
function translate2(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries3) {
  const widths = entries3.reduce((w4, g) => {
    w4[g.column] = Math.max(g.bounds.x2 - g.x, w4[g.column] || 0);
    return w4;
  }, {});
  entries3.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark2, width2, height2, viewBounds2) {
  var group2 = mark2.items[0], frame = group2.frame, orient2 = group2.orient, anchor = group2.anchor, offset4 = group2.offset, padding3 = group2.padding, title2 = group2.items[0].items[0], subtitle = group2.items[1] && group2.items[1].items[0], end = orient2 === Left || orient2 === Right ? height2 : width2, start = 0, x2 = 0, y2 = 0, sx = 0, sy = 0, pos;
  if (frame !== Group) {
    orient2 === Left ? (start = viewBounds2.y2, end = viewBounds2.y1) : orient2 === Right ? (start = viewBounds2.y1, end = viewBounds2.y2) : (start = viewBounds2.x1, end = viewBounds2.x2);
  } else if (orient2 === Left) {
    start = height2, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient2) {
      case Top:
      case Bottom:
        sy = title2.bounds.height() + padding3;
        break;
      case Left:
        sx = title2.bounds.width() + padding3;
        break;
      case Right:
        sx = -title2.bounds.width() - padding3;
        break;
    }
    tempBounds2.clear().union(subtitle.bounds);
    tempBounds2.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set2(subtitle, "x", sx) | set2(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds2);
      subtitle.mark.bounds.clear().union(tempBounds2);
      view.dirty(subtitle);
    }
    tempBounds2.clear().union(subtitle.bounds);
  } else {
    tempBounds2.clear();
  }
  tempBounds2.union(title2.bounds);
  switch (orient2) {
    case Top:
      x2 = pos;
      y2 = viewBounds2.y1 - tempBounds2.height() - offset4;
      break;
    case Left:
      x2 = viewBounds2.x1 - tempBounds2.width() - offset4;
      y2 = pos;
      break;
    case Right:
      x2 = viewBounds2.x2 + tempBounds2.width() + offset4;
      y2 = pos;
      break;
    case Bottom:
      x2 = pos;
      y2 = viewBounds2.y2 + offset4;
      break;
    default:
      x2 = group2.x;
      y2 = group2.y;
  }
  if (set2(group2, "x", x2) | set2(group2, "y", y2)) {
    tempBounds2.translate(x2, y2);
    view.dirty(group2);
    group2.bounds.clear().union(tempBounds2);
    mark2.bounds.clear().union(tempBounds2);
    view.dirty(group2);
  }
  return group2.bounds;
}
function ViewLayout(params2) {
  Transform.call(this, null, params2);
}
inherits(ViewLayout, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    _.mark.items.forEach((group2) => {
      if (_.layout) trellisLayout(view, group2, _.layout);
      layoutGroup(view, group2, _);
    });
    return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
  }
});
function shouldReflow(group2) {
  return group2 && group2.mark.role !== "legend-entry";
}
function layoutGroup(view, group2, _) {
  var items = group2.items, width2 = Math.max(0, group2.width || 0), height2 = Math.max(0, group2.height || 0), viewBounds2 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds2.clone(), yBounds = viewBounds2.clone(), legends = [], title2, mark2, orient2, b2, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    mark2 = items[i];
    switch (mark2.role) {
      case AxisRole:
        b2 = isYAxis(mark2) ? xBounds : yBounds;
        b2.union(axisLayout(view, mark2, width2, height2));
        break;
      case TitleRole:
        title2 = mark2;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark2));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark2.bounds);
        yBounds.union(mark2.bounds);
        break;
      default:
        viewBounds2.union(mark2.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient2 = item.orient || Right;
      if (orient2 !== None3) (l[orient2] || (l[orient2] = [])).push(item);
    });
    for (const orient3 in l) {
      const g = l[orient3];
      gridLayout(view, g, legendParams(g, orient3, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b3 = item.bounds;
      if (!b3.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b3;
        view.dirty(item);
      }
      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds2.add(b3.x1, 0).add(b3.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds2.add(0, b3.y1).add(0, b3.y2);
        }
      } else {
        viewBounds2.union(b3);
      }
    });
  }
  viewBounds2.union(xBounds).union(yBounds);
  if (title2) {
    viewBounds2.union(titleLayout(view, title2, width2, height2, viewBounds2));
  }
  if (group2.clip) {
    viewBounds2.set(0, 0, group2.width || 0, group2.height || 0);
  }
  viewSizeLayout(view, group2, viewBounds2, _);
}
function viewSizeLayout(view, group2, viewBounds2, _) {
  const auto = _.autosize || {}, type3 = auto.type;
  if (view._autosize < 1 || !type3) return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group2.width || 0), left = Math.max(0, Math.ceil(-viewBounds2.x1)), height2 = Math.max(0, group2.height || 0), top = Math.max(0, Math.ceil(-viewBounds2.y1));
  const right = Math.max(0, Math.ceil(viewBounds2.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds2.y2 - height2));
  if (auto.contains === Padding) {
    const padding3 = view.padding();
    viewWidth2 -= padding3.left + padding3.right;
    viewHeight2 -= padding3.top + padding3.bottom;
  }
  if (type3 === None3) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type3 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type3 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type3 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type3 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}

// node_modules/vega-encode/build/vega-encode.module.js
var vega_encode_module_exports = {};
__export(vega_encode_module_exports, {
  axisticks: () => AxisTicks,
  datajoin: () => DataJoin,
  encode: () => Encode,
  legendentries: () => LegendEntries,
  linkpath: () => LinkPath,
  pie: () => Pie,
  scale: () => Scale,
  sortitems: () => SortItems,
  stack: () => Stack
});
function AxisTicks(params2) {
  Transform.call(this, null, params2);
}
inherits(AxisTicks, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks = this.value, scale6 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count = tickCount(scale6, tally, _.minstep), format5 = _.format || tickFormat2(locale2, scale6, count, _.formatSpecifier, _.formatType, !!_.values), values5 = _.values ? validTicks(scale6, _.values, count) : tickValues(scale6, count);
    if (ticks) out.rem = ticks;
    ticks = values5.map((value3, i) => ingest$1({
      index: i / (values5.length - 1 || 1),
      value: value3,
      label: format5(value3)
    }));
    if (_.extra && ticks.length) {
      ticks.push(ingest$1({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ""
      }));
    }
    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }
});
function DataJoin(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest$1({});
}
function newMap(key2) {
  const map2 = fastmap().test((t2) => t2.exit);
  map2.lookup = (t2) => map2.get(key2(t2));
  return map2;
}
inherits(DataJoin, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key2 = _.key || tupleid, map2 = this.value;
    if (isArray(out.encode)) {
      out.encode = null;
    }
    if (map2 && (_.modified("key") || pulse2.modified(key2))) {
      error("DataJoin does not support modified key function or fields.");
    }
    if (!map2) {
      pulse2 = pulse2.addAll();
      this.value = map2 = newMap(key2);
    }
    pulse2.visit(pulse2.ADD, (t2) => {
      const k2 = key2(t2);
      let x2 = map2.get(k2);
      if (x2) {
        if (x2.exit) {
          map2.empty--;
          out.add.push(x2);
        } else {
          out.mod.push(x2);
        }
      } else {
        x2 = item(t2);
        map2.set(k2, x2);
        out.add.push(x2);
      }
      x2.datum = t2;
      x2.exit = false;
    });
    pulse2.visit(pulse2.MOD, (t2) => {
      const k2 = key2(t2), x2 = map2.get(k2);
      if (x2) {
        x2.datum = t2;
        out.mod.push(x2);
      }
    });
    pulse2.visit(pulse2.REM, (t2) => {
      const k2 = key2(t2), x2 = map2.get(k2);
      if (t2 === x2.datum && !x2.exit) {
        out.rem.push(x2);
        x2.exit = true;
        ++map2.empty;
      }
    });
    if (pulse2.changed(pulse2.ADD_MOD)) out.modifies("datum");
    if (pulse2.clean() || _.clean && map2.empty > df.cleanThreshold) {
      df.runAfter(map2.clean);
    }
    return out;
  }
});
function Encode(params2) {
  Transform.call(this, null, params2);
}
inherits(Encode, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
    if (isArray(encode2)) {
      if (out.changed() || encode2.every((e2) => encoders[e2])) {
        encode2 = encode2[0];
        out.encode = null;
      } else {
        return pulse2.StopPropagation;
      }
    }
    var reenter = encode2 === "enter", update3 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set5 = (encode2 && !reenter ? encoders[encode2] : update3) || falsy;
    if (pulse2.changed(pulse2.ADD)) {
      pulse2.visit(pulse2.ADD, (t2) => {
        enter(t2, _);
        update3(t2, _);
      });
      out.modifies(enter.output);
      out.modifies(update3.output);
      if (set5 !== falsy && set5 !== update3) {
        pulse2.visit(pulse2.ADD, (t2) => {
          set5(t2, _);
        });
        out.modifies(set5.output);
      }
    }
    if (pulse2.changed(pulse2.REM) && exit !== falsy) {
      pulse2.visit(pulse2.REM, (t2) => {
        exit(t2, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set5 !== falsy) {
      const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
      if (reenter) {
        pulse2.visit(flag2, (t2) => {
          const mod = enter(t2, _) || fmod;
          if (set5(t2, _) || mod) out.mod.push(t2);
        });
        if (out.mod.length) out.modifies(enter.output);
      } else {
        pulse2.visit(flag2, (t2) => {
          if (set5(t2, _) || fmod) out.mod.push(t2);
        });
      }
      if (out.mod.length) out.modifies(set5.output);
    }
    return out.changed() ? out : pulse2.StopPropagation;
  }
});
function LegendEntries(params2) {
  Transform.call(this, [], params2);
}
inherits(LegendEntries, Transform, {
  transform(_, pulse2) {
    if (this.value != null && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items = this.value, type3 = _.type || SymbolLegend, scale6 = _.scale, limit = +_.limit, count = tickCount(scale6, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type3 === SymbolLegend, format5 = _.format || labelFormat(locale2, scale6, count, type3, _.formatSpecifier, _.formatType, lskip), values5 = _.values || labelValues(scale6, count), domain4, fraction, size, offset4, ellipsis;
    if (items) out.rem = items;
    if (type3 === SymbolLegend) {
      if (limit && values5.length > limit) {
        pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
        items = values5.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values5;
      }
      if (isFunction(size = _.size)) {
        if (!_.values && scale6(items[0]) === 0) {
          items = items.slice(1);
        }
        offset4 = items.reduce((max4, value3) => Math.max(max4, size(value3, _)), 0);
      } else {
        size = constant(offset4 = size || 8);
      }
      items = items.map((value3, index3) => ingest$1({
        index: index3,
        label: format5(value3, index3, items),
        value: value3,
        offset: offset4,
        size: size(value3, _)
      }));
      if (ellipsis) {
        ellipsis = values5[items.length];
        items.push(ingest$1({
          index: items.length,
          label: `…${values5.length - items.length} entries`,
          value: ellipsis,
          offset: offset4,
          size: size(ellipsis, _)
        }));
      }
    } else if (type3 === GradientLegend) {
      domain4 = scale6.domain(), fraction = scaleFraction(scale6, domain4[0], peek(domain4));
      if (values5.length < 3 && !_.values && domain4[0] !== peek(domain4)) {
        values5 = [domain4[0], peek(domain4)];
      }
      items = values5.map((value3, index3) => ingest$1({
        index: index3,
        label: format5(value3, index3, values5),
        value: value3,
        perc: fraction(value3)
      }));
    } else {
      size = values5.length - 1;
      fraction = labelFraction(scale6);
      items = values5.map((value3, index3) => ingest$1({
        index: index3,
        label: format5(value3, index3, values5),
        value: value3,
        perc: index3 ? fraction(value3) : 0,
        perc2: index3 === size ? 1 : fraction(values5[index3 + 1])
      }));
    }
    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }
});
var sourceX = (t2) => t2.source.x;
var sourceY = (t2) => t2.source.y;
var targetX = (t2) => t2.target.x;
var targetY = (t2) => t2.target.y;
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
LinkPath.Definition = {
  "type": "LinkPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sourceX",
    "type": "field",
    "default": "source.x"
  }, {
    "name": "sourceY",
    "type": "field",
    "default": "source.y"
  }, {
    "name": "targetX",
    "type": "field",
    "default": "target.x"
  }, {
    "name": "targetY",
    "type": "field",
    "default": "target.y"
  }, {
    "name": "orient",
    "type": "enum",
    "default": "vertical",
    "values": ["horizontal", "vertical", "radial"]
  }, {
    "name": "shape",
    "type": "enum",
    "default": "line",
    "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    "name": "require",
    "type": "signal"
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(LinkPath, Transform, {
  transform(_, pulse2) {
    var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient2 = _.orient || "vertical", shape2 = _.shape || "line", path3 = Paths.get(shape2 + "-" + orient2) || Paths.get(shape2);
    if (!path3) {
      error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
    }
    pulse2.visit(pulse2.SOURCE, (t2) => {
      t2[as] = path3(sx(t2), sy(t2), tx(t2), ty(t2));
    });
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var line2 = (sx, sy, tx, ty) => "M" + sx + "," + sy + "L" + tx + "," + ty;
var lineR = (sa2, sr, ta, tr2) => line2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var arc2 = (sx, sy, tx, ty) => {
  var dx = tx - sx, dy = ty - sy, rr = Math.hypot(dx, dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx + "," + ty;
};
var arcR = (sa2, sr, ta, tr2) => arc2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var curve = (sx, sy, tx, ty) => {
  const dx = tx - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
  return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx + iy) + "," + (ty - ix) + " " + tx + "," + ty;
};
var curveR = (sa2, sr, ta, tr2) => curve(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var orthoX = (sx, sy, tx, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx;
var orthoY = (sx, sy, tx, ty) => "M" + sx + "," + sy + "H" + tx + "V" + ty;
var orthoR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), sf = Math.abs(ta - sa2) > Math.PI ? ta <= sa2 : ta > sa2;
  return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts2 + "L" + tr2 * tc + "," + tr2 * ts2;
};
var diagonalX = (sx, sy, tx, ty) => {
  const m = (sx + tx) / 2;
  return "M" + sx + "," + sy + "C" + m + "," + sy + " " + m + "," + ty + " " + tx + "," + ty;
};
var diagonalY = (sx, sy, tx, ty) => {
  const m = (sy + ty) / 2;
  return "M" + sx + "," + sy + "C" + sx + "," + m + " " + tx + "," + m + " " + tx + "," + ty;
};
var diagonalR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), mr = (sr + tr2) / 2;
  return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts2 + " " + tr2 * tc + "," + tr2 * ts2;
};
var Paths = fastmap({
  "line": line2,
  "line-radial": lineR,
  "arc": arc2,
  "arc-radial": arcR,
  "curve": curve,
  "curve-radial": curveR,
  "orthogonal-horizontal": orthoX,
  "orthogonal-vertical": orthoY,
  "orthogonal-radial": orthoR,
  "diagonal-horizontal": diagonalX,
  "diagonal-vertical": diagonalY,
  "diagonal-radial": diagonalR
});
function Pie(params2) {
  Transform.call(this, null, params2);
}
Pie.Definition = {
  "type": "Pie",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "startAngle",
    "type": "number",
    "default": 0
  }, {
    "name": "endAngle",
    "type": "number",
    "default": 6.283185307179586
  }, {
    "name": "sort",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["startAngle", "endAngle"]
  }]
};
inherits(Pie, Transform, {
  transform(_, pulse2) {
    var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field3 = _.field || one, start = _.startAngle || 0, stop3 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data3 = pulse2.source, values5 = data3.map(field3), n = values5.length, a = start, k2 = (stop3 - start) / sum(values5), index3 = range(n), i, t2, v;
    if (_.sort) {
      index3.sort((a2, b2) => values5[a2] - values5[b2]);
    }
    for (i = 0; i < n; ++i) {
      v = values5[index3[i]];
      t2 = data3[index3[i]];
      t2[startAngle] = a;
      t2[endAngle] = a += v * k2;
    }
    this.value = values5;
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var DEFAULT_COUNT = 5;
function includeZero(scale6) {
  const type3 = scale6.type;
  return !scale6.bins && (type3 === Linear || type3 === Pow || type3 === Sqrt);
}
function includePad(type3) {
  return isContinuous(type3) && type3 !== Sequential;
}
var SKIP2 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function Scale(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Scale, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, scale$12 = this.value, key2 = scaleKey(_);
    if (!scale$12 || key2 !== scale$12.type) {
      this.value = scale$12 = scale(key2)();
    }
    for (key2 in _) if (!SKIP2[key2]) {
      if (key2 === "padding" && includePad(scale$12.type)) continue;
      isFunction(scale$12[key2]) ? scale$12[key2](_[key2]) : df.warn("Unsupported scale property: " + key2);
    }
    configureRange(scale$12, _, configureBins(scale$12, _, configureDomain(scale$12, _, df)));
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t2 = _.type, d = "", n;
  if (t2 === Sequential) return Sequential + "-" + Linear;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential + "-" : n === 3 ? Diverging + "-" : "";
  }
  return (d + t2 || Linear).toLowerCase();
}
function isContinuousColor(_) {
  const t2 = _.type;
  return isContinuous(t2) && t2 !== Time && t2 !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));
}
function configureDomain(scale6, _, df) {
  const raw = rawDomain(scale6, _.domainRaw, df);
  if (raw > -1) return raw;
  var domain4 = _.domain, type3 = scale6.type, zero4 = _.zero || _.zero === void 0 && includeZero(scale6), n, mid;
  if (!domain4) return 0;
  if (zero4 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain4 = domain4.slice()).length - 1 || 1;
    if (zero4) {
      if (domain4[0] > 0) domain4[0] = 0;
      if (domain4[n] < 0) domain4[n] = 0;
    }
    if (_.domainMin != null) domain4[0] = _.domainMin;
    if (_.domainMax != null) domain4[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain4[n] ? n + 1 : mid < domain4[0] ? 0 : n;
      if (i !== n) df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain4.splice(i, 0, mid);
    }
  }
  if (includePad(type3) && _.padding && domain4[0] !== peek(domain4)) {
    domain4 = padDomain(type3, domain4, _.range, _.padding, _.exponent, _.constant);
  }
  scale6.domain(domainCheck(type3, domain4, df));
  if (type3 === Ordinal) {
    scale6.unknown(_.domainImplicit ? implicit : void 0);
  }
  if (_.nice && scale6.nice) {
    scale6.nice(_.nice !== true && tickCount(scale6, _.nice) || null);
  }
  return domain4.length;
}
function rawDomain(scale6, raw, df) {
  if (raw) {
    scale6.domain(domainCheck(scale6.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type3, domain4, range6, pad2, exponent, constant3) {
  var span2 = Math.abs(peek(range6) - range6[0]), frac = span2 / (span2 - 2 * pad2), d = type3 === Log ? zoomLog(domain4, null, frac) : type3 === Sqrt ? zoomPow(domain4, null, frac, 0.5) : type3 === Pow ? zoomPow(domain4, null, frac, exponent || 1) : type3 === Symlog ? zoomSymlog(domain4, null, frac, constant3 || 1) : zoomLinear(domain4, null, frac);
  domain4 = domain4.slice();
  domain4[0] = d[0];
  domain4[domain4.length - 1] = d[1];
  return domain4;
}
function domainCheck(type3, domain4, df) {
  if (isLogarithmic(type3)) {
    var s = Math.abs(domain4.reduce((s2, v) => s2 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s !== domain4.length) {
      df.warn("Log scale domain includes zero: " + $(domain4));
    }
  }
  return domain4;
}
function configureBins(scale6, _, count) {
  let bins2 = _.bins;
  if (bins2 && !isArray(bins2)) {
    const domain4 = scale6.domain(), lo = domain4[0], hi = peek(domain4), step = bins2.step;
    let start = bins2.start == null ? lo : bins2.start, stop3 = bins2.stop == null ? hi : bins2.stop;
    if (!step) error("Scale bins parameter missing step property.");
    if (start < lo) start = step * Math.ceil(lo / step);
    if (stop3 > hi) stop3 = step * Math.floor(hi / step);
    bins2 = range(start, stop3 + step / 2, step);
  }
  if (bins2) {
    scale6.bins = bins2;
  } else if (scale6.bins) {
    delete scale6.bins;
  }
  if (scale6.type === BinOrdinal) {
    if (!bins2) {
      scale6.bins = scale6.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale6.domain(bins2);
      count = bins2.length;
    }
  }
  return count;
}
function configureRange(scale6, _, count) {
  var type3 = scale6.type, round2 = _.round || false, range6 = _.range;
  if (_.rangeStep != null) {
    range6 = configureRangeStep(type3, _, count);
  } else if (_.scheme) {
    range6 = configureScheme(type3, _, count);
    if (isFunction(range6)) {
      if (scale6.interpolator) {
        return scale6.interpolator(range6);
      } else {
        error(`Scale type ${type3} does not support interpolating color schemes.`);
      }
    }
  }
  if (range6 && isInterpolating(type3)) {
    return scale6.interpolator(interpolateColors(flip(range6, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range6 && _.interpolate && scale6.interpolate) {
    scale6.interpolate(interpolate(_.interpolate, _.interpolateGamma));
  } else if (isFunction(scale6.round)) {
    scale6.round(round2);
  } else if (isFunction(scale6.rangeRound)) {
    scale6.interpolate(round2 ? round_default : value_default);
  }
  if (range6) scale6.range(flip(range6, _.reverse));
}
function configureRangeStep(type3, _, count) {
  if (type3 !== Band && type3 !== Point) {
    error("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type3 === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace(count, inner, outer)];
}
function configureScheme(type3, _, count) {
  var extent2 = _.schemeExtent, name4, scheme$1;
  if (isArray(_.scheme)) {
    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name4 = _.scheme.toLowerCase();
    scheme$1 = scheme(name4);
    if (!scheme$1) error(`Unrecognized scheme name: ${_.scheme}`);
  }
  count = type3 === Threshold ? count + 1 : type3 === BinOrdinal ? count - 1 : type3 === Quantile2 || type3 === Quantize ? +_.schemeCount || DEFAULT_COUNT : count;
  return isInterpolating(type3) ? adjustScheme(scheme$1, extent2, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent2), count) : type3 === Ordinal ? scheme$1 : scheme$1.slice(0, count);
}
function adjustScheme(scheme3, extent2, reverse3) {
  return isFunction(scheme3) && (extent2 || reverse3) ? interpolateRange(scheme3, flip(extent2 || [0, 1], reverse3)) : scheme3;
}
function flip(array4, reverse3) {
  return reverse3 ? array4.slice().reverse() : array4;
}
function SortItems(params2) {
  Transform.call(this, null, params2);
}
inherits(SortItems, Transform, {
  transform(_, pulse2) {
    const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
    if (mod) pulse2.source.sort(stableCompare(_.sort));
    this.modified(mod);
    return pulse2;
  }
});
var Zero = "zero";
var Center = "center";
var Normalize = "normalize";
var DefOutput = ["y0", "y1"];
function Stack(params2) {
  Transform.call(this, null, params2);
}
Stack.Definition = {
  "type": "Stack",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "offset",
    "type": "enum",
    "default": Zero,
    "values": [Zero, Center, Normalize]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": DefOutput
  }]
};
inherits(Stack, Transform, {
  transform(_, pulse2) {
    var as = _.as || DefOutput, y02 = as[0], y12 = as[1], sort3 = stableCompare(_.sort), field3 = _.field || one, stack2 = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups, i, n, max4;
    groups = partition2(pulse2.source, _.groupby, sort3, field3);
    for (i = 0, n = groups.length, max4 = groups.max; i < n; ++i) {
      stack2(groups[i], max4, field3, y02, y12);
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group2, max4, field3, y02, y12) {
  var last = (max4 - group2.sum) / 2, m = group2.length, j = 0, t2;
  for (; j < m; ++j) {
    t2 = group2[j];
    t2[y02] = last;
    t2[y12] = last += Math.abs(field3(t2));
  }
}
function stackNormalize(group2, max4, field3, y02, y12) {
  var scale6 = 1 / group2.sum, last = 0, m = group2.length, j = 0, v = 0, t2;
  for (; j < m; ++j) {
    t2 = group2[j];
    t2[y02] = last;
    t2[y12] = last = scale6 * (v += Math.abs(field3(t2)));
  }
}
function stackZero(group2, max4, field3, y02, y12) {
  var lastPos = 0, lastNeg = 0, m = group2.length, j = 0, v, t2;
  for (; j < m; ++j) {
    t2 = group2[j];
    v = +field3(t2);
    if (v < 0) {
      t2[y02] = lastNeg;
      t2[y12] = lastNeg += v;
    } else {
      t2[y02] = lastPos;
      t2[y12] = lastPos += v;
    }
  }
}
function partition2(data3, groupby, sort3, field3) {
  var groups = [], get6 = (f) => f(t2), map2, i, n, m, t2, k2, g, s, max4;
  if (groupby == null) {
    groups.push(data3.slice());
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t2 = data3[i];
      k2 = groupby.map(get6);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        groups.push(g);
      }
      g.push(t2);
    }
  }
  for (k2 = 0, max4 = 0, m = groups.length; k2 < m; ++k2) {
    g = groups[k2];
    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field3(g[i]));
    }
    g.sum = s;
    if (s > max4) max4 = s;
    if (sort3) g.sort(sort3);
  }
  groups.max = max4;
  return groups;
}

// node_modules/vega-geo/build/vega-geo.module.js
var vega_geo_module_exports = {};
__export(vega_geo_module_exports, {
  contour: () => Contour,
  geojson: () => GeoJSON,
  geopath: () => GeoPath,
  geopoint: () => GeoPoint,
  geoshape: () => GeoShape,
  graticule: () => Graticule,
  heatmap: () => Heatmap,
  isocontour: () => Isocontour,
  kde2d: () => KDE2D,
  projection: () => Projection
});

// node_modules/d3-geo-projection/src/math.js
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp3 = Math.exp;
var floor2 = Math.floor;
var log4 = Math.log;
var max3 = Math.max;
var min3 = Math.min;
var pow4 = Math.pow;
var sign = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sin = Math.sin;
var tan = Math.tan;
var epsilon2 = 1e-6;
var epsilon22 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt3(2);
var sqrtPi = sqrt3(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
function sinci(x2) {
  return x2 ? x2 / Math.sin(x2) : 1;
}
function asin(x2) {
  return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
}
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function sqrt3(x2) {
  return x2 > 0 ? Math.sqrt(x2) : 0;
}
function tanh(x2) {
  x2 = exp3(2 * x2);
  return (x2 - 1) / (x2 + 1);
}
function sinh(x2) {
  return (exp3(x2) - exp3(-x2)) / 2;
}
function cosh(x2) {
  return (exp3(x2) + exp3(-x2)) / 2;
}
function arsinh(x2) {
  return log4(x2 + sqrt3(x2 * x2 + 1));
}
function arcosh(x2) {
  return log4(x2 + sqrt3(x2 * x2 - 1));
}

// node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x2, y2) {
  var cosy = cos(y2), sincia = sinci(acos(cosy * cos(x2 /= 2)));
  return [2 * cosy * sin(x2) * sincia, sin(y2) * sincia];
}
aitoffRaw.invert = function(x2, y2) {
  if (x2 * x2 + 4 * y2 * y2 > pi * pi + epsilon2) return;
  var x12 = x2, y12 = y2, i = 25;
  do {
    var sinx = sin(x12), sinx_2 = sin(x12 / 2), cosx_2 = cos(x12 / 2), siny = sin(y12), cosy = cos(y12), sin_2y = sin(2 * y12), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e2 = c ? acos(cosy * cosx_2) * sqrt3(f = 1 / c) : f = 0, f, fx = 2 * e2 * cosy * sinx_2 - x2, fy = e2 * siny - y2, dxdx = f * (cos2y * sin2x_2 + e2 * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e2 * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e2 * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e2 * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
    if (!z) break;
    var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
    x12 -= dx, y12 -= dy;
  } while ((abs(dx) > epsilon2 || abs(dy) > epsilon2) && --i > 0);
  return [x12, y12];
};

// node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi) {
  var tanPhi = tan(phi / 2), k2 = sqrt3(1 - tanPhi * tanPhi), c = 1 + k2 * cos(lambda /= 2), x2 = sin(lambda) * k2 / c, y2 = tanPhi / c, x22 = x2 * x2, y22 = y2 * y2;
  return [
    4 / 3 * x2 * (3 + x22 - 3 * y22),
    4 / 3 * y2 * (3 + 3 * x22 - y22)
  ];
}
augustRaw.invert = function(x2, y2) {
  x2 *= 3 / 8, y2 *= 3 / 8;
  if (!x2 && abs(y2) > 1) return null;
  var x22 = x2 * x2, y22 = y2 * y2, s = 1 + x22 + y22, sin3Eta = sqrt3((s - sqrt3(s * s - 4 * y2 * y2)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y2 / sin3Eta)) / 3 : arsinh(abs(x2)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;
  return [
    sign(x2) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),
    sign(y2) * 2 * atan2(coshXi * sin(eta), 0.25 + d)
  ];
};

// node_modules/d3-geo-projection/src/baker.js
var sqrt8 = sqrt3(8);
var phi0 = log4(1 + sqrt2);
function bakerRaw(lambda, phi) {
  var phi02 = abs(phi);
  return phi02 < quarterPi ? [lambda, log4(tan(quarterPi + phi / 2))] : [lambda * cos(phi02) * (2 * sqrt2 - 1 / sin(phi02)), sign(phi) * (2 * sqrt2 * (phi02 - quarterPi) - log4(tan(phi02 / 2)))];
}
bakerRaw.invert = function(x2, y2) {
  if ((y02 = abs(y2)) < phi0) return [x2, 2 * atan(exp3(y2)) - halfPi];
  var phi = quarterPi, i = 25, delta, y02;
  do {
    var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);
    phi -= delta = (sqrt8 * (phi - quarterPi) - log4(tanPhi_2) - y02) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (abs(delta) > epsilon22 && --i > 0);
  return [x2 / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y2) * phi];
};

// node_modules/d3-geo-projection/src/hammer.js
function hammerQuarticAuthalicRaw(lambda, phi) {
  return [
    lambda * cos(phi) / cos(phi /= 2),
    2 * sin(phi)
  ];
}
hammerQuarticAuthalicRaw.invert = function(x2, y2) {
  var phi = 2 * asin(y2 / 2);
  return [
    x2 * cos(phi / 2) / cos(phi),
    phi
  ];
};

// node_modules/d3-geo-projection/src/newton.js
function solve(f, y2, x2) {
  var steps = 100, delta, f0, f1;
  x2 = x2 === void 0 ? 0 : +x2;
  y2 = +y2;
  do {
    f0 = f(x2);
    f1 = f(x2 + epsilon2);
    if (f0 === f1) f1 = f0 + epsilon2;
    x2 -= delta = -1 * epsilon2 * (f0 - y2) / (f0 - f1);
  } while (steps-- > 0 && abs(delta) > epsilon2);
  return steps < 0 ? NaN : x2;
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * sin(phi), i = 30, delta;
  do
    phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));
  while (abs(delta) > epsilon2 && --i > 0);
  return phi / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi) {
    return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];
  }
  forward.invert = function(x2, y2) {
    return y2 = asin(y2 / cy), [x2 / (cx * cos(y2)), asin((2 * y2 + sin(2 * y2)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}

// node_modules/d3-geo-projection/src/boggs.js
var k = 2.00276;
var w2 = 1.11072;
function boggsRaw(lambda, phi) {
  var theta = mollweideBromleyTheta(pi, phi);
  return [k * lambda / (1 / cos(phi) + w2 / cos(theta)), (phi + sqrt2 * sin(theta)) / k];
}
boggsRaw.invert = function(x2, y2) {
  var ky = k * y2, theta = y2 < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;
  do {
    phi = ky - sqrt2 * sin(theta);
    theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));
  } while (abs(delta) > epsilon2 && --i > 0);
  phi = ky - sqrt2 * sin(theta);
  return [x2 * (1 / cos(phi) + w2 / cos(theta)) / k, phi];
};

// node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi) {
  return [lambda * cos(phi), phi];
}
sinusoidalRaw.invert = function(x2, y2) {
  return [x2 / cos(y2), y2];
};

// node_modules/d3-geo-projection/src/bromley.js
var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);

// node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi) {
  var alpha = sqrt3(1 - sin(phi));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
collignonRaw.invert = function(x2, y2) {
  var lambda = (lambda = y2 / sqrtPi - 1) * lambda;
  return [lambda > 0 ? x2 * sqrt3(pi / lambda) / 2 : 0, asin(1 - lambda)];
};

// node_modules/d3-geo-projection/src/craster.js
var sqrt32 = sqrt3(3);
function crasterRaw(lambda, phi) {
  return [sqrt32 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt32 * sqrtPi * sin(phi / 3)];
}
crasterRaw.invert = function(x2, y2) {
  var phi = 3 * asin(y2 / (sqrt32 * sqrtPi));
  return [sqrtPi * x2 / (sqrt32 * (2 * cos(2 * phi / 3) - 1)), phi];
};

// node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi0 = cos(phi02);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi0, asin(y2 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi) {
  var alpha = sqrt3(8 / (3 * pi));
  return [
    alpha * lambda * (1 - abs(phi) / pi),
    alpha * phi
  ];
}
eckert1Raw.invert = function(x2, y2) {
  var alpha = sqrt3(8 / (3 * pi)), phi = y2 / alpha;
  return [
    x2 / (alpha * (1 - abs(phi) / pi)),
    phi
  ];
};

// node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi) {
  var alpha = sqrt3(4 - 3 * sin(abs(phi)));
  return [
    2 / sqrt3(6 * pi) * lambda * alpha,
    sign(phi) * sqrt3(2 * pi / 3) * (2 - alpha)
  ];
}
eckert2Raw.invert = function(x2, y2) {
  var alpha = 2 - abs(y2) / sqrt3(2 * pi / 3);
  return [
    x2 * sqrt3(6 * pi) / (2 * alpha),
    sign(y2) * asin((4 - alpha * alpha) / 3)
  ];
};

// node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi) {
  var k2 = sqrt3(pi * (4 + pi));
  return [
    2 / k2 * lambda * (1 + sqrt3(1 - 4 * phi * phi / (pi * pi))),
    4 / k2 * phi
  ];
}
eckert3Raw.invert = function(x2, y2) {
  var k2 = sqrt3(pi * (4 + pi)) / 2;
  return [
    x2 * k2 / (1 + sqrt3(1 - y2 * y2 * (4 + pi) / (4 * pi))),
    y2 * k2 / 2
  ];
};

// node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi) {
  var k2 = (2 + halfPi) * sin(phi);
  phi /= 2;
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon2; i++) {
    var cosPhi = cos(phi);
    phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k2) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt3(pi * (4 + pi)) * lambda * (1 + cos(phi)),
    2 * sqrt3(pi / (4 + pi)) * sin(phi)
  ];
}
eckert4Raw.invert = function(x2, y2) {
  var A2 = y2 * sqrt3((4 + pi) / pi) / 2, k2 = asin(A2), c = cos(k2);
  return [
    x2 / (2 / sqrt3(pi * (4 + pi)) * (1 + c)),
    asin((k2 + A2 * (c + 2)) / (2 + halfPi))
  ];
};

// node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi) {
  return [
    lambda * (1 + cos(phi)) / sqrt3(2 + pi),
    2 * phi / sqrt3(2 + pi)
  ];
}
eckert5Raw.invert = function(x2, y2) {
  var k2 = sqrt3(2 + pi), phi = y2 * k2 / 2;
  return [
    k2 * x2 / (1 + cos(phi)),
    phi
  ];
};

// node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi) {
  var k2 = (1 + halfPi) * sin(phi);
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon2; i++) {
    phi -= delta = (phi + sin(phi) - k2) / (1 + cos(phi));
  }
  k2 = sqrt3(2 + pi);
  return [
    lambda * (1 + cos(phi)) / k2,
    2 * phi / k2
  ];
}
eckert6Raw.invert = function(x2, y2) {
  var j = 1 + halfPi, k2 = sqrt3(j / 2);
  return [
    x2 * 2 * k2 / (1 + cos(y2 *= k2)),
    asin((y2 + sin(y2)) / j)
  ];
};

// node_modules/d3-geo-projection/src/eisenlohr.js
var eisenlohrK = 3 + 2 * sqrt2;
function eisenlohrRaw(lambda, phi) {
  var s0 = sin(lambda /= 2), c0 = cos(lambda), k2 = sqrt3(cos(phi)), c1 = cos(phi /= 2), t2 = sin(phi) / (c1 + sqrt2 * c0 * k2), c = sqrt3(2 / (1 + t2 * t2)), v = sqrt3((sqrt2 * c1 + (c0 + s0) * k2) / (sqrt2 * c1 + (c0 - s0) * k2));
  return [
    eisenlohrK * (c * (v - 1 / v) - 2 * log4(v)),
    eisenlohrK * (c * t2 * (v + 1 / v) - 2 * atan(t2))
  ];
}
eisenlohrRaw.invert = function(x2, y2) {
  if (!(p = augustRaw.invert(x2 / 1.2, y2 * 1.065))) return null;
  var lambda = p[0], phi = p[1], i = 20, p;
  x2 /= eisenlohrK, y2 /= eisenlohrK;
  do {
    var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k2 = sqrt3(cos1), t2 = s1 / (c1 + sqrt2 * c0 * k2), t22 = t2 * t2, c = sqrt3(2 / (1 + t22)), v0 = sqrt2 * c1 + (c0 + s0) * k2, v1 = sqrt2 * c1 + (c0 - s0) * k2, v2 = v0 / v1, v = sqrt3(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log4(v) - x2, fy = c * t2 * vp1v - 2 * atan(t2) - y2, deltatDeltaLambda = s1 && sqrt1_2 * k2 * s0 * t22 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k2) / (2 * (c1 + sqrt2 * c0 * k2) * (c1 + sqrt2 * c0 * k2) * k2), deltacDeltat = -0.5 * t2 * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A2 = (A2 = 2 * c1 + sqrt2 * k2 * (c0 - s0)) * A2 * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k2 + cos1) / A2, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k2 * A2), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t2 * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t22) + c * vp1v * deltatDeltaLambda + c * t2 * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t2 * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t22) + c * vp1v * deltatDeltaPhi + c * t2 * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
    if (!denominator) break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi = max3(-halfPi, min3(halfPi, phi - deltaPhi));
  } while ((abs(deltaLambda) > epsilon2 || abs(deltaPhi) > epsilon2) && --i > 0);
  return abs(abs(phi) - halfPi) < epsilon2 ? [0, phi] : i && [lambda, phi];
};

// node_modules/d3-geo-projection/src/fahey.js
var faheyK = cos(35 * radians);
function faheyRaw(lambda, phi) {
  var t2 = tan(phi / 2);
  return [lambda * faheyK * sqrt3(1 - t2 * t2), (1 + faheyK) * t2];
}
faheyRaw.invert = function(x2, y2) {
  var t2 = y2 / (1 + faheyK);
  return [x2 && x2 / (faheyK * sqrt3(1 - t2 * t2)), 2 * atan(t2)];
};

// node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi) {
  var k2 = phi / 2, cosk = cos(k2);
  return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k2)];
}
foucautRaw.invert = function(x2, y2) {
  var k2 = atan(y2 / sqrtPi), cosk = cos(k2), phi = 2 * k2;
  return [x2 * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];
};

// node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a, b2, c, d, e2, f, g, h2) {
  if (arguments.length < 8) h2 = 0;
  function forward(lambda, phi) {
    if (!phi) return [a * lambda / pi, 0];
    var phi2 = phi * phi, xB = a + phi2 * (b2 + phi2 * (c + phi2 * d)), yB = phi * (e2 - 1 + phi2 * (f - h2 + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;
    return [m * sin(alpha), phi * (1 + phi2 * h2) + m * (1 - cos(alpha))];
  }
  forward.invert = function(x2, y2) {
    var lambda = pi * x2 / a, phi = y2, deltaLambda, deltaPhi, i = 50;
    do {
      var phi2 = phi * phi, xB = a + phi2 * (b2 + phi2 * (c + phi2 * d)), yB = phi * (e2 - 1 + phi2 * (f - h2 + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b2 + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e2 + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = lambda / pi * (1 / sqrt3(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2, fx = msinAlpha - x2, fy = phi * (1 + phi2 * h2) + m - mcosAlpha - y2, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator) break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs(deltaLambda) > epsilon2 || abs(deltaPhi) > epsilon2) && --i > 0);
    return [lambda, phi];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/ginzburg4.js
var ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);

// node_modules/d3-geo-projection/src/ginzburg5.js
var ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);

// node_modules/d3-geo-projection/src/ginzburg6.js
var ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);

// node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi) {
  var lambda2 = lambda * lambda, phi2 = phi * phi;
  return [
    lambda * (1 - 0.162388 * phi2) * (0.87 - 952426e-9 * lambda2 * lambda2),
    phi * (1 + phi2 / 12)
  ];
}
ginzburg8Raw.invert = function(x2, y2) {
  var lambda = x2, phi = y2, i = 50, delta;
  do {
    var phi2 = phi * phi;
    phi -= delta = (phi * (1 + phi2 / 12) - y2) / (1 + phi2 / 4);
  } while (abs(delta) > epsilon2 && --i > 0);
  i = 50;
  x2 /= 1 - 0.162388 * phi2;
  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x2) / (0.87 - 476213e-8 * lambda4);
  } while (abs(delta) > epsilon2 && --i > 0);
  return [lambda, phi];
};

// node_modules/d3-geo-projection/src/ginzburg9.js
var ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);

// node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi) {
  var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z = sin(sPhi * phi);
  lambda = abs(atan2(y2, z));
  phi = asin(x2);
  if (abs(lambda - halfPi) > epsilon2) lambda %= halfPi;
  var point5 = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);
  if (lambda > pi / 4) z = point5[0], point5[0] = -point5[1], point5[1] = -z;
  return point5[0] *= sLambda, point5[1] *= -sPhi, point5;
}
gringortenRaw.invert = function(x2, y2) {
  if (abs(x2) > 1) x2 = sign(x2) * 2 - x2;
  if (abs(y2) > 1) y2 = sign(y2) * 2 - y2;
  var sx = sign(x2), sy = sign(y2), x02 = -sx * x2, y02 = -sy * y2, t2 = y02 / x02 < 1, p = gringortenHexadecantInvert(t2 ? y02 : x02, t2 ? x02 : y02), lambda = p[0], phi = p[1], cosPhi = cos(phi);
  if (t2) lambda = -halfPi - lambda;
  return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];
};
function gringortenHexadecant(lambda, phi) {
  if (phi === halfPi) return [0, 0];
  var sinPhi = sin(phi), r2 = sinPhi * sinPhi, r22 = r2 * r2, j = 1 + r22, k2 = 1 + 3 * r22, q = 1 - r22, z = asin(1 / sqrt3(j)), v = q + r2 * j * z, p2 = (1 - sinPhi) / v, p = sqrt3(p2), a2 = p2 * j, a = sqrt3(a2), h2 = p * q, x2, i;
  if (lambda === 0) return [0, -(h2 + r2 * a)];
  var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r2 + z * k2) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r2 * p * drdPhi, dra2dPhi = r2 * j * dp2dPhi + p2 * k2 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;
  if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {
    x2 = (h2 + r2 * sqrt3(a2 * (1 + r22) - h2 * h2)) / (1 + r22);
    if (lambda > pi / 4) return [x2, x2];
    var x12 = x2, x02 = 0.5 * x2;
    x2 = 0.5 * (x02 + x12), i = 50;
    do {
      var g = sqrt3(a2 - x2 * x2), f = x2 * (zeta + mu * g) + nu * asin(x2 / a) - lambda1;
      if (!f) break;
      if (f < 0) x02 = x2;
      else x12 = x2;
      x2 = 0.5 * (x02 + x12);
    } while (abs(x12 - x02) > epsilon2 && --i > 0);
  } else {
    x2 = epsilon2, i = 25;
    do {
      var x22 = x2 * x2, g2 = sqrt3(a2 - x22), zetaMug = zeta + mu * g2, f2 = x2 * zetaMug + nu * asin(x2 / a) - lambda1, df = zetaMug + (nu - mu * x22) / g2;
      x2 -= delta = g2 ? f2 / df : 0;
    } while (abs(delta) > epsilon2 && --i > 0);
  }
  return [x2, -h2 - r2 * sqrt3(a2 - x2 * x2)];
}
function gringortenHexadecantInvert(x2, y2) {
  var x02 = 0, x12 = 1, r2 = 0.5, i = 50;
  while (true) {
    var r22 = r2 * r2, sinPhi = sqrt3(r2), z = asin(1 / sqrt3(1 + r22)), v = 1 - r22 + r2 * (1 + r22) * z, p2 = (1 - sinPhi) / v, p = sqrt3(p2), a2 = p2 * (1 + r22), h2 = p * (1 - r22), g2 = a2 - x2 * x2, g = sqrt3(g2), y02 = y2 + h2 + r2 * g;
    if (abs(x12 - x02) < epsilon22 || --i === 0 || y02 === 0) break;
    if (y02 > 0) x02 = r2;
    else x12 = r2;
    r2 = 0.5 * (x02 + x12);
  }
  if (!i) return null;
  var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r2 + z * (1 + 3 * r22)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r22) * dpdPhi - 2 * r2 * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r2 * (1 + r22) * dp2dPhi + p2 * (1 + 3 * r22) * drdPhi);
  return [pi / 4 * (x2 * (zeta + mu * g) + nu * asin(x2 / sqrt3(a2))), phi];
}

// node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u, v, m) {
  var a, b2, c;
  if (!u) {
    b2 = ellipticJ(v, 1 - m);
    return [
      [0, b2[0] / b2[1]],
      [1 / b2[1], 0],
      [b2[2] / b2[1], 0]
    ];
  }
  a = ellipticJ(u, m);
  if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
  b2 = ellipticJ(v, 1 - m);
  c = b2[1] * b2[1] + m * a[0] * a[0] * b2[0] * b2[0];
  return [
    [a[0] * b2[2] / c, a[1] * a[2] * b2[0] * b2[1] / c],
    [a[1] * b2[1] / c, -a[0] * a[2] * b2[0] * b2[2] / c],
    [a[2] * b2[1] * b2[2] / c, -m * a[0] * a[1] * b2[0] / c]
  ];
}
function ellipticJ(u, m) {
  var ai, b2, phi, t2, twon;
  if (m < epsilon2) {
    t2 = sin(u);
    b2 = cos(u);
    ai = m * (u - t2 * b2) / 4;
    return [
      t2 - ai * b2,
      b2 + ai * t2,
      1 - m * t2 * t2 / 2,
      u - ai
    ];
  }
  if (m >= 1 - epsilon2) {
    ai = (1 - m) / 4;
    b2 = cosh(u);
    t2 = tanh(u);
    phi = 1 / b2;
    twon = b2 * sinh(u);
    return [
      t2 + ai * (twon - u) / (b2 * b2),
      phi - ai * t2 * phi * (twon - u),
      phi + ai * t2 * phi * (twon + u),
      2 * atan(exp3(u)) - halfPi + ai * (twon - u) / b2
    ];
  }
  var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt3(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
  b2 = sqrt3(1 - m);
  twon = 1;
  while (abs(c[i] / a[i]) > epsilon2 && i < 8) {
    ai = a[i++];
    c[i] = (ai - b2) / 2;
    a[i] = (ai + b2) / 2;
    b2 = sqrt3(ai * b2);
    twon *= 2;
  }
  phi = twon * a[i] * u;
  do {
    t2 = c[i] * sin(b2 = phi) / a[i];
    phi = (asin(t2) + phi) / 2;
  } while (--i);
  return [sin(phi), t2 = cos(phi), t2 / cos(phi - b2), phi];
}
function ellipticFi(phi, psi, m) {
  var r2 = abs(phi), i = abs(psi), sinhPsi = sinh(i);
  if (r2) {
    var cscPhi = 1 / sin(r2), cotPhi2 = 1 / (tan(r2) * tan(r2)), b2 = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b2 + sqrt3(b2 * b2 - 4 * c)) / 2;
    return [
      ellipticF(atan(1 / sqrt3(cotLambda2)), m) * sign(phi),
      ellipticF(atan(sqrt3((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)
    ];
  }
  return [
    0,
    ellipticF(atan(sinhPsi), 1 - m) * sign(psi)
  ];
}
function ellipticF(phi, m) {
  if (!m) return phi;
  if (m === 1) return log4(tan(phi / 2 + quarterPi));
  var a = 1, b2 = sqrt3(1 - m), c = sqrt3(m);
  for (var i = 0; abs(c) > epsilon2; i++) {
    if (phi % pi) {
      var dPhi = atan(b2 * tan(phi) / a);
      if (dPhi < 0) dPhi += pi;
      phi += dPhi + ~~(phi / pi) * pi;
    } else phi += phi;
    c = (a + b2) / 2;
    b2 = sqrt3(a * b2);
    c = ((a = c) - b2) / 2;
  }
  return phi / (pow4(2, i) * a);
}

// node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi) {
  var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt3(1 - k_ * k_), K3 = ellipticF(halfPi, k2 * k2), f = -1, psi = log4(tan(pi / 4 + abs(phi) / 2)), r2 = exp3(f * psi) / sqrt3(k_), at = guyouComplexAtan(r2 * cos(f * lambda), r2 * sin(f * lambda)), t2 = ellipticFi(at[0], at[1], k2 * k2);
  return [-t2[1], (phi >= 0 ? 1 : -1) * (0.5 * K3 - t2[0])];
}
function guyouComplexAtan(x2, y2) {
  var x22 = x2 * x2, y_1 = y2 + 1, t2 = 1 - x22 - y2 * y2;
  return [
    0.5 * ((x2 >= 0 ? halfPi : -halfPi) - atan2(t2, 2 * x2)),
    -0.25 * log4(t2 * t2 + 4 * x22) + 0.5 * log4(y_1 * y_1 + x22)
  ];
}
function guyouComplexDivide(a, b2) {
  var denominator = b2[0] * b2[0] + b2[1] * b2[1];
  return [
    (a[0] * b2[0] + a[1] * b2[1]) / denominator,
    (a[1] * b2[0] - a[0] * b2[1]) / denominator
  ];
}
guyouRaw.invert = function(x2, y2) {
  var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt3(1 - k_ * k_), K3 = ellipticF(halfPi, k2 * k2), f = -1, j = ellipticJi(0.5 * K3 - y2, -x2, k2 * k2), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;
  return [
    lambda,
    2 * atan(exp3(0.5 / f * log4(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi
  ];
};

// node_modules/d3-geo-projection/src/healpix.js
var K = 3;
var healpixParallel = asin(1 - 1 / K) * degrees;
var healpixLambert = cylindricalEqualAreaRaw(0);

// node_modules/d3-geo-projection/src/sinuMollweide.js
var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi) {
  return phi > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
}
sinuMollweideRaw.invert = function(x2, y2) {
  return y2 > -sinuMollweidePhi ? mollweideRaw.invert(x2, y2 - sinuMollweideY) : sinusoidalRaw.invert(x2, y2);
};

// node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi) {
  return abs(phi) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
}
homolosineRaw.invert = function(x2, y2) {
  return abs(y2) > sinuMollweidePhi ? mollweideRaw.invert(x2, y2 + (y2 > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x2, y2);
};

// node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi) {
  return [3 / tau * lambda * sqrt3(pi * pi / 3 - phi * phi), phi];
}
kavrayskiy7Raw.invert = function(x2, y2) {
  return [tau / 3 * x2 / sqrt3(pi * pi / 3 - y2 * y2), y2];
};

// node_modules/d3-geo-projection/src/larrivee.js
var pi_sqrt2 = pi / sqrt2;
function larriveeRaw(lambda, phi) {
  return [
    lambda * (1 + sqrt3(cos(phi))) / 2,
    phi / (cos(phi / 2) * cos(lambda / 6))
  ];
}
larriveeRaw.invert = function(x2, y2) {
  var x02 = abs(x2), y02 = abs(y2), lambda = epsilon2, phi = halfPi;
  if (y02 < pi_sqrt2) phi *= y02 / pi_sqrt2;
  else lambda += 6 * acos(pi_sqrt2 / y02);
  for (var i = 0; i < 25; i++) {
    var sinPhi = sin(phi), sqrtcosPhi = sqrt3(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x02, f1 = phi / (cosPhi_2 * cosLambda_6) - y02, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi -= dPhi;
    lambda -= dLambda;
    if (abs(dPhi) < epsilon2 && abs(dLambda) < epsilon2) break;
  }
  return [x2 < 0 ? -lambda : lambda, y2 < 0 ? -phi : phi];
};

// node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi) {
  var lambda2 = lambda * lambda, phi2 = phi * phi;
  return [
    lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),
    phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032))
  ];
}
laskowskiRaw.invert = function(x2, y2) {
  var lambda = sign(x2) * pi, phi = y2 / 2, i = 50;
  do {
    var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x2, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y2, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 199025e-9 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi -= deltaPhi;
  } while ((abs(deltaLambda) > epsilon2 || abs(deltaPhi) > epsilon2) && --i > 0);
  return i && [lambda, phi];
};

// node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi) {
  return [
    sin(lambda) / cos(phi),
    tan(phi) * cos(lambda)
  ];
}
littrowRaw.invert = function(x2, y2) {
  var x22 = x2 * x2, y22 = y2 * y2, y2_1 = y22 + 1, x2_y2_1 = x22 + y2_1, cosPhi = x2 ? sqrt1_2 * sqrt3((x2_y2_1 - sqrt3(x2_y2_1 * x2_y2_1 - 4 * x22)) / x22) : 1 / sqrt3(y2_1);
  return [
    asin(x2 * cosPhi),
    sign(y2) * acos(cosPhi)
  ];
};

// node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi) {
  return [lambda, 1.25 * log4(tan(quarterPi + 0.4 * phi))];
}
millerRaw.invert = function(x2, y2) {
  return [x2, 2.5 * atan(exp3(0.8 * y2)) - 0.625 * pi];
};

// node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
var sqrt6 = sqrt3(6);
var sqrt7 = sqrt3(7);
function mtFlatPolarParabolicRaw(lambda, phi) {
  var theta = asin(7 * sin(phi) / (3 * sqrt6));
  return [
    sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,
    9 * sin(theta / 3) / sqrt7
  ];
}
mtFlatPolarParabolicRaw.invert = function(x2, y2) {
  var theta = 3 * asin(y2 * sqrt7 / 9);
  return [
    x2 * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),
    asin(sin(theta) * 3 * sqrt6 / 7)
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi) {
  var k2 = (1 + sqrt1_2) * sin(phi), theta = phi;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (sin(theta / 2) + sin(theta) - k2) / (0.5 * cos(theta / 2) + cos(theta));
    if (abs(delta) < epsilon2) break;
  }
  return [
    lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),
    2 * sqrt3(3) * sin(theta / 2) / sqrt3(2 + sqrt2)
  ];
}
mtFlatPolarQuarticRaw.invert = function(x2, y2) {
  var sinTheta_2 = y2 * sqrt3(2 + sqrt2) / (2 * sqrt3(3)), theta = 2 * asin(sinTheta_2);
  return [
    3 * sqrt2 * x2 / (1 + 2 * cos(theta) / cos(theta / 2)),
    asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi) {
  var A2 = sqrt3(6 / (4 + pi)), k2 = (1 + pi / 4) * sin(phi), theta = phi / 2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + sin(theta) - k2) / (0.5 + cos(theta));
    if (abs(delta) < epsilon2) break;
  }
  return [
    A2 * (0.5 + cos(theta)) * lambda / 1.5,
    A2 * theta
  ];
}
mtFlatPolarSinusoidalRaw.invert = function(x2, y2) {
  var A2 = sqrt3(6 / (4 + pi)), theta = y2 / A2;
  if (abs(abs(theta) - halfPi) < epsilon2) theta = theta < 0 ? -halfPi : halfPi;
  return [
    1.5 * x2 / (A2 * (0.5 + cos(theta))),
    asin((theta / 2 + sin(theta)) / (1 + pi / 4))
  ];
};

// node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4))
  ];
}
naturalEarth2Raw.invert = function(x2, y2) {
  var phi = y2, i = 25, delta, phi2, phi4, phi6;
  do {
    phi2 = phi * phi;
    phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4)) - y2) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -396e-5 * phi4));
  } while (abs(delta) > epsilon22 && --i > 0);
  phi2 = phi * phi;
  phi4 = phi2 * phi2;
  phi6 = phi2 * phi4;
  return [
    x2 / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi
  ];
};

// node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi) {
  return [
    lambda * (1 + cos(phi)) / 2,
    2 * (phi - tan(phi / 2))
  ];
}
nellHammerRaw.invert = function(x2, y2) {
  var p = y2 / 2;
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon2; ++i) {
    var c = cos(y2 / 2);
    y2 -= delta = (y2 - tan(y2 / 2) - p) / (1 - 0.5 / (c * c));
  }
  return [
    2 * x2 / (1 + cos(y2)),
    y2
  ];
};

// node_modules/d3-geo-projection/src/nicolosi.js
function nicolosiRaw(lambda, phi) {
  var sinPhi = sin(phi), q = cos(phi), s = sign(lambda);
  if (lambda === 0 || abs(phi) === halfPi) return [0, phi];
  else if (phi === 0) return [lambda, 0];
  else if (abs(lambda) === halfPi) return [lambda * q, halfPi * sinPhi];
  var b2 = pi / (2 * lambda) - 2 * lambda / pi, c = 2 * phi / pi, d = (1 - c * c) / (sinPhi - c);
  var b22 = b2 * b2, d2 = d * d, b2d2 = 1 + b22 / d2, d2b2 = 1 + d2 / b22;
  var M = (b2 * sinPhi / d - b2 / 2) / b2d2, N = (d2 * sinPhi / b22 + d / 2) / d2b2, m = M * M + q * q / b2d2, n = N * N - (d2 * sinPhi * sinPhi / b22 + d * sinPhi - 1) / d2b2;
  return [
    halfPi * (M + sqrt3(m) * s),
    halfPi * (N + sqrt3(n < 0 ? 0 : n) * sign(-phi * b2) * s)
  ];
}
nicolosiRaw.invert = function(x2, y2) {
  x2 /= halfPi;
  y2 /= halfPi;
  var x22 = x2 * x2, y22 = y2 * y2, x2y2 = x22 + y22, pi2 = pi * pi;
  return [
    x2 ? (x2y2 - 1 + sqrt3((1 - x2y2) * (1 - x2y2) + 4 * x22)) / (2 * x2) * halfPi : 0,
    solve(function(phi) {
      return x2y2 * (pi * sin(phi) - 2 * phi) * pi + 4 * phi * phi * (y2 - sin(phi)) + 2 * pi * phi - pi2 * y2;
    }, 0)
  ];
};

// node_modules/d3-geo-projection/src/patterson.js
var pattersonK1 = 1.0148;
var pattersonK2 = 0.23185;
var pattersonK3 = -0.14499;
var pattersonK4 = 0.02406;
var pattersonC1 = pattersonK1;
var pattersonC2 = 5 * pattersonK2;
var pattersonC3 = 7 * pattersonK3;
var pattersonC4 = 9 * pattersonK4;
var pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi) {
  var phi2 = phi * phi;
  return [
    lambda,
    phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))
  ];
}
pattersonRaw.invert = function(x2, y2) {
  if (y2 > pattersonYmax) y2 = pattersonYmax;
  else if (y2 < -pattersonYmax) y2 = -pattersonYmax;
  var yc = y2, delta;
  do {
    var y22 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y22 * y22 * (pattersonK2 + y22 * (pattersonK3 + pattersonK4 * y22))) - y2) / (pattersonC1 + y22 * y22 * (pattersonC2 + y22 * (pattersonC3 + pattersonC4 * y22)));
  } while (abs(delta) > epsilon2);
  return [x2, yc];
};

// node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi) {
  if (abs(phi) < epsilon2) return [lambda, 0];
  var tanPhi = tan(phi), k2 = lambda * sin(phi);
  return [
    sin(k2) / tanPhi,
    phi + (1 - cos(k2)) / tanPhi
  ];
}
polyconicRaw.invert = function(x2, y2) {
  if (abs(y2) < epsilon2) return [x2, 0];
  var k2 = x2 * x2 + y2 * y2, phi = y2 * 0.5, i = 10, delta;
  do {
    var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y2 * phi + phi * phi;
    phi -= delta = (tanPhi * j + 2 * (phi - y2)) / (2 + j * secPhi * secPhi + 2 * (phi - y2) * tanPhi);
  } while (abs(delta) > epsilon2 && --i > 0);
  tanPhi = tan(phi);
  return [
    (abs(y2) < abs(phi + 1 / tanPhi) ? asin(x2 * tanPhi) : sign(y2) * sign(x2) * (acos(abs(x2 * tanPhi)) + halfPi)) / sin(phi),
    phi
  ];
};

// node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron = [
  [0, 90],
  [-90, 0],
  [0, 0],
  [90, 0],
  [180, 0],
  [0, -90]
];
var octahedron_default = [
  [0, 2, 1],
  [0, 3, 2],
  [5, 1, 2],
  [5, 2, 3],
  [0, 1, 4],
  [0, 4, 3],
  [5, 4, 1],
  [5, 3, 4]
].map(function(face) {
  return face.map(function(i) {
    return octahedron[i];
  });
});

// node_modules/d3-geo-projection/src/polyhedral/collignon.js
var kx = 2 / sqrt3(3);
function collignonK(a, b2) {
  var p = collignonRaw(a, b2);
  return [p[0] * kx, p[1]];
}
collignonK.invert = function(x2, y2) {
  return collignonRaw.invert(x2 / kx, y2);
};

// node_modules/d3-geo-projection/src/robinson.js
var K2 = [
  [0.9986, -0.062],
  [1, 0],
  [0.9986, 0.062],
  [0.9954, 0.124],
  [0.99, 0.186],
  [0.9822, 0.248],
  [0.973, 0.31],
  [0.96, 0.372],
  [0.9427, 0.434],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.835, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1]
];
K2.forEach(function(d) {
  d[1] *= 1.593415793900743;
});
function robinsonRaw(lambda, phi) {
  var i = min3(18, abs(phi) * 36 / pi), i0 = floor2(i), di = i - i0, ax = (k2 = K2[i0])[0], ay = k2[1], bx = (k2 = K2[++i0])[0], by = k2[1], cx = (k2 = K2[min3(19, ++i0)])[0], cy = k2[1], k2;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    sign(phi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
robinsonRaw.invert = function(x2, y2) {
  var phi = y2 * 90, i = min3(18, abs(phi / 5)), i0 = max3(0, floor2(i));
  do {
    var ay = K2[i0][1], by = K2[i0 + 1][1], cy = K2[min3(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t2 = 2 * (abs(y2) - by) / u, c = v / u, di = t2 * (1 - c * t2 * (1 - 2 * c * t2));
    if (di >= 0 || i0 === 1) {
      phi = (y2 >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = min3(18, abs(phi) / 5);
        i0 = floor2(i);
        di = i - i0;
        ay = K2[i0][1];
        by = K2[i0 + 1][1];
        cy = K2[min3(19, i0 + 2)][1];
        phi -= (delta = sign(y2) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y2) * degrees;
      } while (abs(delta) > epsilon22 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K2[i0][0], bx = K2[i0 + 1][0], cx = K2[min3(19, i0 + 2)][0];
  return [
    x2 / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * radians
  ];
};

// node_modules/d3-geo-projection/src/stitch.js
var epsilon3 = 1e-4;
var x0 = -180;
var x0e = x0 + epsilon3;
var x1 = 180;
var x1e = x1 - epsilon3;
var y0 = -90;
var y0e = y0 + epsilon3;
var y1 = 90;
var y1e = y1 - epsilon3;

// node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi) {
  var t2 = tan(phi / 2), s = sin(quarterPi * t2);
  return [
    lambda * (0.74482 - 0.34588 * s * s),
    1.70711 * t2
  ];
}
timesRaw.invert = function(x2, y2) {
  var t2 = y2 / 1.70711, s = sin(quarterPi * t2);
  return [
    x2 / (0.74482 - 0.34588 * s * s),
    2 * atan(t2)
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi) {
  if (abs(phi) < epsilon2) return [lambda, 0];
  var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
  if (abs(lambda) < epsilon2 || abs(abs(phi) - halfPi) < epsilon2) return [0, sign(phi) * pi * tan(theta / 2)];
  var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A22, G_P2 = G - P2, Q = A22 + G;
  return [
    sign(lambda) * pi * (A2 * G_P2 + sqrt3(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
    sign(phi) * pi * (P * Q - A2 * sqrt3((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
  ];
}
vanDerGrintenRaw.invert = function(x2, y2) {
  if (abs(y2) < epsilon2) return [x2, 0];
  if (abs(x2) < epsilon2) return [0, halfPi * sin(2 * atan(y2 / pi))];
  var x22 = (x2 /= pi) * x2, y22 = (y2 /= pi) * y2, x2_y2 = x22 + y22, z = x2_y2 * x2_y2, c1 = -abs(y2) * (1 + x2_y2), c2 = c1 - 2 * y22 + x22, c3 = -2 * c1 + 1 + 2 * y22 + z, d = y22 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt3(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;
  return [
    pi * (x2_y2 - 1 + sqrt3(1 + 2 * (x22 - y22) + z)) / (2 * x2),
    sign(y2) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi) {
  if (abs(phi) < epsilon2) return [lambda, 0];
  var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
  if (abs(lambda) < epsilon2 || abs(abs(phi) - halfPi) < epsilon2) return [0, sign(phi) * pi * tan(theta / 2)];
  var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, x12 = cosTheta * (sqrt3(1 + A22) - A2 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
  return [
    sign(lambda) * pi * x12,
    sign(phi) * pi * sqrt3(1 - x12 * (2 * A2 + x12))
  ];
}
vanDerGrinten2Raw.invert = function(x2, y2) {
  if (!x2) return [0, halfPi * sin(2 * atan(y2 / pi))];
  var x12 = abs(x2 / pi), A2 = (1 - x12 * x12 - (y2 /= pi) * y2) / (2 * x12), A22 = A2 * A2, B2 = sqrt3(A22 + 1);
  return [
    sign(x2) * pi * (B2 - A2),
    sign(y2) * halfPi * sin(2 * atan2(sqrt3((1 - 2 * A2 * x12) * (A2 + B2) - x12), sqrt3(B2 + A2 + x12)))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi) {
  if (abs(phi) < epsilon2) return [lambda, 0];
  var sinTheta = phi / halfPi, theta = asin(sinTheta);
  if (abs(lambda) < epsilon2 || abs(abs(phi) - halfPi) < epsilon2) return [0, pi * tan(theta / 2)];
  var A2 = (pi / lambda - lambda / pi) / 2, y12 = sinTheta / (1 + cos(theta));
  return [
    pi * (sign(lambda) * sqrt3(A2 * A2 + 1 - y12 * y12) - A2),
    pi * y12
  ];
}
vanDerGrinten3Raw.invert = function(x2, y2) {
  if (!y2) return [x2, 0];
  var y12 = y2 / pi, A2 = (pi * pi * (1 - y12 * y12) - x2 * x2) / (2 * pi * x2);
  return [
    x2 ? pi * (sign(x2) * sqrt3(A2 * A2 + 1) - A2) : 0,
    halfPi * sin(2 * atan(y12))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi) {
  if (!phi) return [lambda, 0];
  var phi02 = abs(phi);
  if (!lambda || phi02 === halfPi) return [0, phi];
  var B2 = phi02 / halfPi, B22 = B2 * B2, C2 = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C22 = C2 * C2, BC = B2 * C2, B_C2 = B22 + C22 + 2 * BC, B_3C = B2 + 3 * C2, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt3(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B22 + C22 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + 12 * BC * C22 + 4 * C22 * C22), x12 = (D * (B_C2 + C22 - 1) + 2 * sqrt3(F)) / (4 * B_C2 + D2);
  return [
    sign(lambda) * halfPi * x12,
    sign(phi) * halfPi * sqrt3(1 + D * abs(x12) - x12 * x12)
  ];
}
vanDerGrinten4Raw.invert = function(x2, y2) {
  var delta;
  if (!x2 || !y2) return [x2, y2];
  var sy = sign(y2);
  y2 = abs(y2) / pi;
  var x12 = sign(x2) * x2 / halfPi, D = (x12 * x12 - 1 + 4 * y2 * y2) / abs(x12), D2 = D * D, B2 = y2 * (2 - (y2 > 0.5 ? min3(y2, abs(x2)) : 0)), r2 = x2 * x2 + y2 * y2, i = 50;
  do {
    var B22 = B2 * B2, C2 = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C_ = (3 * B2 - B22 * B2 - 10) / (2 * B22 * B2), C22 = C2 * C2, BC = B2 * C2, B_C = B2 + C2, B_C2 = B_C * B_C, B_3C = B2 + 3 * C2, F = B_C2 * (B22 + C22 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + C22 * (12 * BC + 4 * C22)), F_ = -2 * B_C * (4 * BC * C22 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C22 * (-6 + 14 * B22 - D2 + (-8 + 8 * B22 - 2 * D2) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D2) * C_)), sqrtF = sqrt3(F), f = D * (B_C2 + C22 - 1) + 2 * sqrtF - x12 * (4 * B_C2 + D2), f_ = D * (2 * C2 * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C22 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
    B2 -= delta = f / f_;
  } while (delta * r2 * r2 > epsilon2 && --i > 0);
  return [
    sign(x2) * (sqrt3(D * D + 4) + D) * pi / 4,
    sy * halfPi * B2
  ];
};

// node_modules/d3-geo-projection/src/wagner4.js
var A = 4 * pi + 3 * sqrt3(3);
var B = 2 * sqrt3(2 * pi * sqrt3(3) / A);
var wagner4Raw = mollweideBromleyRaw(B * sqrt3(3) / pi, B, A / 6);

// node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi) {
  return [lambda * sqrt3(1 - 3 * phi * phi / (pi * pi)), phi];
}
wagner6Raw.invert = function(x2, y2) {
  return [x2 / sqrt3(1 - 3 * y2 * y2 / (pi * pi)), y2];
};

// node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi) {
  var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);
  cosPhi = sqrt3(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
wiechelRaw.invert = function(x2, y2) {
  var w4 = (x2 * x2 + y2 * y2) / -2, k2 = sqrt3(-w4 * (2 + w4)), b2 = y2 * w4 + x2 * k2, a = x2 * w4 - y2 * k2, D = sqrt3(a * a + b2 * b2);
  return [
    atan2(k2 * b2, D * (1 + w4)),
    D ? -asin(k2 * a / D) : 0
  ];
};

// node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi) {
  var coordinates = aitoffRaw(lambda, phi);
  return [
    (coordinates[0] + lambda / halfPi) / 2,
    (coordinates[1] + phi) / 2
  ];
}
winkel3Raw.invert = function(x2, y2) {
  var lambda = x2, phi = y2, i = 25;
  do {
    var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C2 = 1 - cos2phi * coslambda_2 * coslambda_2, E = C2 ? acos(cosphi * coslambda_2) * sqrt3(F = 1 / C2) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x2, fy = 0.5 * (E * sinphi + phi) - y2, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi -= dphi;
  } while ((abs(dlambda) > epsilon2 || abs(dphi) > epsilon2) && --i > 0);
  return [lambda, phi];
};

// node_modules/vega-projection/build/vega-projection.module.js
var defaultPath = path_default();
var projectionProperties = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function create2(type3, constructor) {
  return function projection3() {
    const p = constructor();
    p.type = type3;
    p.path = path_default().projection(p);
    p.copy = p.copy || function() {
      const c = projection3();
      projectionProperties.forEach((prop) => {
        if (p[prop]) c[prop](p[prop]());
      });
      c.path.pointRadius(p.path.pointRadius());
      return c;
    };
    return registerScale(p);
  };
}
function projection2(type3, proj) {
  if (!type3 || typeof type3 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type3 = type3.toLowerCase();
  if (arguments.length > 1) {
    projections[type3] = create2(type3, proj);
    return this;
  } else {
    return projections[type3] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
var projections = {
  // base d3-geo projection types
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default,
  mercator: mercator_default,
  mollweide: mollweide_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
for (const key2 in projections) {
  projection2(key2, projections[key2]);
}

// node_modules/vega-geo/build/vega-geo.module.js
function noop2() {
}
var cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values5, tz) {
    return tz.map((value3) => contour(values5, value3));
  }
  function contour(values5, value3) {
    var polygons = [], holes = [];
    isorings(values5, value3, (ring) => {
      smooth(ring, values5, value3);
      if (area2(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value3,
      coordinates: polygons
    };
  }
  function isorings(values5, value3, callback) {
    var fragmentByStart = [], fragmentByEnd = [], x2, y2, t02, t1, t2, t3;
    x2 = y2 = -1;
    t1 = values5[0] >= value3;
    cases[t1 << 1].forEach(stitch);
    while (++x2 < dx - 1) {
      t02 = t1, t1 = values5[x2 + 1] >= value3;
      cases[t02 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);
    while (++y2 < dy - 1) {
      x2 = -1;
      t1 = values5[y2 * dx + dx] >= value3;
      t2 = values5[y2 * dx] >= value3;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x2 < dx - 1) {
        t02 = t1, t1 = values5[y2 * dx + dx + x2 + 1] >= value3;
        t3 = t2, t2 = values5[y2 * dx + x2 + 1] >= value3;
        cases[t02 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }
    x2 = -1;
    t2 = values5[y2 * dx] >= value3;
    cases[t2 << 2].forEach(stitch);
    while (++x2 < dx - 1) {
      t3 = t2, t2 = values5[y2 * dx + x2 + 1] >= value3;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);
    function stitch(line4) {
      var start = [line4[0][0] + x2, line4[0][1] + y2], end = [line4[1][0] + x2, line4[1][1] + y2], startIndex = index3(start), endIndex = index3(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index3(point5) {
    return point5[0] * 2 + point5[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values5, value3) {
    ring.forEach((point5) => {
      var x2 = point5[0], y2 = point5[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values5[yt * dx + xt];
      if (x2 > 0 && x2 < dx && xt === x2) {
        v0 = values5[yt * dx + xt - 1];
        point5[0] = x2 + (value3 - v0) / (v1 - v0) - 0.5;
      }
      if (y2 > 0 && y2 < dy && yt === y2) {
        v0 = values5[(yt - 1) * dx + xt];
        point5[1] = y2 + (value3 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0)) error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop2, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area2(ring) {
  var i = 0, n = ring.length, area4 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area4 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area4;
}
function contains(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
}
function ringContains(ring, point5) {
  var x2 = point5[0], y2 = point5[1], contains3 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi2, pj, point5)) return 0;
    if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi) contains3 = -contains3;
  }
  return contains3;
}
function segmentContains(a, b2, c) {
  var i;
  return collinear(a, b2, c) && within(a[i = +(a[0] === b2[0])], c[i], b2[i]);
}
function collinear(a, b2, c) {
  return (b2[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b2[1] - a[1]);
}
function within(p, q, r2) {
  return p <= q && q <= r2 || r2 <= q && q <= p;
}
function quantize2(k2, nice2, zero4) {
  return function(values5) {
    var ex = extent(values5), start = zero4 ? Math.min(ex[0], 0) : ex[0], stop3 = ex[1], span2 = stop3 - start, step = nice2 ? tickStep(start, stop3, k2) : span2 / (k2 + 1);
    return range(start + step, stop3, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
Isocontour.Definition = {
  "type": "Isocontour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "levels",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "zero",
    "type": "boolean",
    "default": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }, {
    "name": "scale",
    "type": "number",
    "expr": true
  }, {
    "name": "translate",
    "type": "number",
    "array": true,
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "default": "contour"
  }]
};
inherits(Isocontour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source4 = pulse2.materialize(pulse2.SOURCE).source, field3 = _.field || identity2, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source4, field3, _), as = _.as === null ? null : _.as || "contour", values5 = [];
    source4.forEach((t2) => {
      const grid = field3(t2);
      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));
      transformPaths(paths, grid, t2, _);
      paths.forEach((p) => {
        values5.push(rederive(t2, ingest$1(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values5;
    return out;
  }
});
function levels(values5, f, _) {
  const q = quantize2(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values5.map((t2) => max(f(t2).values)));
}
function transformPaths(paths, grid, datum2, _) {
  let s = _.scale || grid.scale, t2 = _.translate || grid.translate;
  if (isFunction(s)) s = s(datum2, _);
  if (isFunction(t2)) t2 = t2(datum2, _);
  if ((s === 1 || s == null) && !t2) return;
  const sx = (isNumber(s) ? s : s[0]) || 1, sy = (isNumber(s) ? s : s[1]) || 1, tx = t2 && t2[0] || 0, ty = t2 && t2[1] || 0;
  paths.forEach(transform2(grid, sx, sy, tx, ty));
}
function transform2(grid, sx, sy, tx, ty) {
  const x12 = grid.x1 || 0, y12 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2) coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x12) * sx + tx;
    coordinates[1] = (coordinates[1] - y12) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data3, f) {
  const v = bw >= 0 ? bw : estimateBandwidth(data3, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number2(_) {
  return isFunction(_) ? _ : constant(+_);
}
function density2D() {
  var x2 = (d) => d[0], y2 = (d) => d[1], weight = one, bandwidth2 = [-1, -1], dx = 960, dy = 500, k2 = 2;
  function density(data3, counts) {
    const rx = radius(bandwidth2[0], data3, x2) >> k2, ry = radius(bandwidth2[1], data3, y2) >> k2, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k2), m = 2 * oy + (dy >> k2), values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
    let values5 = values0;
    data3.forEach((d) => {
      const xi = ox + (+x2(d) >> k2), yi = oy + (+y2(d) >> k2);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m, values0, values1, rx);
      blurX(n, m, values1, values0, rx);
      blurX(n, m, values0, values1, rx);
      values5 = values1;
    } else if (ry > 0) {
      blurY(n, m, values0, values1, ry);
      blurY(n, m, values1, values0, ry);
      blurY(n, m, values0, values1, ry);
      values5 = values1;
    }
    const s = counts ? Math.pow(2, -2 * k2) : 1 / sum(values5);
    for (let i = 0, sz2 = n * m; i < sz2; ++i) values5[i] *= s;
    return {
      values: values5,
      scale: 1 << k2,
      width: n,
      height: m,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k2),
      y2: oy + (dy >> k2)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x2 = number2(_), density) : x2;
  };
  density.y = function(_) {
    return arguments.length ? (y2 = number2(_), density) : y2;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number2(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0)) error("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k2;
    if (!((_ = +_) >= 1)) error("invalid cell size");
    k2 = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length) return bandwidth2;
    _ = array(_);
    if (_.length === 1) _ = [+_[0], +_[0]];
    if (_.length !== 2) error("invalid bandwidth");
    return bandwidth2 = _, density;
  };
  return density;
}
function blurX(n, m, source4, target2, r2) {
  const w4 = (r2 << 1) + 1;
  for (let j = 0; j < m; ++j) {
    for (let i = 0, sr = 0; i < n + r2; ++i) {
      if (i < n) {
        sr += source4[i + j * n];
      }
      if (i >= r2) {
        if (i >= w4) {
          sr -= source4[i - w4 + j * n];
        }
        target2[i - r2 + j * n] = sr / Math.min(i + 1, n - 1 + w4 - i, w4);
      }
    }
  }
}
function blurY(n, m, source4, target2, r2) {
  const w4 = (r2 << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m + r2; ++j) {
      if (j < m) {
        sr += source4[i + j * n];
      }
      if (j >= r2) {
        if (j >= w4) {
          sr -= source4[i + (j - w4) * n];
        }
        target2[i + (j - r2) * n] = sr / Math.min(j + 1, m - 1 + w4 - j, w4);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
KDE2D.Definition = {
  "type": "KDE2D",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": "grid"
  }]
};
var PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
inherits(KDE2D, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) return pulse2.StopPropagation;
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition3(source4, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values5 = [];
    function set5(t2, vals2) {
      for (let i = 0; i < names.length; ++i) t2[names[i]] = vals2[i];
      return t2;
    }
    values5 = groups.map((g) => ingest$1(set5({
      [as]: kde2(g, _.counts)
    }, g.dims)));
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values5;
    return out;
  }
});
function partition3(data3, groupby) {
  var groups = [], get6 = (f) => f(t2), map2, i, n, t2, k2, g;
  if (groupby == null) {
    groups.push(data3);
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t2 = data3[i];
      k2 = groupby.map(get6);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        g.dims = k2;
        groups.push(g);
      }
      g.push(t2);
    }
  }
  return groups;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
Contour.Definition = {
  "type": "Contour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "values",
    "type": "number",
    "array": true
  }, {
    "name": "x",
    "type": "field"
  }, {
    "name": "y",
    "type": "field"
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number"
  }, {
    "name": "count",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }]
};
inherits(Contour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values5 = _.values, thresh = _.thresholds || quantize2(_.count || 10, _.nice, !!values5), size = _.size, grid, post2;
    if (!values5) {
      values5 = pulse2.materialize(pulse2.SOURCE).source;
      grid = params(density2D(), _)(values5, true);
      post2 = transform2(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values5 = grid.values;
    }
    thresh = isArray(thresh) ? thresh : thresh(values5);
    values5 = contour.size(size)(values5, thresh);
    if (post2) values5.forEach(post2);
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = (values5 || []).map(ingest$1);
    return out;
  }
});
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
var MultiPoint = "MultiPoint";
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
GeoJSON.Definition = {
  "type": "GeoJSON",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "length": 2
  }, {
    "name": "geojson",
    "type": "field"
  }]
};
inherits(GeoJSON, Transform, {
  transform(_, pulse2) {
    var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity2, flag2 = pulse2.ADD, mod;
    mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
    if (!this.value || mod) {
      flag2 = pulse2.SOURCE;
      this._features = features = [];
      this._points = points2 = [];
    }
    if (geojson) {
      pulse2.visit(flag2, (t2) => features.push(geojson(t2)));
    }
    if (lon && lat) {
      pulse2.visit(flag2, (t2) => {
        var x2 = lon(t2), y2 = lat(t2);
        if (x2 != null && y2 != null && (x2 = +x2) === x2 && (y2 = +y2) === y2) {
          points2.push([x2, y2]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points2
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features
    };
  }
});
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
GeoPath.Definition = {
  "type": "GeoPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(GeoPath, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), path3 = this.value, field3 = _.field || identity2, as = _.as || "path", flag2 = out.SOURCE;
    if (!path3 || _.modified()) {
      this.value = path3 = getProjectionPath(_.projection);
      out.materialize().reflow();
    } else {
      flag2 = field3 === identity2 || pulse2.modified(field3.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev = initPath(path3, _.pointRadius);
    out.visit(flag2, (t2) => t2[as] = path3(field3(t2)));
    path3.pointRadius(prev);
    return out.modifies(as);
  }
});
function initPath(path3, pointRadius) {
  const prev = path3.pointRadius();
  path3.context(null);
  if (pointRadius != null) {
    path3.pointRadius(pointRadius);
  }
  return prev;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
GeoPoint.Definition = {
  "type": "GeoPoint",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection",
    "required": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["x", "y"]
  }]
};
inherits(GeoPoint, Transform, {
  transform(_, pulse2) {
    var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x2 = as[0], y2 = as[1], mod;
    function set5(t2) {
      const xy = proj([lon(t2), lat(t2)]);
      if (xy) {
        t2[x2] = xy[0];
        t2[y2] = xy[1];
      } else {
        t2[x2] = void 0;
        t2[y2] = void 0;
      }
    }
    if (_.modified()) {
      pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set5);
    } else {
      mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
      pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set5);
    }
    return pulse2.modifies(as);
  }
});
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
GeoShape.Definition = {
  "type": "GeoShape",
  "metadata": {
    "modifies": true,
    "nomod": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field",
    "default": "datum"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "shape"
  }]
};
inherits(GeoShape, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), shape2 = this.value, as = _.as || "shape", flag2 = out.ADD;
    if (!shape2 || _.modified()) {
      this.value = shape2 = shapeGenerator(getProjectionPath(_.projection), _.field || field("datum"), _.pointRadius);
      out.materialize().reflow();
      flag2 = out.SOURCE;
    }
    out.visit(flag2, (t2) => t2[as] = shape2);
    return out.modifies(as);
  }
});
function shapeGenerator(path3, field3, pointRadius) {
  const shape2 = pointRadius == null ? (_) => path3(field3(_)) : (_) => {
    var prev = path3.pointRadius(), value3 = path3.pointRadius(pointRadius)(field3(_));
    path3.pointRadius(prev);
    return value3;
  };
  shape2.context = (_) => {
    path3.context(_);
    return shape2;
  };
  return shape2;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
Graticule.Definition = {
  "type": "Graticule",
  "metadata": {
    "changes": true,
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMajor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMinor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "step",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "stepMajor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [90, 360]
  }, {
    "name": "stepMinor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [10, 10]
  }, {
    "name": "precision",
    "type": "number",
    "default": 2.5
  }]
};
inherits(Graticule, Transform, {
  transform(_, pulse2) {
    var src = this.value, gen = this.generator, t2;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if (isFunction(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t2 = gen();
    if (src.length) {
      pulse2.mod.push(replace(src[0], t2));
    } else {
      pulse2.add.push(ingest$1(t2));
    }
    src[0] = t2;
    return pulse2;
  }
});
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
Heatmap.Definition = {
  "type": "heatmap",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "color",
    "type": "string",
    "expr": true
  }, {
    "name": "opacity",
    "type": "number",
    "expr": true
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "as",
    "type": "string",
    "default": "image"
  }]
};
inherits(Heatmap, Transform, {
  transform(_, pulse2) {
    if (!pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var source4 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field3 = _.field || identity2, opacity2 = opacity_(_.opacity, _), color4 = color_(_.color, _), as = _.as || "image", obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? max(source4.map((t2) => max(field3(t2).values))) : 0
    };
    source4.forEach((t2) => {
      const v = field3(t2);
      const o = extend({}, t2, obj);
      if (!shared) o.$max = max(v.values || []);
      t2[as] = toCanvas(v, o, color4.dep ? color4 : constant(color4(o)), opacity2.dep ? opacity2 : constant(opacity2(o)));
    });
    return pulse2.reflow(true).modifies(as);
  }
});
function color_(color4, _) {
  let f;
  if (isFunction(color4)) {
    f = (obj) => rgb(color4(obj, _));
    f.dep = dependency(color4);
  } else {
    f = constant(rgb(color4 || "#888"));
  }
  return f;
}
function opacity_(opacity2, _) {
  let f;
  if (isFunction(opacity2)) {
    f = (obj) => opacity2(obj, _);
    f.dep = dependency(opacity2);
  } else if (opacity2) {
    f = constant(opacity2);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction(f)) return false;
  const set5 = toSet(accessorFields(f));
  return set5.$x || set5.$y || set5.$value || set5.$max;
}
function toCanvas(grid, obj, color4, opacity2) {
  const n = grid.width, m = grid.height, x12 = grid.x1 || 0, y12 = grid.y1 || 0, x2 = grid.x2 || n, y2 = grid.y2 || m, val = grid.values, value3 = val ? (i) => val[i] : zero, can = domCanvas(x2 - x12, y2 - y12), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x2 - x12, y2 - y12), pix = img.data;
  for (let j = y12, k2 = 0; j < y2; ++j) {
    obj.$y = j - y12;
    for (let i = x12, r2 = j * n; i < x2; ++i, k2 += 4) {
      obj.$x = i - x12;
      obj.$value = value3(i + r2);
      const v = color4(obj);
      pix[k2 + 0] = v.r;
      pix[k2 + 1] = v.g;
      pix[k2 + 2] = v.b;
      pix[k2 + 3] = ~~(255 * opacity2(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Projection, Transform, {
  transform(_, pulse2) {
    let proj = this.value;
    if (!proj || _.modified("type")) {
      this.value = proj = create3(_.type);
      projectionProperties.forEach((prop) => {
        if (_[prop] != null) set3(proj, prop, _[prop]);
      });
    } else {
      projectionProperties.forEach((prop) => {
        if (_.modified(prop)) set3(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);
    if (_.fit) fit(proj, _);
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function fit(proj, _) {
  const data3 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data3) : _.size ? proj.fitSize(_.size, data3) : 0;
}
function create3(type3) {
  const constructor = projection2((type3 || "mercator").toLowerCase());
  if (!constructor) error("Unrecognized projection type: " + type3);
  return constructor();
}
function set3(proj, key2, value3) {
  if (isFunction(proj[key2])) proj[key2](value3);
}
function collectGeoJSON(data3) {
  data3 = array(data3);
  return data3.length === 1 ? data3[0] : {
    type: FeatureCollection,
    features: data3.reduce((a, f) => a.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}

// node_modules/vega-force/build/vega-force.module.js
var vega_force_module_exports = {};
__export(vega_force_module_exports, {
  force: () => Force
});
var ForceMap = {
  center: center_default,
  collide: collide_default,
  nbody: manyBody_default,
  link: link_default,
  x: x_default,
  y: y_default
};
var Forces = "forces";
var ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"];
var ForceConfig = ["static", "iterations"];
var ForceOutput = ["x", "y", "vx", "vy"];
function Force(params2) {
  Transform.call(this, null, params2);
}
Force.Definition = {
  "type": "Force",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "static",
    "type": "boolean",
    "default": false
  }, {
    "name": "restart",
    "type": "boolean",
    "default": false
  }, {
    "name": "iterations",
    "type": "number",
    "default": 300
  }, {
    "name": "alpha",
    "type": "number",
    "default": 1
  }, {
    "name": "alphaMin",
    "type": "number",
    "default": 1e-3
  }, {
    "name": "alphaTarget",
    "type": "number",
    "default": 0
  }, {
    "name": "velocityDecay",
    "type": "number",
    "default": 0.4
  }, {
    "name": "forces",
    "type": "param",
    "array": true,
    "params": [{
      "key": {
        "force": "center"
      },
      "params": [{
        "name": "x",
        "type": "number",
        "default": 0
      }, {
        "name": "y",
        "type": "number",
        "default": 0
      }]
    }, {
      "key": {
        "force": "collide"
      },
      "params": [{
        "name": "radius",
        "type": "number",
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "default": 0.7
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "nbody"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": -30,
        "expr": true
      }, {
        "name": "theta",
        "type": "number",
        "default": 0.9
      }, {
        "name": "distanceMin",
        "type": "number",
        "default": 1
      }, {
        "name": "distanceMax",
        "type": "number"
      }]
    }, {
      "key": {
        "force": "link"
      },
      "params": [{
        "name": "links",
        "type": "data"
      }, {
        "name": "id",
        "type": "field"
      }, {
        "name": "distance",
        "type": "number",
        "default": 30,
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "expr": true
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "x"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "x",
        "type": "field"
      }]
    }, {
      "key": {
        "force": "y"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "y",
        "type": "field"
      }]
    }]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "modify": false,
    "default": ForceOutput
  }]
};
inherits(Force, Transform, {
  transform(_, pulse2) {
    var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
    if (!sim) {
      this.value = sim = simulation(pulse2.source, _);
      sim.on("tick", rerun(pulse2.dataflow, this));
      if (!_.static) {
        change2 = true;
        sim.tick();
      }
      pulse2.modifies("index");
    } else {
      if (change2) {
        pulse2.modifies("index");
        sim.nodes(pulse2.source);
      }
      if (params2 || pulse2.changed(pulse2.MOD)) {
        setup(sim, _, 0, pulse2);
      }
    }
    if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0; ) sim.tick();
      } else {
        if (sim.stopped()) sim.restart();
        if (!change2) return pulse2.StopPropagation;
      }
    }
    return this.finish(_, pulse2);
  },
  finish(_, pulse2) {
    const dataflow = pulse2.dataflow;
    for (let args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== "link") {
        continue;
      }
      for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
        if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }
    return pulse2.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = simulation_default(nodes), stop3 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop3());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array(_.forces), i, n, p, name4;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p)) sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name4 = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name4) : null;
    if (p) sim.force(name4, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k2, v;
  for (k2 in f) {
    if (isFunction(v = f[k2]) && pulse2.modified(accessorFields(v))) return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has(ForceMap, _.force)) {
    error("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction(f[p])) setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f(isFunction(v) ? (d) => v(d, _) : v);
}

// node_modules/vega-hierarchy/build/vega-hierarchy.module.js
var vega_hierarchy_module_exports = {};
__export(vega_hierarchy_module_exports, {
  nest: () => Nest,
  pack: () => Pack,
  partition: () => Partition,
  stratify: () => Stratify,
  tree: () => Tree,
  treelinks: () => TreeLinks,
  treemap: () => Treemap
});
function lookup3(tree, key2, filter3) {
  const map2 = {};
  tree.each((node) => {
    const t2 = node.data;
    if (filter3(t2)) map2[key2(t2)] = node;
  });
  tree.lookup = map2;
  return tree;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
Nest.Definition = {
  "type": "Nest",
  "metadata": {
    "treesource": true,
    "changes": true
  },
  "params": [{
    "name": "keys",
    "type": "field",
    "array": true
  }, {
    "name": "generate",
    "type": "boolean"
  }]
};
var children = (n) => n.values;
inherits(Nest, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Nest transform requires an upstream data source.");
    }
    var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree = this.value;
    if (!tree || mod || pulse2.changed()) {
      if (tree) {
        tree.each((node) => {
          if (node.children && isTuple(node.data)) {
            out.rem.push(node.data);
          }
        });
      }
      this.value = tree = hierarchy({
        values: array(_.keys).reduce((n, k2) => {
          n.key(k2);
          return n;
        }, nest()).entries(out.source)
      }, children);
      if (gen) {
        tree.each((node) => {
          if (node.children) {
            node = ingest$1(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      }
      lookup3(tree, tupleid, tupleid);
    }
    out.source.root = tree;
    return out;
  }
});
function nest() {
  const keys5 = [], nest2 = {
    entries: (array4) => entries3(apply3(array4, 0), 0),
    key: (d) => (keys5.push(d), nest2)
  };
  function apply3(array4, depth) {
    if (depth >= keys5.length) {
      return array4;
    }
    const n = array4.length, key2 = keys5[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value3, values5;
    while (++i < n) {
      keyValue = key2(value3 = array4[i]) + "";
      if (values5 = valuesByKey[keyValue]) {
        values5.push(value3);
      } else {
        valuesByKey[keyValue] = [value3];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply3(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries3(map2, depth) {
    if (++depth > keys5.length) return map2;
    const array4 = [];
    for (const key2 in map2) {
      array4.push({
        key: key2,
        values: entries3(map2[key2], depth)
      });
    }
    return array4;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
var defaultSeparation = (a, b2) => a.parent === b2.parent ? 1 : 2;
inherits(HierarchyLayout, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source || !pulse2.source.root) {
      error(this.constructor.name + " transform requires a backing tree data source.");
    }
    const layout = this.layout(_.method), fields = this.fields, root = pulse2.source.root, as = _.as || fields;
    if (_.field) root.sum(_.field);
    else root.count();
    if (_.sort) root.sort(stableCompare(_.sort, (d) => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : one);
    }
    try {
      this.value = layout(root);
    } catch (err) {
      error(err);
    }
    root.each((node) => setFields(node, fields, as));
    return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
  }
});
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _) layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t2 = node.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t2[as[i]] = node[fields[i]];
  }
  t2[as[n]] = node.children ? node.children.length : 0;
}
var Output$3 = ["x", "y", "r", "depth", "children"];
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
Pack.Definition = {
  "type": "Pack",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "radius",
    "type": "field",
    "default": null
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$3.length,
    "default": Output$3
  }]
};
inherits(Pack, HierarchyLayout, {
  layout: pack_default,
  params: ["radius", "size", "padding"],
  fields: Output$3
});
var Output$2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
Partition.Definition = {
  "type": "Partition",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$2.length,
    "default": Output$2
  }]
};
inherits(Partition, HierarchyLayout, {
  layout: partition_default,
  params: ["size", "round", "padding"],
  fields: Output$2
});
function Stratify(params2) {
  Transform.call(this, null, params2);
}
Stratify.Definition = {
  "type": "Stratify",
  "metadata": {
    "treesource": true
  },
  "params": [{
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "parentKey",
    "type": "field",
    "required": true
  }]
};
inherits(Stratify, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Stratify transform requires an upstream data source.");
    }
    let tree = this.value;
    const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
    out.source = out.source.slice();
    if (run2) {
      tree = out.source.length ? lookup3(stratify_default().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup3(stratify_default()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree;
    return out;
  }
});
var Layouts = {
  tidy: tree_default,
  cluster: cluster_default
};
var Output$1 = ["x", "y", "depth", "children"];
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
Tree.Definition = {
  "type": "Tree",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "tidy",
    "values": ["tidy", "cluster"]
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "nodeSize",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "separation",
    "type": "boolean",
    "default": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$1.length,
    "default": Output$1
  }]
};
inherits(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method2) {
    const m = method2 || "tidy";
    if (has(Layouts, m)) return Layouts[m]();
    else error("Unrecognized Tree layout method: " + m);
  },
  params: ["size", "nodeSize"],
  fields: Output$1
});
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
TreeLinks.Definition = {
  "type": "TreeLinks",
  "metadata": {
    "tree": true,
    "generates": true,
    "changes": true
  },
  "params": []
};
inherits(TreeLinks, Transform, {
  transform(_, pulse2) {
    const links = this.value, tree = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
    if (!tree) error("TreeLinks transform requires a tree data source.");
    if (pulse2.changed(pulse2.ADD_REM)) {
      out.rem = links;
      pulse2.visit(pulse2.SOURCE, (t2) => lut[tupleid(t2)] = 1);
      tree.each((node) => {
        const t2 = node.data, p = node.parent && node.parent.data;
        if (p && lut[tupleid(t2)] && lut[tupleid(p)]) {
          out.add.push(ingest$1({
            source: p,
            target: t2
          }));
        }
      });
      this.value = out.add;
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t2) => lut[tupleid(t2)] = 1);
      links.forEach((link) => {
        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {
          out.mod.push(link);
        }
      });
    }
    return out;
  }
});
var Tiles = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  slicedice: sliceDice_default,
  squarify: squarify_default,
  resquarify: resquarify_default
};
var Output2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
Treemap.Definition = {
  "type": "Treemap",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "squarify",
    "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingInner",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingOuter",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingTop",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingRight",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingBottom",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingLeft",
    "type": "number",
    "default": 0
  }, {
    "name": "ratio",
    "type": "number",
    "default": 1.618033988749895
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output2.length,
    "default": Output2
  }]
};
inherits(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x2 = treemap_default();
    x2.ratio = (_) => {
      const t2 = x2.tile();
      if (t2.ratio) x2.tile(t2.ratio(_));
    };
    x2.method = (_) => {
      if (has(Tiles, _)) x2.tile(Tiles[_]);
      else error("Unrecognized Treemap layout method: " + _);
    };
    return x2;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Output2
});

// node_modules/vega-label/build/vega-label.module.js
var vega_label_module_exports = {};
__export(vega_label_module_exports, {
  label: () => Label
});
var ALPHA_MASK = 4278190080;
function baseBitmaps($2, data3) {
  const bitmap = $2.bitmap();
  (data3 || []).forEach((d) => bitmap.set($2(d.boundary[0]), $2(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($2, baseMark, avoidMarks, labelInside, isGroupArea) {
  const width2 = $2.width, height2 = $2.height, border = labelInside || isGroupArea, context3 = domCanvas(width2, height2).getContext("2d"), baseMarkContext = domCanvas(width2, height2).getContext("2d"), strokeContext = border && domCanvas(width2, height2).getContext("2d");
  avoidMarks.forEach((items) => draw2(context3, items, false));
  draw2(baseMarkContext, baseMark, false);
  if (border) {
    draw2(strokeContext, baseMark, true);
  }
  const buffer = getBuffer(context3, width2, height2), baseMarkBuffer = getBuffer(baseMarkContext, width2, height2), strokeBuffer = border && getBuffer(strokeContext, width2, height2), layer1 = $2.bitmap(), layer2 = border && $2.bitmap();
  let x2, y2, u, v, index3, alpha, strokeAlpha, baseMarkAlpha;
  for (y2 = 0; y2 < height2; ++y2) {
    for (x2 = 0; x2 < width2; ++x2) {
      index3 = y2 * width2 + x2;
      alpha = buffer[index3] & ALPHA_MASK;
      baseMarkAlpha = baseMarkBuffer[index3] & ALPHA_MASK;
      strokeAlpha = border && strokeBuffer[index3] & ALPHA_MASK;
      if (alpha || strokeAlpha || baseMarkAlpha) {
        u = $2(x2);
        v = $2(y2);
        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v);
        if (border && (alpha || strokeAlpha)) layer2.set(u, v);
      }
    }
  }
  return [layer1, layer2];
}
function getBuffer(context3, width2, height2) {
  return new Uint32Array(context3.getImageData(0, 0, width2, height2).data.buffer);
}
function draw2(context3, items, interior) {
  if (!items.length) return;
  const type3 = items[0].mark.marktype;
  if (type3 === "group") {
    items.forEach((group2) => {
      group2.items.forEach((mark2) => draw2(context3, mark2.items, interior));
    });
  } else {
    Marks[type3].draw(context3, {
      items: interior ? items.map(prepare) : items
    });
  }
}
function prepare(source4) {
  const item = rederive(source4, {});
  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {
    return {
      ...item,
      strokeOpacity: 1,
      stroke: "#000",
      fillOpacity: 0
    };
  }
  return item;
}
var DIV = 5;
var MOD2 = 31;
var SIZE = 32;
var RIGHT0 = new Uint32Array(SIZE + 1);
var RIGHT1 = new Uint32Array(SIZE + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap(w4, h2) {
  const array4 = new Uint32Array(~~((w4 * h2 + SIZE) / SIZE));
  function _set(index3, mask) {
    array4[index3] |= mask;
  }
  function _clear(index3, mask) {
    array4[index3] &= mask;
  }
  return {
    array: array4,
    get: (x2, y2) => {
      const index3 = y2 * w4 + x2;
      return array4[index3 >>> DIV] & 1 << (index3 & MOD2);
    },
    set: (x2, y2) => {
      const index3 = y2 * w4 + x2;
      _set(index3 >>> DIV, 1 << (index3 & MOD2));
    },
    clear: (x2, y2) => {
      const index3 = y2 * w4 + x2;
      _clear(index3 >>> DIV, ~(1 << (index3 & MOD2)));
    },
    getRange: (x2, y2, x22, y22) => {
      let r2 = y22, start, end, indexStart, indexEnd;
      for (; r2 >= y2; --r2) {
        start = r2 * w4 + x2;
        end = r2 * w4 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array4[indexStart] & RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]) {
            return true;
          }
        } else {
          if (array4[indexStart] & RIGHT0[start & MOD2]) return true;
          if (array4[indexEnd] & RIGHT1[(end & MOD2) + 1]) return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array4[i]) return true;
          }
        }
      }
      return false;
    },
    setRange: (x2, y2, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y2 <= y22; ++y2) {
        start = y2 * w4 + x2;
        end = y2 * w4 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD2]);
          _set(indexEnd, RIGHT1[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 4294967295);
        }
      }
    },
    clearRange: (x2, y2, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y2 <= y22; ++y2) {
        start = y2 * w4 + x2;
        end = y2 * w4 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD2] | RIGHT0[(end & MOD2) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD2]);
          _clear(indexEnd, RIGHT0[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
        }
      }
    },
    outOfBounds: (x2, y2, x22, y22) => x2 < 0 || y2 < 0 || y22 >= h2 || x22 >= w4
  };
}
function scaler(width2, height2, padding3) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w4 = ~~((width2 + 2 * padding3 + ratio) / ratio), h2 = ~~((height2 + 2 * padding3 + ratio) / ratio), scale6 = (_) => ~~((_ + padding3) / ratio);
  scale6.invert = (_) => _ * ratio - padding3;
  scale6.bitmap = () => Bitmap(w4, h2);
  scale6.ratio = ratio;
  scale6.padding = padding3;
  scale6.width = width2;
  scale6.height = height2;
  return scale6;
}
function placeAreaLabelNaive($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height;
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      x3 = (x12 + x2) / 2;
      y3 = (y12 + y2) / 2;
      areaWidth = Math.abs(x2 - x12 + y2 - y12);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x3;
        d.y = y3;
      }
    }
    x3 = textWidth / 2;
    y3 = textHeight / 2;
    x12 = d.x - x3;
    x2 = d.x + x3;
    y12 = d.y - y3;
    y2 = d.y + y3;
    d.align = "center";
    if (x12 < 0 && x2 <= width2) {
      d.align = "left";
    } else if (0 <= x12 && width2 < x2) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y12 < 0 && y2 <= height2) {
      d.baseline = "top";
    } else if (0 <= y12 && height2 < y2) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x2, y2, textWidth, textHeight, width2, height2) {
  let r2 = textWidth / 2;
  return x2 - r2 < 0 || x2 + r2 > width2 || y2 - (r2 = textHeight / 2) < 0 || y2 + r2 > height2;
}
function collision($2, x2, y2, textHeight, textWidth, h2, bm0, bm1) {
  const w4 = textWidth * h2 / (textHeight * 2), x12 = $2(x2 - w4), x22 = $2(x2 + w4), y12 = $2(y2 - (h2 = h2 / 2)), y22 = $2(y2 + h2);
  return bm0.outOfBounds(x12, y12, x22, y22) || bm0.getRange(x12, y12, x22, y22) || bm1 && bm1.getRange(x12, y12, x22, y22);
}
function placeAreaLabelReducedSearch($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x3, _y3, maxSize, textWidth, textHeight) {
    const x2 = $2.invert(_x3), y2 = $2.invert(_y3);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x2, y2, textWidth, textHeight, width2, height2) && !collision($2, x2, y2, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x2, y2, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($2, x2, y2, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x2, y2, lo, true];
      }
    }
  }
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x3, _y3, _x1, _xMid, _x22, _y1, _yMid, _y22, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      if (x12 > x2) {
        swapTmp = x12;
        x12 = x2;
        x2 = swapTmp;
      }
      if (y12 > y2) {
        swapTmp = y12;
        y12 = y2;
        y2 = swapTmp;
      }
      _x1 = $2(x12);
      _x22 = $2(x2);
      _xMid = ~~((_x1 + _x22) / 2);
      _y1 = $2(y12);
      _y22 = $2(y2);
      _yMid = ~~((_y1 + _y22) / 2);
      for (_x3 = _xMid; _x3 >= _x1; --_x3) {
        for (_y3 = _yMid; _y3 >= _y1; --_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x3 = _xMid; _x3 <= _x22; ++_x3) {
        for (_y3 = _yMid; _y3 <= _y22; ++_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x2 - x12 + y2 - y12);
        x3 = (x12 + x2) / 2;
        y3 = (y12 + y2) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x3;
          d.y = y3;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x3 = textWidth / 2;
      y3 = textHeight / 2;
      bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var X_DIR = [-1, -1, 1, 1];
var Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $2.bitmap();
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text), stack2 = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x3, _y3, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      stack2.push([$2((x12 + x2) / 2), $2((y12 + y2) / 2)]);
      while (stack2.length) {
        [_x3, _y3] = stack2.pop();
        if (bm0.get(_x3, _y3) || bm1.get(_x3, _y3) || bm2.get(_x3, _y3)) continue;
        bm2.set(_x3, _y3);
        for (let j = 0; j < 4; ++j) {
          x3 = _x3 + X_DIR[j];
          y3 = _y3 + Y_DIR[j];
          if (!bm2.outOfBounds(x3, y3, x3, y3)) stack2.push([x3, y3]);
        }
        x3 = $2.invert(_x3);
        y3 = $2.invert(_y3);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($2, x3, y3, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x3;
            d.y = y3;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x2 - x12 + y2 - y12);
        x3 = (x12 + x2) / 2;
        y3 = (y12 + y2) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x3;
          d.y = y3;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x3 = textWidth / 2;
      y3 = textHeight / 2;
      bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var Aligns = ["right", "center", "left"];
var Baselines = ["bottom", "middle", "top"];
function placeMarkLabel($2, bitmaps, anchors, offsets2) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = d.textWidth ?? 0, dx, dy, isInside, sizeFactor, insideFactor, x12, x2, y12, y2, xc, yc, _x1, _x22, _y1, _y22;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x12 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y12 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $2(x12);
      _y1 = $2(y12);
      _y22 = $2(y2);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y22, bm0, bm1, x12, x12, y12, y2, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics.width(d.datum, d.datum.text);
        }
      }
      xc = x12 + insideFactor * textWidth * dx / 2;
      x12 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $2(x12);
      _x22 = $2(x2);
      if (test(_x1, _x22, _y1, _y22, bm0, bm1, x12, x2, y12, y2, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x12;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y12;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x22, _y22);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x22, _y1, _y22, bm0, bm1, x12, x2, y12, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x22, _y22) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x22, _y22));
}
var TOP = 0;
var MIDDLE = 4;
var BOTTOM = 8;
var LEFT = 0;
var CENTER = 1;
var RIGHT = 2;
var anchorCode = {
  "top-left": TOP + LEFT,
  "top": TOP + CENTER,
  "top-right": TOP + RIGHT,
  "left": MIDDLE + LEFT,
  "middle": MIDDLE + CENTER,
  "right": MIDDLE + RIGHT,
  "bottom-left": BOTTOM + LEFT,
  "bottom": BOTTOM + CENTER,
  "bottom-right": BOTTOM + RIGHT
};
var placeAreaLabel = {
  "naive": placeAreaLabelNaive,
  "reduced-search": placeAreaLabelReducedSearch,
  "floodfill": placeAreaLabelFloodFill
};
function labelLayout(texts, size, compare5, offset4, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding3, method2) {
  if (!texts.length) return texts;
  const positions = Math.max(offset4.length, anchor.length), offsets2 = getOffsets(offset4, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), infPadding = padding3 === null || padding3 === Infinity, isNaiveGroupArea = isGroupArea && method2 === "naive";
  let maxTextWidth = -1, maxTextHeight = -1;
  const data3 = texts.map((d) => {
    const textWidth = infPadding ? textMetrics.width(d, d.text) : void 0;
    maxTextWidth = Math.max(maxTextWidth, textWidth);
    maxTextHeight = Math.max(maxTextHeight, d.fontSize);
    return {
      datum: d,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: boundary(d),
      textWidth
    };
  });
  padding3 = padding3 === null || padding3 === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset4) : padding3;
  const $2 = scaler(size[0], size[1], padding3);
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare5) {
      data3.sort((a, b2) => compare5(a.datum, b2.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map((d) => d.datum);
    bitmaps = avoidMarks.length || baseMark ? markBitmaps($2, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($2, avoidBaseMark && data3);
  }
  const place = isGroupArea ? placeAreaLabel[method2]($2, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($2, bitmaps, anchors, offsets2);
  data3.forEach((d) => d.opacity = +place(d));
  return data3;
}
function getOffsets(_, count) {
  const offsets2 = new Float64Array(count), n = _.length;
  for (let i = 0; i < n; ++i) offsets2[i] = _[i] || 0;
  for (let i = n; i < count; ++i) offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count) {
  const anchors = new Int8Array(count), n = _.length;
  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === "start" ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b2 = d.datum.bounds;
      return [b2.x1, (b2.x1 + b2.x2) / 2, b2.x2, b2.y1, (b2.y1 + b2.y2) / 2, b2.y2];
    };
  }
}
var Output3 = ["x", "y", "opacity", "align", "baseline"];
var Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Label(params2) {
  Transform.call(this, null, params2);
}
Label.Definition = {
  type: "Label",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: true,
    default: Anchors
  }, {
    name: "offset",
    type: "number",
    array: true,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: true
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: true
  }, {
    name: "avoidMarks",
    type: "data",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output3.length,
    default: Output3
  }]
};
inherits(Label, Transform, {
  transform(_, pulse2) {
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort"))) return;
    if (!_.size || _.size.length !== 2) {
      error("Size parameter should be specified as a [width, height] array.");
    }
    const as = _.as || Output3;
    labelLayout(pulse2.materialize(pulse2.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || "end", _.markIndex || 0, _.padding === void 0 ? 0 : _.padding, _.method || "naive").forEach((l) => {
      const t2 = l.datum;
      t2[as[0]] = l.x;
      t2[as[1]] = l.y;
      t2[as[2]] = l.opacity;
      t2[as[3]] = l.align;
      t2[as[4]] = l.baseline;
    });
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-regression/build/vega-regression.module.js
var vega_regression_module_exports = {};
__export(vega_regression_module_exports, {
  loess: () => Loess,
  regression: () => Regression
});
function partition4(data3, groupby) {
  var groups = [], get6 = function(f) {
    return f(t2);
  }, map2, i, n, t2, k2, g;
  if (groupby == null) {
    groups.push(data3);
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t2 = data3[i];
      k2 = groupby.map(get6);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        g.dims = k2;
        groups.push(g);
      }
      g.push(t2);
    }
  }
  return groups;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
Loess.Definition = {
  "type": "Loess",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0.3
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Loess, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source4, _.groupby), names = (_.groupby || []).map(accessorName), m = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values5 = [];
      groups.forEach((g) => {
        loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
          const t2 = {};
          for (let i = 0; i < m; ++i) {
            t2[names[i]] = g.dims[i];
          }
          t2[as[0]] = p[0];
          t2[as[1]] = p[1];
          values5.push(ingest$1(t2));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values5;
    }
    return out;
  }
});
var Methods2 = {
  constant: constant2,
  linear: linear2,
  log: log3,
  exp: exp2,
  pow: pow3,
  quad,
  poly
};
var degreesOfFreedom = (method2, order) => method2 === "poly" ? order : method2 === "quad" ? 2 : 1;
function Regression(params2) {
  Transform.call(this, null, params2);
}
Regression.Definition = {
  "type": "Regression",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "string",
    "default": "linear",
    "values": Object.keys(Methods2)
  }, {
    "name": "order",
    "type": "number",
    "default": 3
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "params",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Regression, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source4, _.groupby), names = (_.groupby || []).map(accessorName), method2 = _.method || "linear", order = _.order == null ? 3 : _.order, dof = degreesOfFreedom(method2, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit2 = Methods2[method2], values5 = [];
      let domain4 = _.extent;
      if (!has(Methods2, method2)) {
        error("Invalid regression method: " + method2);
      }
      if (domain4 != null) {
        if (method2 === "log" && domain4[0] <= 0) {
          pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
          domain4 = null;
        }
      }
      groups.forEach((g) => {
        const n = g.length;
        if (n <= dof) {
          pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const model = fit2(g, _.x, _.y, order);
        if (_.params) {
          values5.push(ingest$1({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain4 || extent(g, _.x), add5 = (p) => {
          const t2 = {};
          for (let i = 0; i < names.length; ++i) {
            t2[names[i]] = g.dims[i];
          }
          t2[as[0]] = p[0];
          t2[as[1]] = p[1];
          values5.push(ingest$1(t2));
        };
        if (method2 === "linear" || method2 === "constant") {
          dom.forEach((x2) => add5([x2, model.predict(x2)]));
        } else {
          sampleCurve(model.predict, dom, 25, 200).forEach(add5);
        }
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values5;
    }
    return out;
  }
});

// node_modules/vega-voronoi/build/vega-voronoi.module.js
var vega_voronoi_module_exports = {};
__export(vega_voronoi_module_exports, {
  voronoi: () => Voronoi
});
function Voronoi(params2) {
  Transform.call(this, null, params2);
}
Voronoi.Definition = {
  "type": "Voronoi",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "default": [[-1e5, -1e5], [1e5, 1e5]],
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
var defaultExtent = [-1e5, -1e5, 1e5, 1e5];
inherits(Voronoi, Transform, {
  transform(_, pulse2) {
    const as = _.as || "path", data3 = pulse2.source;
    if (!data3 || !data3.length) return pulse2;
    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = Delaunay.from(data3, _.x, _.y).voronoi(s);
    for (let i = 0, n = data3.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data3[i][as] = polygon && !isPoint(polygon) ? toPathString(polygon) : null;
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function toPathString(p) {
  const x2 = p[0][0], y2 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x2 && p[n][1] === y2; --n) ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}
function isPoint(p) {
  return p.length === 2 && p[0][0] === p[1][0] && p[0][1] === p[1][1];
}

// node_modules/vega-wordcloud/build/vega-wordcloud.module.js
var vega_wordcloud_module_exports = {};
__export(vega_wordcloud_module_exports, {
  wordcloud: () => Wordcloud
});
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloud() {
  var size = [256, 256], text4, font3, fontSize2, fontStyle, fontWeight, rotate2, padding3, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds2 = null, n = words.length, i = -1, tags = [], data3 = words.map((d2) => ({
      text: text4(d2),
      font: font3(d2),
      style: fontStyle(d2),
      weight: fontWeight(d2),
      rotate: rotate2(d2),
      size: ~~(fontSize2(d2) + 1e-14),
      padding: padding3(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a, b2) => b2.size - a.size);
    while (++i < n) {
      var d = data3[i];
      d.x = size[0] * (random2() + 0.5) >> 1;
      d.y = size[1] * (random2() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data3, i);
      if (d.hasText && place(board, d, bounds2)) {
        tags.push(d);
        if (bounds2) cloudBounds(bounds2, d);
        else bounds2 = [{
          x: d.x + d.x0,
          y: d.y + d.y0
        }, {
          x: d.x + d.x1,
          y: d.y + d.y1
        }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context3 = canvas.getContext("2d");
    context3.fillStyle = context3.strokeStyle = "red";
    context3.textAlign = "center";
    return {
      context: context3,
      ratio
    };
  }
  function place(board, tag, bounds2) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.hypot(size[0], size[1]), s = spiral(size), dt = random2() < 0.5 ? 1 : -1, t2 = -dt, dxdy, dx, dy;
    while (dxdy = s(t2 += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
      if (!bounds2 || !cloudCollide(tag, board, size[0])) {
        if (!bounds2 || collideRects(tag, bounds2)) {
          var sprite = tag.sprite, w4 = tag.width >> 5, sw = size[0] >> 5, lx2 = tag.x - (w4 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
          for (var j = 0; j < h2; j++) {
            last = 0;
            for (var i = 0; i <= w4; i++) {
              board[x2 + i] |= last << msx | (i < w4 ? (last = sprite[j * w4 + i]) >>> sx : 0);
            }
            x2 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font3 = functor(_);
      return cloud2;
    } else {
      return font3;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud2;
    } else {
      return fontWeight;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate2 = functor(_);
      return cloud2;
    } else {
      return rotate2;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text4 = functor(_);
      return cloud2;
    } else {
      return text4;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize2 = functor(_);
      return cloud2;
    } else {
      return fontSize2;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding3 = functor(_);
      return cloud2;
    } else {
      return padding3;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random2 = _;
      return cloud2;
    } else {
      return random2;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data3, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x2 = 0, y2 = 0, maxh = 0, n = data3.length, w4, w32, h2, i, j;
  --di;
  while (++di < n) {
    d = data3[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w4 = c.measureText(d.text + "m").width * ratio;
    h2 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr2 = Math.cos(d.rotate * cloudRadians), wcr = w4 * cr2, wsr = w4 * sr, hcr = h2 * cr2, hsr = h2 * sr;
      w4 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w4 = w4 + 31 >> 5 << 5;
    }
    if (h2 > maxh) maxh = h2;
    if (x2 + w4 >= cw << 5) {
      x2 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h2 >= ch) break;
    c.translate((x2 + (w4 >> 1)) / ratio, (y2 + (h2 >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }
    c.restore();
    d.width = w4;
    d.height = h2;
    d.xoff = x2;
    d.yoff = y2;
    d.x1 = w4 >> 1;
    d.y1 = h2 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x2 += w4;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data3[di];
    if (!d.hasText) continue;
    w4 = d.width;
    w32 = w4 >> 5;
    h2 = d.y1 - d.y0;
    for (i = 0; i < h2 * w32; i++) sprite[i] = 0;
    x2 = d.xoff;
    if (x2 == null) return;
    y2 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h2; j++) {
      for (i = 0; i < w4; i++) {
        var k2 = w32 * j + (i >> 5), m = pixels[(y2 + j) * (cw << 5) + (x2 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k2] |= m;
        seen |= m;
      }
      if (seen) seenRow = j;
      else {
        d.y0++;
        h2--;
        j--;
        y2++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w4 = tag.width >> 5, lx2 = tag.x - (w4 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
  for (var j = 0; j < h2; j++) {
    last = 0;
    for (var i = 0; i <= w4; i++) {
      if ((last << msx | (i < w4 ? (last = sprite[j * w4 + i]) >>> sx : 0)) & board[x2 + i]) return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds2, d) {
  var b0 = bounds2[0], b1 = bounds2[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}
function collideRects(a, b2) {
  return a.x + a.x1 > b2[0].x && a.x + a.x0 < b2[1].x && a.y + a.y1 > b2[0].y && a.y + a.y0 < b2[1].y;
}
function archimedeanSpiral(size) {
  var e2 = size[0] / size[1];
  return function(t2) {
    return [e2 * (t2 *= 0.1) * Math.cos(t2), t2 * Math.sin(t2)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x2 = 0, y2 = 0;
  return function(t2) {
    var sign2 = t2 < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign2 * t2) - sign2 & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x2, y2];
  };
}
function zeroArray(n) {
  var a = [], i = -1;
  while (++i < n) a[i] = 0;
  return a;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var Output4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
var Params2 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
Wordcloud.Definition = {
  "type": "Wordcloud",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "font",
    "type": "string",
    "expr": true,
    "default": "sans-serif"
  }, {
    "name": "fontStyle",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontWeight",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontSize",
    "type": "number",
    "expr": true,
    "default": 14
  }, {
    "name": "fontSizeRange",
    "type": "number",
    "array": "nullable",
    "default": [10, 50]
  }, {
    "name": "rotate",
    "type": "number",
    "expr": true,
    "default": 0
  }, {
    "name": "text",
    "type": "field"
  }, {
    "name": "spiral",
    "type": "string",
    "values": ["archimedean", "rectangular"]
  }, {
    "name": "padding",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 7,
    "default": Output4
  }]
};
inherits(Wordcloud, Transform, {
  transform(_, pulse2) {
    if (_.size && !(_.size[0] && _.size[1])) {
      error("Wordcloud size dimensions must be non-zero.");
    }
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params2.some(modp))) return;
    const data3 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output4;
    let fontSize2 = _.fontSize || 14, range6;
    isFunction(fontSize2) ? range6 = _.fontSizeRange : fontSize2 = constant(fontSize2);
    if (range6) {
      const fsize = fontSize2, sizeScale = scale("sqrt")().domain(extent(data3, fsize)).range(range6);
      fontSize2 = (x2) => sizeScale(fsize(x2));
    }
    data3.forEach((t2) => {
      t2[as[0]] = NaN;
      t2[as[1]] = NaN;
      t2[as[3]] = 0;
    });
    const words = layout.words(data3).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize2).random(random).layout();
    const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
    for (let i = 0, w4, t2; i < n; ++i) {
      w4 = words[i];
      t2 = w4.datum;
      t2[as[0]] = w4.x + dx;
      t2[as[1]] = w4.y + dy;
      t2[as[2]] = w4.font;
      t2[as[3]] = w4.size;
      t2[as[4]] = w4.style;
      t2[as[5]] = w4.weight;
      t2[as[6]] = w4.rotate;
    }
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-crossfilter/build/vega-crossfilter.module.js
var vega_crossfilter_module_exports = {};
__export(vega_crossfilter_module_exports, {
  crossfilter: () => CrossFilter,
  resolvefilter: () => ResolveFilter
});
var array8 = (n) => new Uint8Array(n);
var array16 = (n) => new Uint16Array(n);
var array32 = (n) => new Uint32Array(n);
function Bitmaps() {
  let width2 = 8, data3 = [], seen = array32(0), curr = array2(0, width2), prev = array2(0, width2);
  return {
    data: () => data3,
    seen: () => seen = lengthen(seen, data3.length),
    add(array4) {
      for (let i = 0, j = data3.length, n = array4.length, t2; i < n; ++i) {
        t2 = array4[i];
        t2._index = j++;
        data3.push(t2);
      }
    },
    remove(num, map2) {
      const n = data3.length, copy2 = Array(n - num), reindex = data3;
      let t2, i, j;
      for (i = 0; !map2[i] && i < n; ++i) {
        copy2[i] = data3[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t2 = data3[i];
        if (!map2[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy2[j] = t2;
          t2._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data3 = copy2;
      return reindex;
    },
    size: () => data3.length,
    curr: () => curr,
    prev: () => prev,
    reset: (k2) => prev[k2] = curr[k2],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k2, one3) {
      curr[k2] |= one3;
    },
    clear(k2, one3) {
      curr[k2] &= ~one3;
    },
    resize(n, m) {
      const k2 = curr.length;
      if (n > k2 || m > width2) {
        width2 = Math.max(m, width2);
        curr = array2(n, width2, curr);
        prev = array2(n, width2);
      }
    }
  };
}
function lengthen(array4, length3, copy2) {
  if (array4.length >= length3) return array4;
  copy2 = copy2 || new array4.constructor(length3);
  copy2.set(array4);
  return copy2;
}
function array2(n, m, array4) {
  const copy2 = (m < 257 ? array8 : m < 65537 ? array16 : array32)(n);
  if (array4) copy2.set(array4);
  return copy2;
}
function Dimension(index3, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index3.bisect,
    index: index3.index,
    size: index3.size,
    onAdd(added, curr) {
      const dim = this, range6 = dim.bisect(dim.range, added.value), idx = added.index, lo = range6[0], hi = range6[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2) curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2) curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index3 = array32(0), value3 = [], size = 0;
  function insert3(key2, data3, base) {
    if (!data3.length) return [];
    const n0 = size, n1 = data3.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key2(data3[i]);
      addi[i] = i;
    }
    addv = sort(addv, addi);
    if (n0) {
      oldv = value3;
      oldi = index3;
      value3 = Array(n0 + n1);
      index3 = array32(n0 + n1);
      merge3(base, oldv, oldi, n0, addv, addi, n1, value3, index3);
    } else {
      if (base > 0) for (i = 0; i < n1; ++i) {
        addi[i] += base;
      }
      value3 = addv;
      index3 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove2(num, map2) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map2[index3[i]] && i < n; ++i) ;
    for (j = i; i < n; ++i) {
      if (!map2[idx = index3[i]]) {
        index3[j] = idx;
        value3[j] = value3[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map2) {
    for (let i = 0, n = size; i < n; ++i) {
      index3[i] = map2[index3[i]];
    }
  }
  function bisect2(range6, array4) {
    let n;
    if (array4) {
      n = array4.length;
    } else {
      array4 = value3;
      n = size;
    }
    return [bisectLeft(array4, range6[0], 0, n), bisectRight(array4, range6[1], 0, n)];
  }
  return {
    insert: insert3,
    remove: remove2,
    bisect: bisect2,
    reindex,
    index: () => index3,
    size: () => size
  };
}
function sort(values5, index3) {
  values5.sort.call(index3, (a, b2) => {
    const x2 = values5[a], y2 = values5[b2];
    return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
  });
  return permute(values5, index3);
}
function merge3(base, value0, index0, n0, value1, index1, n1, value3, index3) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value3[i] = value0[i0];
      index3[i] = index0[i0++];
    } else {
      value3[i] = value1[i1];
      index3[i] = index1[i1++] + base;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value3[i] = value0[i0];
    index3[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value3[i] = value1[i1];
    index3[i] = index1[i1] + base;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  "type": "CrossFilter",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "query",
    "type": "array",
    "array": true,
    "required": true,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }]
};
inherits(CrossFilter, Transform, {
  transform(_, pulse2) {
    if (!this._dims) {
      return this.init(_, pulse2);
    } else {
      var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
      return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
    }
  },
  init(_, pulse2) {
    const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m = query.length;
    let i = 0, key2, index3;
    for (; i < m; ++i) {
      key2 = fields[i].fname;
      index3 = indices[key2] || (indices[key2] = SortedIndex());
      dims.push(Dimension(index3, i, query[i]));
    }
    return this.eval(_, pulse2);
  },
  reinit(_, pulse2) {
    const output3 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), out = output3.rem = output3.add, mod = output3.mod, m = query.length, adds = {};
    let add5, index3, key2, mods, remMap, modMap, i, n, f;
    prev.set(curr);
    if (pulse2.rem.length) {
      remMap = this.remove(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      bits.add(pulse2.add);
    }
    if (pulse2.mod.length) {
      modMap = {};
      for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }
    for (i = 0; i < m; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
        key2 = f.fname;
        if (!(add5 = adds[key2])) {
          indices[key2] = index3 = SortedIndex();
          adds[key2] = add5 = index3.insert(f, pulse2.source, 0);
        }
        dims[i] = Dimension(index3, i, query[i]).onAdd(add5, curr);
      }
    }
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        continue;
      } else if (prev[i] !== curr[i]) {
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        mod.push(i);
      }
    }
    bits.mask = (1 << m) - 1;
    return output3;
  },
  eval(_, pulse2) {
    const output3 = pulse2.materialize().fork(), m = this._dims.length;
    let mask = 0;
    if (pulse2.rem.length) {
      this.remove(_, pulse2, output3);
      mask |= (1 << m) - 1;
    }
    if (_.modified("query") && !_.modified("fields")) {
      mask |= this.update(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      this.insert(_, pulse2, output3);
      mask |= (1 << m) - 1;
    }
    if (pulse2.mod.length) {
      this.modify(pulse2, output3);
      mask |= (1 << m) - 1;
    }
    this.value.mask = mask;
    return output3;
  },
  insert(_, pulse2, output3) {
    const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output3.add, n = bits.size() + tuples.length, m = dims.length;
    let k2 = bits.size(), j, key2, add5;
    bits.resize(n, m);
    bits.add(tuples);
    const curr = bits.curr(), prev = bits.prev(), all = bits.all();
    for (j = 0; j < m; ++j) {
      key2 = fields[j].fname;
      add5 = adds[key2] || (adds[key2] = indices[key2].insert(fields[j], tuples, k2));
      dims[j].onAdd(add5, curr);
    }
    for (; k2 < n; ++k2) {
      prev[k2] = all;
      if (curr[k2] !== all) out.push(k2);
    }
  },
  modify(pulse2, output3) {
    const out = output3.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
    let i, n, k2;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k2 = tuples[i]._index;
      if (curr[k2] !== all) out.push(k2);
    }
  },
  remove(_, pulse2, output3) {
    const indices = this._indices, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), map2 = {}, out = output3.rem, tuples = pulse2.rem;
    let i, n, k2, f;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k2 = tuples[i]._index;
      map2[k2] = 1;
      prev[k2] = f = curr[k2];
      curr[k2] = all;
      if (f !== all) out.push(k2);
    }
    for (k2 in indices) {
      indices[k2].remove(n, map2);
    }
    this.reindex(pulse2, n, map2);
    return map2;
  },
  // reindex filters and indices after propagation completes
  reindex(pulse2, num, map2) {
    const indices = this._indices, bits = this.value;
    pulse2.runAfter(() => {
      const indexMap = bits.remove(num, map2);
      for (const key2 in indices) indices[key2].reindex(indexMap);
    });
  },
  update(_, pulse2, output3) {
    const dims = this._dims, query = _.query, stamp = pulse2.stamp, m = dims.length;
    let mask = 0, i, q;
    output3.filters = 0;
    for (q = 0; q < m; ++q) {
      if (_.modified("query", q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output3.add, output3.rem);
    } else {
      for (q = 0, mask = 0; q < m; ++q) {
        if (!_.modified("query", q)) continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output3.add);
        output3.rem = output3.add;
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev = bits.prev(), index3 = dim.index(), old = dim.bisect(dim.range), range6 = dim.bisect(query), lo1 = range6[0], hi1 = range6[1], lo0 = old[0], hi0 = old[1], one3 = dim.one;
    let i, j, k2;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k2 = index3[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k2 = index3[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k2 = index3[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k2 = index3[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add5, rem2) {
    const bits = this.value, curr = bits.curr(), index3 = dim.index(), old = dim.bisect(dim.range), range6 = dim.bisect(query), lo1 = range6[0], hi1 = range6[1], lo0 = old[0], hi0 = old[1], one3 = dim.one;
    let i, j, k2;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k2 = index3[i];
        curr[k2] ^= one3;
        add5.push(k2);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k2 = index3[i];
        curr[k2] ^= one3;
        rem2.push(k2);
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k2 = index3[i];
        curr[k2] ^= one3;
        add5.push(k2);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k2 = index3[i];
        curr[k2] ^= one3;
        rem2.push(k2);
      }
    }
    dim.range = query.slice();
  }
});
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
ResolveFilter.Definition = {
  "type": "ResolveFilter",
  "metadata": {},
  "params": [{
    "name": "ignore",
    "type": "number",
    "required": true,
    "description": "A bit mask indicating which filters to ignore."
  }, {
    "name": "filter",
    "type": "object",
    "required": true,
    "description": "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
inherits(ResolveFilter, Transform, {
  transform(_, pulse2) {
    const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
    if ((mask & ignore) === 0) return pulse2.StopPropagation;
    const output3 = pulse2.fork(pulse2.ALL), data3 = bitmap.data(), curr = bitmap.curr(), prev = bitmap.prev(), pass = (k2) => !(curr[k2] & ignore) ? data3[k2] : null;
    output3.filter(output3.MOD, pass);
    if (!(mask & mask - 1)) {
      output3.filter(output3.ADD, pass);
      output3.filter(output3.REM, (k2) => (curr[k2] & ignore) === mask ? data3[k2] : null);
    } else {
      output3.filter(output3.ADD, (k2) => {
        const c = curr[k2] & ignore, f = !c && c ^ prev[k2] & ignore;
        return f ? data3[k2] : null;
      });
      output3.filter(output3.REM, (k2) => {
        const c = curr[k2] & ignore, f = c && !(c ^ (c ^ prev[k2] & ignore));
        return f ? data3[k2] : null;
      });
    }
    return output3.filter(output3.SOURCE, (t2) => pass(t2._index));
  }
});

// node_modules/vega-expression/build/vega-expression.module.js
var RawCode = "RawCode";
var Literal = "Literal";
var Property = "Property";
var Identifier2 = "Identifier";
var ArrayExpression = "ArrayExpression";
var BinaryExpression = "BinaryExpression";
var CallExpression = "CallExpression";
var ConditionalExpression = "ConditionalExpression";
var LogicalExpression = "LogicalExpression";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var UnaryExpression = "UnaryExpression";
function ASTNode(type3) {
  this.type = type3;
}
ASTNode.prototype.visit = function(visitor) {
  let c, i, n;
  if (visitor(this)) return 1;
  for (c = children2(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};
function children2(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier2:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName;
var source2;
var index;
var length;
var lookahead;
var TokenBooleanLiteral = 1;
var TokenEOF = 2;
var TokenIdentifier = 3;
var TokenKeyword = 4;
var TokenNullLiteral = 5;
var TokenNumericLiteral = 6;
var TokenPunctuator = 7;
var TokenStringLiteral = 8;
var TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression";
var SyntaxBinaryExpression = "BinaryExpression";
var SyntaxCallExpression = "CallExpression";
var SyntaxConditionalExpression = "ConditionalExpression";
var SyntaxIdentifier = "Identifier";
var SyntaxLiteral = "Literal";
var SyntaxLogicalExpression = "LogicalExpression";
var SyntaxMemberExpression = "MemberExpression";
var SyntaxObjectExpression = "ObjectExpression";
var SyntaxProperty = "Property";
var SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0";
var MessageUnexpectedNumber = "Unexpected number";
var MessageUnexpectedString = "Unexpected string";
var MessageUnexpectedIdentifier = "Unexpected identifier";
var MessageUnexpectedReserved = "Unexpected reserved word";
var MessageUnexpectedEOS = "Unexpected end of input";
var MessageInvalidRegExp = "Invalid regular expression";
var MessageUnterminatedRegExp = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL = "ILLEGAL";
var DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".includes(ch2);
}
function isOctalDigit(ch2) {
  return "01234567".includes(ch2);
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].includes(ch2);
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 >= 48 && ch2 <= 57 || // 0..9
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
var keywords = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment() {
  while (index < length) {
    const ch2 = source2.charCodeAt(index);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source2[index])) {
      ch2 = source2[index++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source2[index];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index < length) {
    ch2 = source2[index++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id2;
  ch2 = source2.charCodeAt(index++);
  id2 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source2.charCodeAt(index) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id2 = ch2;
  }
  while (index < length) {
    ch2 = source2.charCodeAt(index);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index;
    id2 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id2 = id2.substr(0, id2.length - 1);
      if (source2.charCodeAt(index) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id2 += ch2;
    }
  }
  return id2;
}
function getIdentifier() {
  var start, ch2;
  start = index++;
  while (index < length) {
    ch2 = source2.charCodeAt(index);
    if (ch2 === 92) {
      index = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index;
    } else {
      break;
    }
  }
  return source2.slice(start, index);
}
function scanIdentifier() {
  var start, id2, type3;
  start = index;
  id2 = source2.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id2.length === 1) {
    type3 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id2)) {
    type3 = TokenKeyword;
  } else if (id2 === "null") {
    type3 = TokenNullLiteral;
  } else if (id2 === "true" || id2 === "false") {
    type3 = TokenBooleanLiteral;
  } else {
    type3 = TokenIdentifier;
  }
  return {
    type: type3,
    value: id2,
    start,
    end: index
  };
}
function scanPunctuator() {
  var start = index, code = source2.charCodeAt(index), code2, ch1 = source2[index], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index
      };
    default:
      code2 = source2.charCodeAt(index + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index
            };
          case 33:
          case 61:
            index += 2;
            if (source2.charCodeAt(index) === 61) {
              ++index;
            }
            return {
              type: TokenPunctuator,
              value: source2.slice(start, index),
              start,
              end: index
            };
        }
      }
  }
  ch4 = source2.substr(index, 4);
  if (ch4 === ">>>=") {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".includes(ch1) || ch2 === "=>") {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if ("<>=!+-*%&|^/".includes(ch1)) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}
function scanHexLiteral(start) {
  let number5 = "";
  while (index < length) {
    if (!isHexDigit(source2[index])) {
      break;
    }
    number5 += source2[index++];
  }
  if (number5.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source2.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number5, 16),
    start,
    end: index
  };
}
function scanOctalLiteral(start) {
  let number5 = "0" + source2[index++];
  while (index < length) {
    if (!isOctalDigit(source2[index])) {
      break;
    }
    number5 += source2[index++];
  }
  if (isIdentifierStart(source2.charCodeAt(index)) || isDecimalDigit(source2.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number5, 8),
    octal: true,
    start,
    end: index
  };
}
function scanNumericLiteral() {
  var number5, start, ch2;
  ch2 = source2[index];
  assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index;
  number5 = "";
  if (ch2 !== ".") {
    number5 = source2[index++];
    ch2 = source2[index];
    if (number5 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source2.charCodeAt(index))) {
      number5 += source2[index++];
    }
    ch2 = source2[index];
  }
  if (ch2 === ".") {
    number5 += source2[index++];
    while (isDecimalDigit(source2.charCodeAt(index))) {
      number5 += source2[index++];
    }
    ch2 = source2[index];
  }
  if (ch2 === "e" || ch2 === "E") {
    number5 += source2[index++];
    ch2 = source2[index];
    if (ch2 === "+" || ch2 === "-") {
      number5 += source2[index++];
    }
    if (isDecimalDigit(source2.charCodeAt(index))) {
      while (isDecimalDigit(source2.charCodeAt(index))) {
        number5 += source2[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source2.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number5),
    start,
    end: index
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source2[index];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index;
  ++index;
  while (index < length) {
    ch2 = source2[index++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source2[index++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source2[index] === "{") {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index < length && isOctalDigit(source2[index])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source2[index++]);
                if ("0123".includes(ch2) && index < length && isOctalDigit(source2[index])) {
                  code = code * 8 + "01234567".indexOf(source2[index++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source2[index] === "\n") {
          ++index;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.includes("u")) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e2) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source2[index];
  assert(ch2 === "/", "Regular expression literal must start with a slash");
  str = source2[index++];
  classMarker = false;
  terminated = false;
  while (index < length) {
    ch2 = source2[index++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source2[index++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index < length) {
    ch2 = source2[index];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index;
    if (ch2 === "\\" && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value3;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value3 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value3,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }
  const ch2 = source2.charCodeAt(index);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source2.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}
function peek2() {
  const pos = index;
  lookahead = advance();
  index = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator2, left, right) {
  const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name4) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name4;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source2.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor2, object2, property2) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor2 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed) property2.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key2, value3) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key2;
  node.value = value3;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator2, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index3) => {
    assert(index3 < args.length, "Message reference must be in range");
    return args[index3];
  });
  error2 = new Error(msg);
  error2.index = index;
  error2.description = msg;
  throw error2;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value3) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value3) {
    throwUnexpected(token);
  }
}
function match(value3) {
  return lookahead.type === TokenPunctuator && lookahead.value === value3;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key2, id2, value3;
  index = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", id2, value3);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", key2, value3);
  }
}
function parseObjectInitialiser() {
  var properties = [], property2, name4, key2, map2 = {}, toString2 = String;
  index = lookahead.start;
  expect("{");
  while (!match("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name4 = property2.key.name;
    } else {
      name4 = toString2(property2.key.value);
    }
    key2 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map2, key2)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map2[key2] = true;
    }
    properties.push(property2);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression();
  expect(")");
  return expr2;
}
var legalKeywords = {
  "if": 1
};
function parsePrimaryExpression() {
  var type3, token, expr2;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type3 = lookahead.type;
  index = lookahead.start;
  if (type3 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type3 === TokenStringLiteral || type3 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type3 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type3 === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr2 = finishLiteral(token);
  } else if (type3 === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr2 = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek2();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token, prec, stack2, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack2 = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
      right = stack2.pop();
      operator2 = stack2.pop().value;
      left = stack2.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack2.push(expr2);
    }
    token = lex();
    token.prec = prec;
    stack2.push(token);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack2.push(expr2);
  }
  i = stack2.length - 1;
  expr2 = stack2[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack2[i - 1].value, stack2[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression() {
  const expr2 = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser(code) {
  source2 = code;
  index = 0;
  length = source2.length;
  lookahead = null;
  peek2();
  const expr2 = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var Constants = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Functions(codegen2) {
  function fncall(name4, args, cast, type3) {
    let obj = codegen2(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0) obj = "(" + obj + ")";
    }
    return obj + "." + name4 + (type3 < 0 ? "" : type3 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
  }
  function fn(name4, cast, type3) {
    return (args) => fncall(name4, args, cast, type3);
  }
  const DATE2 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3) error("Missing arguments to clamp function.");
      if (args.length > 3) error("Too many arguments to clamp function.");
      const a = args.map(codegen2);
      return "Math.max(" + a[1] + ", Math.min(" + a[2] + "," + a[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE2,
    date: fn("getDate", DATE2, 0),
    day: fn("getDay", DATE2, 0),
    year: fn("getFullYear", DATE2, 0),
    month: fn("getMonth", DATE2, 0),
    hours: fn("getHours", DATE2, 0),
    minutes: fn("getMinutes", DATE2, 0),
    seconds: fn("getSeconds", DATE2, 0),
    milliseconds: fn("getMilliseconds", DATE2, 0),
    time: fn("getTime", DATE2, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE2, 0),
    utcdate: fn("getUTCDate", DATE2, 0),
    utcday: fn("getUTCDay", DATE2, 0),
    utcyear: fn("getUTCFullYear", DATE2, 0),
    utcmonth: fn("getUTCMonth", DATE2, 0),
    utchours: fn("getUTCHours", DATE2, 0),
    utcminutes: fn("getUTCMinutes", DATE2, 0),
    utcseconds: fn("getUTCSeconds", DATE2, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE2, 0),
    // sequence functions
    length: fn("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    // base64 encode/decode
    btoa: "btoa",
    atob: "atob",
    // REGEXP functions
    regexp: REGEXP,
    test: fn("test", REGEXP),
    // Control Flow functions
    if: function(args) {
      if (args.length < 3) error("Missing arguments to if function.");
      if (args.length > 3) error("Too many arguments to if function.");
      const a = args.map(codegen2);
      return "(" + a[0] + "?" + a[1] + ":" + a[2] + ")";
    }
  };
}
function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === "'" && s[n] === "'") ? s.slice(1, -1) : s;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants2 = opt.constants || Constants, functions = (opt.functions || Functions)(visit2), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction(globalvar) ? globalvar : (id2) => `${globalvar}["${id2}"]`;
  let globals = {}, fields = {}, memberDepth = 0;
  function visit2(ast) {
    if (isString(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) error("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id2 = n.name;
      if (memberDepth > 0) {
        return id2;
      } else if (has(forbidden, id2)) {
        return error("Illegal identifier: " + id2);
      } else if (has(constants2, id2)) {
        return constants2[id2];
      } else if (has(allowed, id2)) {
        return id2;
      } else {
        globals[id2] = 1;
        return outputGlobal(id2);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit2(n.object);
      if (d) memberDepth += 1;
      const p = visit2(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d) memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has(functions, callee) && functions[callee];
      if (!fn) error("Unrecognized function: " + callee);
      return isFunction(fn) ? fn(args) : fn + "(" + args.map(visit2).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit2).join(",") + "]",
    BinaryExpression: (n) => "(" + visit2(n.left) + " " + n.operator + " " + visit2(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit2(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit2(n.test) + "?" + visit2(n.consequent) + ":" + visit2(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit2(n.left) + n.operator + visit2(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit2).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k2 = visit2(n.key);
      memberDepth -= 1;
      return k2 + ":" + visit2(n.value);
    }
  };
  function codegen2(ast) {
    const result = {
      code: visit2(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen2.functions = functions;
  codegen2.constants = constants2;
  return codegen2;
}

// node_modules/vega-selections/build/vega-selection.module.js
var SELECTION_GETTER = Symbol("vega_selection_getter");
function getter2(f) {
  if (!f.getter || !f.getter[SELECTION_GETTER]) {
    f.getter = field(f.field);
    f.getter[SELECTION_GETTER] = true;
  }
  return f.getter;
}
var Intersect = "intersect";
var Union = "union";
var VlMulti = "vlMulti";
var VlPoint = "vlPoint";
var Or = "or";
var And = "and";
var SelectionId = "_vgsid_";
var $selectionId = field(SelectionId);
var TYPE_ENUM = "E";
var TYPE_RANGE_INC = "R";
var TYPE_RANGE_EXC = "R-E";
var TYPE_RANGE_LE = "R-LE";
var TYPE_RANGE_RE = "R-RE";
var TYPE_PRED_LT = "E-LT";
var TYPE_PRED_LTE = "E-LTE";
var TYPE_PRED_GT = "E-GT";
var TYPE_PRED_GTE = "E-GTE";
var TYPE_PRED_VALID = "E-VALID";
var TYPE_PRED_ONE_OF = "E-ONE";
var UNIT_INDEX = "index:unit";
function testPoint(datum2, entry2) {
  var fields = entry2.fields, values5 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    dval = getter2(f)(datum2);
    if (isDate(dval)) dval = toNumber(dval);
    if (isDate(values5[i])) values5[i] = toNumber(values5[i]);
    if (isArray(values5[i]) && isDate(values5[i][0])) values5[i] = values5[i].map(toNumber);
    if (f.type === TYPE_ENUM) {
      if (isArray(values5[i]) ? !values5[i].includes(dval) : dval !== values5[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange(dval, values5[i])) return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange(dval, values5[i], true, false)) return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange(dval, values5[i], false, false)) return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange(dval, values5[i], false, true)) return false;
      } else if (f.type === TYPE_PRED_LT) {
        if (dval >= values5[i]) return false;
      } else if (f.type === TYPE_PRED_LTE) {
        if (dval > values5[i]) return false;
      } else if (f.type === TYPE_PRED_GT) {
        if (dval <= values5[i]) return false;
      } else if (f.type === TYPE_PRED_GTE) {
        if (dval < values5[i]) return false;
      } else if (f.type === TYPE_PRED_VALID) {
        if (dval === null || isNaN(dval)) return false;
      } else if (f.type === TYPE_PRED_ONE_OF) {
        if (values5[i].indexOf(dval) === -1) return false;
      }
    }
  }
  return true;
}
function selectionTest(name4, datum2, op) {
  var data3 = this.context.data[name4], entries3 = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect4 = op === Intersect, n = entries3.length, i = 0, entry2, miss, count, unit, b2;
  for (; i < n; ++i) {
    entry2 = entries3[i];
    if (unitIdx && intersect4) {
      miss = miss || {};
      count = miss[unit = entry2.unit] || 0;
      if (count === -1) continue;
      b2 = testPoint(datum2, entry2);
      miss[unit] = b2 ? -1 : ++count;
      if (b2 && unitIdx.size === 1) return true;
      if (!b2 && count === unitIdx.get(unit).count) return false;
    } else {
      b2 = testPoint(datum2, entry2);
      if (intersect4 ^ b2) return b2;
    }
  }
  return n && intersect4;
}
var bisect = bisector($selectionId);
var bisectLeft2 = bisect.left;
var bisectRight2 = bisect.right;
function selectionIdTest(name4, datum2, op) {
  const data3 = this.context.data[name4], entries3 = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect4 = op === Intersect, value3 = $selectionId(datum2), index3 = bisectLeft2(entries3, value3);
  if (index3 === entries3.length) return false;
  if ($selectionId(entries3[index3]) !== value3) return false;
  if (unitIdx && intersect4) {
    if (unitIdx.size === 1) return true;
    if (bisectRight2(entries3, value3) - index3 < unitIdx.size) return false;
  }
  return true;
}
function selectionTuples(array4, base) {
  return array4.map((x2) => extend(base.fields ? {
    values: base.fields.map((f) => getter2(f)(x2.datum))
  } : {
    [SelectionId]: $selectionId(x2.datum)
  }, base));
}
function selectionResolve(name4, op, isMulti, vl5) {
  var data3 = this.context.data[name4], entries3 = data3 ? data3.values.value : [], resolved = {}, multiRes = {}, types4 = {}, entry2, fields, values5, unit, field3, value3, res, resUnit, type3, union2, n = entries3.length, i = 0, j, m;
  for (; i < n; ++i) {
    entry2 = entries3[i];
    unit = entry2.unit;
    fields = entry2.fields;
    values5 = entry2.values;
    if (fields && values5) {
      for (j = 0, m = fields.length; j < m; ++j) {
        field3 = fields[j];
        res = resolved[field3.field] || (resolved[field3.field] = {});
        resUnit = res[unit] || (res[unit] = []);
        types4[field3.field] = type3 = field3.type.charAt(0);
        union2 = ops[`${type3}_union`];
        res[unit] = union2(resUnit, array(values5[j]));
      }
      if (isMulti) {
        resUnit = multiRes[unit] || (multiRes[unit] = []);
        resUnit.push(array(values5).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
      }
    } else {
      field3 = SelectionId;
      value3 = $selectionId(entry2);
      res = resolved[field3] || (resolved[field3] = {});
      resUnit = res[unit] || (res[unit] = []);
      resUnit.push(value3);
      if (isMulti) {
        resUnit = multiRes[unit] || (multiRes[unit] = []);
        resUnit.push({
          [SelectionId]: value3
        });
      }
    }
  }
  op = op || Union;
  if (resolved[SelectionId]) {
    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));
  } else {
    Object.keys(resolved).forEach((field4) => {
      resolved[field4] = Object.keys(resolved[field4]).map((unit2) => resolved[field4][unit2]).reduce((acc, curr) => acc === void 0 ? curr : ops[`${types4[field4]}_${op}`](acc, curr));
    });
  }
  entries3 = Object.keys(multiRes);
  if (isMulti && entries3.length) {
    const key2 = vl5 ? VlPoint : VlMulti;
    resolved[key2] = op === Union ? {
      [Or]: entries3.reduce((acc, k2) => (acc.push(...multiRes[k2]), acc), [])
    } : {
      [And]: entries3.map((k2) => ({
        [Or]: multiRes[k2]
      }))
    };
  }
  return resolved;
}
var ops = {
  [`${SelectionId}_union`]: union,
  [`${SelectionId}_intersect`]: intersection,
  E_union: function(base, value3) {
    if (!base.length) return value3;
    var i = 0, n = value3.length;
    for (; i < n; ++i) if (!base.includes(value3[i])) base.push(value3[i]);
    return base;
  },
  E_intersect: function(base, value3) {
    return !base.length ? value3 : base.filter((v) => value3.includes(v));
  },
  R_union: function(base, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base.length) return [lo, hi];
    if (base[0] > lo) base[0] = lo;
    if (base[1] < hi) base[1] = hi;
    return base;
  },
  R_intersect: function(base, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base.length) return [lo, hi];
    if (hi < base[0] || base[1] < lo) {
      return [];
    } else {
      if (base[0] < lo) base[0] = lo;
      if (base[1] > hi) base[1] = hi;
    }
    return base;
  }
};
var DataPrefix = ":";
var IndexPrefix = "@";
function selectionVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal) error("First argument to selection functions must be a string literal.");
  const data3 = args[0].value, op = args.length >= 2 && peek(args).value, field3 = "unit", indexName = IndexPrefix + field3, dataName = DataPrefix + data3;
  if (op === Intersect && !has(params2, indexName)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field3);
  }
  if (!has(params2, dataName)) {
    params2[dataName] = scope.getData(data3).tuplesRef();
  }
}

// node_modules/vega-functions/build/vega-functions.module.js
function data(name4) {
  const data3 = this.context.data[name4];
  return data3 ? data3.values.value : [];
}
function indata(name4, field3, value3) {
  const index3 = this.context.data[name4]["index:" + field3], entry2 = index3 ? index3.value.get(value3) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name4, tuples) {
  const df = this.context.dataflow, data3 = this.context.data[name4], input = data3.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode(item, name4, retval) {
  if (item) {
    const df = this.context.dataflow, target2 = item.mark.source;
    df.pulse(target2, df.changeset().encode(item, name4));
  }
  return retval !== void 0 ? retval : item;
}
var wrap = (method2) => function(value3, spec) {
  const locale2 = this.context.dataflow.locale();
  return value3 === null ? "null" : locale2[method2](spec)(value3);
};
var format4 = wrap("format");
var timeFormat2 = wrap("timeFormat");
var utcFormat2 = wrap("utcFormat");
var timeParse2 = wrap("timeParse");
var utcParse2 = wrap("utcParse");
var dateObj = new Date(2e3, 0, 1);
function time2(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day)) return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat2.call(this, dateObj, specifier);
}
function monthFormat(month) {
  return time2.call(this, month, 1, "%B");
}
function monthAbbrevFormat(month) {
  return time2.call(this, month, 1, "%b");
}
function dayFormat(day) {
  return time2.call(this, 0, 2 + day, "%A");
}
function dayAbbrevFormat(day) {
  return time2.call(this, 0, 2 + day, "%a");
}
var DataPrefix2 = ":";
var IndexPrefix2 = "@";
var ScalePrefix = "%";
var SignalPrefix = "$";
function dataVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data3 = args[0].value, dataName = DataPrefix2 + data3;
  if (!has(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data3).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal) error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal) error("Second argument to indata must be a string literal.");
  const data3 = args[0].value, field3 = args[1].value, indexName = IndexPrefix2 + field3;
  if (!has(indexName, params2)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field3);
  }
}
function scaleVisitor(name4, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name4 in scope.scales) {
      addScaleDependency(scope, params2, name4);
    }
  }
}
function addScaleDependency(scope, params2, name4) {
  const scaleName = ScalePrefix + name4;
  if (!has(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name4);
    } catch (err) {
    }
  }
}
function getScale(name4, ctx) {
  if (isString(name4)) {
    const maybeScale = ctx.scales[name4];
    return maybeScale && isRegisteredScale(maybeScale.value) ? maybeScale.value : void 0;
  }
  return void 0;
}
function internalScaleFunctions(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref2 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => `this.__bandwidth(${ref2(args[0])})`,
    _range: (args) => `${ref2(args[0])}.range()`,
    _scale: (args) => `${ref2(args[0])}(${codegen2(args[1])})`
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection3, geojson, group2) {
    if (projection3) {
      const p = getScale(projection3, (group2 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
var geoArea = geoMethod("area", area_default);
var geoBounds = geoMethod("bounds", bounds_default);
var geoCentroid = geoMethod("centroid", centroid_default);
function geoScale(projection3, group2) {
  const p = getScale(projection3, (group2 || this).context);
  return p && p.scale();
}
function inScope(item) {
  const group2 = this.context.group;
  let value3 = false;
  if (group2) while (item) {
    if (item === group2) {
      value3 = true;
      break;
    }
    item = item.mark.group;
  }
  return value3;
}
function log5(df, method2, args) {
  try {
    df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log5(this.context.dataflow, "warn", arguments);
}
function info() {
  return log5(this.context.dataflow, "info", arguments);
}
function debug() {
  return log5(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color4) {
  const c = rgb(color4), r2 = channel_luminance_value(c.r), g = channel_luminance_value(c.g), b2 = channel_luminance_value(c.b);
  return 0.2126 * r2 + 0.7152 * g + 0.0722 * b2;
}
function contrast(color1, color22) {
  const lum1 = luminance(color1), lum2 = luminance(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge4() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend(...args);
}
function equal(a, b2) {
  return a === b2 || a !== a && b2 !== b2 ? true : isArray(a) ? isArray(b2) && a.length === b2.length ? equalArray(a, b2) : false : isObject(a) && isObject(b2) ? equalObject(a, b2) : false;
}
function equalArray(a, b2) {
  for (let i = 0, n = a.length; i < n; ++i) {
    if (!equal(a[i], b2[i])) return false;
  }
  return true;
}
function equalObject(a, b2) {
  for (const key2 in a) {
    if (!equal(a[key2], b2[key2])) return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name4, insert3, remove2, toggle2, modify2, values5) {
  const df = this.context.dataflow, data3 = this.context.data[name4], input = data3.input, stamp = df.stamp();
  let changes = data3.changes, predicate, key2;
  if (df._trigger === false || !(input.value.length || insert3 || toggle2)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data3.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data3.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove2) {
    predicate = remove2 === true ? truthy : isArray(remove2) || isTuple(remove2) ? remove2 : removePredicate(remove2);
    changes.remove(predicate);
  }
  if (insert3) {
    changes.insert(insert3);
  }
  if (toggle2) {
    predicate = removePredicate(toggle2);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle2);
    }
  }
  if (modify2) {
    for (key2 in values5) {
      changes.modify(modify2, key2, values5[key2]);
    }
  }
  return 1;
}
function pinchDistance(event2) {
  const t2 = event2.touches, dx = t2[0].clientX - t2[1].clientX, dy = t2[0].clientY - t2[1].clientY;
  return Math.hypot(dx, dy);
}
function pinchAngle(event2) {
  const t2 = event2.touches;
  return Math.atan2(t2[0].clientY - t2[1].clientY, t2[0].clientX - t2[1].clientX);
}
var accessors = {};
function pluck(data3, name4) {
  const accessor2 = accessors[name4] || (accessors[name4] = field(name4));
  return isArray(data3) ? data3.map(accessor2) : accessor2(data3);
}
function array3(seq) {
  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence2(seq) {
  return array3(seq) || (isString(seq) ? seq : null);
}
function join2(seq) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return array3(seq).join(...args);
}
function indexof(seq) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return sequence2(seq).indexOf(...args);
}
function lastindexof(seq) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return sequence2(seq).lastIndexOf(...args);
}
function slice2(seq) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  return sequence2(seq).slice(...args);
}
function replace2(str, pattern, repl) {
  if (isFunction(repl)) error("Function argument passed to replace.");
  if (!isString(pattern) && !isRegExp(pattern)) error("Please pass a string or RegExp argument to replace.");
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array3(seq).slice().reverse();
}
function sort2(seq) {
  return array3(seq).slice().sort(ascending2);
}
function bandspace(count, paddingInner2, paddingOuter2) {
  return bandSpace(count || 0, paddingInner2 || 0, paddingOuter2 || 0);
}
function bandwidth(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s ? s.copy() : void 0;
}
function domain(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s ? s.domain() : [];
}
function invert(name4, range6, group2) {
  const s = getScale(name4, (group2 || this).context);
  return !s ? void 0 : isArray(range6) ? (s.invertRange || s.invert)(range6) : (s.invert || s.invertExtent)(range6);
}
function range2(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s && s.range ? s.range() : [];
}
function scale3(name4, value3, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s ? s(value3) : void 0;
}
function scaleGradient(scaleOrFunction, p0, p1, count, group2) {
  let scale6 = typeof scaleOrFunction === "string" ? getScale(scaleOrFunction, (group2 || this).context) : scaleOrFunction;
  const gradient4 = Gradient(p0, p1);
  let stops = scale6.domain(), min4 = stops[0], max4 = peek(stops), fraction = identity2;
  if (!(max4 - min4)) {
    scale6 = (scale6.interpolator ? scale("sequential")().interpolator(scale6.interpolator()) : scale("linear")().interpolate(scale6.interpolate()).range(scale6.range())).domain([min4 = 0, max4 = 1]);
  } else {
    fraction = scaleFraction(scale6, min4, max4);
  }
  if (scale6.ticks) {
    stops = scale6.ticks(+count || 15);
    if (min4 !== stops[0]) stops.unshift(min4);
    if (max4 !== peek(stops)) stops.push(max4);
  }
  stops.forEach((_) => gradient4.stop(fraction(_), scale6(_)));
  return gradient4;
}
function geoShape(projection3, geojson, group2) {
  const p = getScale(projection3, (group2 || this).context);
  return function(context3) {
    return p ? p.path.context(context3)(geojson) : "";
  };
}
function pathShape(path3) {
  let p = null;
  return function(context3) {
    return context3 ? pathRender(context3, p = p || parse4(path3)) : path3;
  };
}
var datum = (d) => d.data;
function treeNodes(name4, context3) {
  const tree = data.call(context3, name4);
  return tree.root && tree.root.lookup || {};
}
function treePath(name4, source4, target2) {
  const nodes = treeNodes(name4, this), s = nodes[source4], t2 = nodes[target2];
  return s && t2 ? s.path(t2).map(datum) : void 0;
}
function treeAncestors(name4, node) {
  const n = treeNodes(name4, this)[node];
  return n ? n.ancestors().map(datum) : void 0;
}
var _window = () => typeof window !== "undefined" && window || null;
function screen() {
  const w4 = _window();
  return w4 ? w4.screen : {};
}
function windowSize() {
  const w4 = _window();
  return w4 ? [w4.innerWidth, w4.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect3(b2, opt, group2) {
  if (!b2) return [];
  const [u, v] = b2, box = new Bounds().set(u[0], u[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
  return intersect(scene, box, filter2(opt));
}
function filter2(opt) {
  let p = null;
  if (opt) {
    const types4 = array(opt.marktype), names = array(opt.markname);
    p = (_) => (!types4.length || types4.some((t2) => _.marktype === t2)) && (!names.length || names.some((s) => _.name === s));
  }
  return p;
}
function lassoAppend(lasso, x2, y2) {
  let minDist = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  lasso = array(lasso);
  const last = lasso[lasso.length - 1];
  return last === void 0 || Math.hypot(last[0] - x2, last[1] - y2) > minDist ? [...lasso, [x2, y2]] : lasso;
}
function lassoPath(lasso) {
  return array(lasso).reduce((svg, _ref, i) => {
    let [x2, y2] = _ref;
    return svg += i == 0 ? `M ${x2},${y2} ` : i === lasso.length - 1 ? " Z" : `L ${x2},${y2} `;
  }, "");
}
function intersectLasso(markname, pixelLasso, unit) {
  const {
    x: x2,
    y: y2,
    mark: mark2
  } = unit;
  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [px2, py2] of pixelLasso) {
    if (px2 < bb.x1) bb.x1 = px2;
    if (px2 > bb.x2) bb.x2 = px2;
    if (py2 < bb.y1) bb.y1 = py2;
    if (py2 > bb.y2) bb.y2 = py2;
  }
  bb.translate(x2, y2);
  const intersection2 = intersect3([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark2);
  return intersection2.filter((tuple) => pointInPolygon(tuple.x, tuple.y, pixelLasso));
}
function pointInPolygon(testx, testy, polygon) {
  let intersections = 0;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [prevX, prevY] = polygon[j];
    const [x2, y2] = polygon[i];
    if (y2 > testy != prevY > testy && testx < (prevX - x2) * (testy - y2) / (prevY - y2) + x2) {
      intersections++;
    }
  }
  return intersections & 1;
}
var functionContext = {
  random() {
    return random();
  },
  // override default
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray,
  isBoolean,
  isDate,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber,
  isObject,
  isRegExp,
  isString,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean,
  toDate(_) {
    return toDate(_);
  },
  // suppress extra arguments
  toNumber,
  toString,
  indexof,
  join: join2,
  lastindexof,
  replace: replace2,
  reverse,
  sort: sort2,
  slice: slice2,
  flush,
  lerp,
  merge: merge4,
  pad,
  peek,
  pluck,
  span,
  inrange,
  truncate,
  rgb,
  lab,
  hcl,
  hsl,
  luminance,
  contrast,
  sequence: range,
  format: format4,
  utcFormat: utcFormat2,
  utcParse: utcParse2,
  utcOffset,
  utcSequence,
  timeFormat: timeFormat2,
  timeParse: timeParse2,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter,
  utcquarter,
  week,
  utcweek,
  dayofyear,
  utcdayofyear,
  warn,
  info,
  debug,
  extent(_) {
    return extent(_);
  },
  // suppress extra arguments
  inScope,
  intersect: intersect3,
  clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  encode,
  modify,
  lassoAppend,
  lassoPath,
  intersectLasso
};
var eventFunctions = ["view", "item", "group", "xy", "x", "y"];
var eventPrefix = "event.vega.";
var thisPrefix = "this.";
var astVisitors = {};
var codegenParams = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id2) => `_[${$(SignalPrefix + id2)}]`,
  functions: buildFunctions,
  constants: Constants,
  visitors: astVisitors
};
var codeGenerator = codegen(codegenParams);
function buildFunctions(codegen2) {
  const fn = Functions(codegen2);
  eventFunctions.forEach((name4) => fn[name4] = eventPrefix + name4);
  for (const name4 in functionContext) {
    fn[name4] = thisPrefix + name4;
  }
  extend(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name4, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name4];
  }
  functionContext[name4] = fn;
  if (visitor) astVisitors[name4] = visitor;
  if (codeGenerator) codeGenerator.functions[name4] = thisPrefix + name4;
  return this;
}
expressionFunction("bandwidth", bandwidth, scaleVisitor);
expressionFunction("copy", copy, scaleVisitor);
expressionFunction("domain", domain, scaleVisitor);
expressionFunction("range", range2, scaleVisitor);
expressionFunction("invert", invert, scaleVisitor);
expressionFunction("scale", scale3, scaleVisitor);
expressionFunction("gradient", scaleGradient, scaleVisitor);
expressionFunction("geoArea", geoArea, scaleVisitor);
expressionFunction("geoBounds", geoBounds, scaleVisitor);
expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
expressionFunction("geoShape", geoShape, scaleVisitor);
expressionFunction("geoScale", geoScale, scaleVisitor);
expressionFunction("indata", indata, indataVisitor);
expressionFunction("data", data, dataVisitor);
expressionFunction("treePath", treePath, dataVisitor);
expressionFunction("treeAncestors", treeAncestors, dataVisitor);
expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
expressionFunction("vlSelectionTuples", selectionTuples);
function parser2(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString(expr2) ? expr2 : $(expr2) + "";
    ast = parser(expr2);
  } catch (err) {
    error("Expression parse error: " + expr2);
  }
  ast.visit((node) => {
    if (node.type !== CallExpression) return;
    const name4 = node.callee.name, visit2 = codegenParams.visitors[name4];
    if (visit2) visit2(name4, node.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name4) => {
    const signalName = SignalPrefix + name4;
    if (!has(params2, signalName) && scope.getSignal(name4)) {
      params2[signalName] = scope.signalRef(name4);
    }
  });
  return {
    $expr: extend({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}

// node_modules/vega-runtime/build/vega-runtime.module.js
function parse5(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
var Skip = toSet(["rule"]);
var Swap = toSet(["group", "image", "rect"]);
function adjustSpatial(encode2, marktype) {
  let code = "";
  if (Skip[marktype]) return code;
  if (encode2.x2) {
    if (encode2.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode2.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode2.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type3) {
  return (type3 + "").toLowerCase();
}
function isOperator(type3) {
  return canonicalType(type3) === "operator";
}
function isCollect(type3) {
  return canonicalType(type3) === "collect";
}
function expression(ctx, args, code) {
  if (!code.endsWith(";")) {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u, v, lt2, gt2) {
  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt2}
  : (u > v || v == null) && u != null ? ${gt2}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt2}
  : v !== v && u === u ? ${gt2} : `;
}
var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr2) => expression(ctx, ["_"], expr2.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr2) => expression(ctx, ["datum", "_"], expr2.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr2) => expression(ctx, ["event"], expr2.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr2) => {
    const code = `var datum=event.item&&event.item.datum;return ${expr2.code};`;
    return expression(ctx, ["_", "event"], code);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode2) => {
    const {
      marktype,
      channels
    } = encode2;
    let code = "var o=item,datum=o.datum,m=0,$;";
    for (const name4 in channels) {
      const o = "o[" + $(name4) + "]";
      code += `$=${channels[name4].code};if(${o}!==$)${o}=$,m=1;`;
    }
    code += adjustSpatial(channels, marktype);
    code += "return m;";
    return expression(ctx, ["item", "_"], code);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path3) {
      const ref2 = `[${path3.map($).join("][")}]`;
      const get6 = Function("_", `return _${ref2};`);
      get6.path = ref2;
      return get6;
    },
    comparator(fields, orders) {
      let t2;
      const map2 = (f, i) => {
        const o = orders[i];
        let u, v;
        if (f.path) {
          u = `a${f.path}`;
          v = `b${f.path}`;
        } else {
          (t2 = t2 || {})["f" + i] = f;
          u = `this.f${i}(a)`;
          v = `this.f${i}(b)`;
        }
        return _compare(u, v, -o, o);
      };
      const fn = Function("a", "b", "var u, v; return " + fields.map(map2).join("") + "0;");
      return t2 ? fn.bind(t2) : fn;
    }
  }
};
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op) error("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key2 in spec) {
    const value3 = spec[key2];
    params2[key2] = isArray(value3) ? value3.map((v) => parseParameter(v, ctx, params2)) : parseParameter(value3, ctx, params2);
  }
  return params2;
}
function parseParameter(spec, ctx, params2) {
  if (!spec || !isObject(spec)) return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
var PARSERS = [{
  key: "$ref",
  parse: getOperator
}, {
  key: "$key",
  parse: getKey
}, {
  key: "$expr",
  parse: getExpression
}, {
  key: "$field",
  parse: getField2
}, {
  key: "$encode",
  parse: getEncode
}, {
  key: "$compare",
  parse: getCompare
}, {
  key: "$context",
  parse: getContext
}, {
  key: "$subflow",
  parse: getSubflow
}, {
  key: "$tupleid",
  parse: getTupleId
}];
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k2 = "e:" + _.$expr.code;
  return ctx.fn[k2] || (ctx.fn[k2] = accessor(ctx.parameterExpression(_.$expr), _.$fields));
}
function getKey(_, ctx) {
  const k2 = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k2] || (ctx.fn[k2] = key(_.$key, _.$flat, ctx.expr.codegen));
}
function getField2(_, ctx) {
  if (!_.$field) return null;
  const k2 = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k2] || (ctx.fn[k2] = field(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k2 = "c:" + _.$compare + "_" + _.$order, c = array(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k2] || (ctx.fn[k2] = compare2(c, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode2 = {};
  for (const name4 in spec) {
    const enc = spec[name4];
    encode2[name4] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode2[name4].output = enc.$output;
  }
  return encode2;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key2, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p) p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream(spec) {
  var ctx = this, filter3 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter3);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter3);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume) stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate(spec) {
  var ctx = this, srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid, source4 = ctx.get(srcid), target2 = null, update3 = spec.update, params2 = void 0;
  if (!source4) error("Source not defined: " + spec.source);
  target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update3 && update3.$expr) {
    if (update3.$params) {
      params2 = ctx.parseParameters(update3.$params);
    }
    update3 = ctx.handlerExpression(update3.$expr);
  }
  ctx.update(spec, source4, target2, update3, params2);
}
var SKIP3 = {
  skip: true
};
function getState(options) {
  var ctx = this, state = {};
  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key2) => {
      const op = ctx.signals[key2];
      if (options.signals(key2, op)) {
        signals[key2] = op.value;
      }
    });
  }
  if (options.data) {
    var data3 = state.data = {};
    Object.keys(ctx.data).forEach((key2) => {
      const dataset = ctx.data[key2];
      if (options.data(key2, dataset)) {
        data3[key2] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options));
  }
  return state;
}
function setState(state) {
  var ctx = this, df = ctx.dataflow, data3 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key2) => {
    df.update(ctx.signals[key2], signals[key2], SKIP3);
  });
  Object.keys(data3 || {}).forEach((key2) => {
    df.pulse(ctx.data[key2].input, df.changeset().remove(truthy).insert(data3[key2]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx) subctx.setState(substate);
  });
}
function context2(df, transforms2, functions, expr2) {
  return new Context(df, transforms2, functions, expr2);
}
function Context(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter((c) => c !== ctx);
    const keys5 = Object.keys(ctx.nodes);
    for (const key2 of keys5) ctx.nodes[key2]._targets = null;
    for (const key2 of keys5) ctx.nodes[key2].detach();
    ctx.nodes = null;
  },
  get(id2) {
    return this.nodes[id2];
  },
  set(id2, node) {
    return this.nodes[id2] = node;
  },
  add(spec, op) {
    const ctx = this, df = ctx.dataflow, data3 = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data3) {
      if (data3.$ingest) {
        df.ingest(op, data3.$ingest, data3.$format);
      } else if (data3.$request) {
        df.preload(op, data3.$request, data3.$format);
      } else {
        df.pulse(op, df.changeset().insert(data3));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name4 in spec.data) {
        const data4 = ctx.data[name4] || (ctx.data[name4] = {});
        spec.data[name4].forEach((role) => data4[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach((fn) => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update3) {
    this.add(spec, this.dataflow.add(spec.value, update3));
  },
  transform(spec, type3) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type3)]));
  },
  stream(spec, stream2) {
    this.set(spec.id, stream2);
  },
  update(spec, stream2, target2, update3, params2) {
    this.dataflow.on(stream2, target2, update3, params2, spec.options);
  },
  // expression parsing
  operatorExpression(expr2) {
    return this.expr.operator(this, expr2);
  },
  parameterExpression(expr2) {
    return this.expr.parameter(this, expr2);
  },
  eventExpression(expr2) {
    return this.expr.event(this, expr2);
  },
  handlerExpression(expr2) {
    return this.expr.handler(this, expr2);
  },
  encodeExpression(encode2) {
    return this.expr.encode(this, encode2);
  },
  // parse methods
  parse: parse5,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};

// node_modules/vega-view/build/vega-view.module.js
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el) desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background2(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
var Default = "default";
function cursor(view) {
  const cursor3 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "pointermove"), cursor3, (_, event2) => {
    const value3 = cursor3.value, user = value3 ? isString(value3) ? value3 : value3.user : Default, item = event2.item && event2.item.cursor || null;
    return value3 && user === value3.user && item == value3.item ? value3 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor3
  });
}
function setCursor(view, cursor3) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor3 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor3;
  }
}
function dataref(view, name4) {
  var data3 = view._runtime.data;
  if (!has(data3, name4)) {
    error("Unrecognized data set: " + name4);
  }
  return data3[name4];
}
function data2(name4, values5) {
  return arguments.length < 2 ? dataref(this, name4).values.value : change.call(this, name4, changeset().remove(truthy).insert(values5));
}
function change(name4, changes) {
  if (!isChangeSet(changes)) {
    error("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name4);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name4, _) {
  return change.call(this, name4, changeset().insert(_));
}
function remove(name4, _) {
  return change.call(this, name4, changeset().remove(_));
}
function width(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewWidth + padding3.left + padding3.right);
}
function height(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewHeight + padding3.top + padding3.bottom);
}
function offset3(view) {
  var padding3 = view.padding(), origin = view._origin;
  return [padding3.left + origin[0], padding3.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset3(view), w4 = width(view), h2 = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w4, h2, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w4, h2);
    } catch (error2) {
      view.error(error2);
    }
  });
}
function eventExtend(view, event2, item) {
  var r2 = view._renderer, el = r2 && r2.canvas(), p, e2, translate4;
  if (el) {
    translate4 = offset3(view);
    e2 = event2.changedTouches ? event2.changedTouches[0] : event2;
    p = point2(e2, el);
    p[0] -= translate4[0];
    p[1] -= translate4[1];
  }
  event2.dataflow = view;
  event2.item = item;
  event2.vega = extension(view, item, p);
  return event2;
}
function extension(view, item, point5) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group2(name4) {
    var g = itemGroup, i;
    if (name4) for (i = item; i; i = i.mark.group) {
      if (i.mark.name === name4) {
        g = i;
        break;
      }
    }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2) return point5;
    if (isString(item2)) item2 = group2(item2);
    const p = point5.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant(view),
    item: constant(item || {}),
    group: group2,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
var VIEW = "view";
var TIMER = "timer";
var WINDOW = "window";
var NO_TRAP = {
  trap: false
};
function initializeEventConfig(config) {
  const events4 = extend({
    defaults: {}
  }, config);
  const unpack = (obj, keys5) => {
    keys5.forEach((k2) => {
      if (isArray(obj[k2])) obj[k2] = toSet(obj[k2]);
    });
  };
  unpack(events4.defaults, ["prevent", "allow"]);
  unpack(events4, ["view", "window", "selector"]);
  return events4;
}
function trackEventListener(view, sources, type3, handler) {
  view._eventListeners.push({
    type: type3,
    sources: array(sources),
    handler
  });
}
function prevent(view, type3) {
  var def2 = view._eventConfig.defaults, prevent2 = def2.prevent, allow = def2.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type3] : allow ? !allow[type3] : view.preventDefault();
}
function permit(view, key2, type3) {
  const rule4 = view._eventConfig && view._eventConfig[key2];
  if (rule4 === false || isObject(rule4) && !rule4[type3]) {
    view.warn(`Blocked ${key2} ${type3} event listener.`);
    return false;
  }
  return true;
}
function events2(source4, type3, filter3) {
  var view = this, s = new EventStream(filter3), send = function(e2, item) {
    view.runAsync(null, () => {
      if (source4 === VIEW && prevent(view, type3)) {
        e2.preventDefault();
      }
      s.receive(eventExtend(view, e2, item));
    });
  }, sources;
  if (source4 === TIMER) {
    if (permit(view, "timer", type3)) {
      view.timer(send, type3);
    }
  } else if (source4 === VIEW) {
    if (permit(view, "view", type3)) {
      view.addEventListener(type3, send, NO_TRAP);
    }
  } else {
    if (source4 === WINDOW) {
      if (permit(view, "window", type3) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type3)) {
        sources = Array.from(document.querySelectorAll(source4));
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source4);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type3, send);
      }
      trackEventListener(view, sources, type3, send);
    }
  }
  return s;
}
function itemFilter(event2) {
  return event2.item;
}
function markTarget(event2) {
  return event2.item.mark.source;
}
function invoke(name4) {
  return function(_, event2) {
    return event2.vega.view().changeset().encode(event2.item, name4);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "pointerover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "pointerout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip2 = this._tooltip, timers = this._timers, handlers = this._handler.handlers(), listeners = this._eventListeners, n, m, e2, h2, t2;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e2 = listeners[n];
    m = e2.sources.length;
    while (--m >= 0) {
      e2.sources[m].removeEventListener(e2.type, e2.handler);
    }
  }
  if (tooltip2) {
    tooltip2.call(this, this._handler, null, null, null);
  }
  n = handlers.length;
  while (--n >= 0) {
    t2 = handlers[n].type;
    h2 = handlers[n].handler;
    this._handler.off(t2, h2);
  }
  return this;
}
function element2(tag, attr2, text4) {
  const el = document.createElement(tag);
  for (const key2 in attr2) el.setAttribute(key2, attr2[key2]);
  if (text4 != null) el.textContent = text4;
  return el;
}
var BindClass = "vega-bind";
var NameClass = "vega-bind-name";
var RadioClass = "vega-bind-radio";
function bind2(view, el, binding) {
  if (!el) return;
  const param2 = binding.param;
  let bind3 = binding.state;
  if (!bind3) {
    bind3 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value3) => {
        if (value3 != view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind3.source = true;
            view.signal(param2.signal, value3);
          });
        }
      }
    };
    if (param2.debounce) {
      bind3.update = debounce(param2.debounce, bind3.update);
    }
  }
  const create4 = param2.input == null && param2.element ? target : generate2;
  create4(bind3, el, param2, view);
  if (!bind3.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind3.source ? bind3.source = false : bind3.set(view.signal(param2.signal));
    });
    bind3.active = true;
  }
  return bind3;
}
function target(bind3, node, param2, view) {
  const type3 = param2.event || "input";
  const handler = () => bind3.update(node.value);
  view.signal(param2.signal, node.value);
  node.addEventListener(type3, handler);
  trackEventListener(view, node, type3, handler);
  bind3.set = (value3) => {
    node.value = value3;
    node.dispatchEvent(event(type3));
  };
}
function event(type3) {
  return typeof Event !== "undefined" ? new Event(type3) : {
    type: type3
  };
}
function generate2(bind3, el, param2, view) {
  const value3 = view.signal(param2.signal);
  const div = element2("div", {
    "class": BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element2("label"));
  wrapper.appendChild(element2("span", {
    "class": NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range3;
      break;
  }
  input(bind3, wrapper, param2, value3);
}
function form(bind3, el, param2, value3) {
  const node = element2("input");
  for (const key2 in param2) {
    if (key2 !== "signal" && key2 !== "element") {
      node.setAttribute(key2 === "input" ? "type" : key2, param2[key2]);
    }
  }
  node.setAttribute("name", param2.signal);
  node.value = value3;
  el.appendChild(node);
  node.addEventListener("input", () => bind3.update(node.value));
  bind3.elements = [node];
  bind3.set = (value4) => node.value = value4;
}
function checkbox(bind3, el, param2, value3) {
  const attr2 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value3) attr2.checked = true;
  const node = element2("input", attr2);
  el.appendChild(node);
  node.addEventListener("change", () => bind3.update(node.checked));
  bind3.elements = [node];
  bind3.set = (value4) => node.checked = !!value4 || null;
}
function select(bind3, el, param2, value3) {
  const node = element2("select", {
    name: param2.signal
  }), labels3 = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr2 = {
      value: option
    };
    if (valuesEqual(option, value3)) attr2.selected = true;
    node.appendChild(element2("option", attr2, (labels3[i] || option) + ""));
  });
  el.appendChild(node);
  node.addEventListener("change", () => {
    bind3.update(param2.options[node.selectedIndex]);
  });
  bind3.elements = [node];
  bind3.set = (value4) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value4)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind3, el, param2, value3) {
  const group2 = element2("span", {
    "class": RadioClass
  }), labels3 = param2.labels || [];
  el.appendChild(group2);
  bind3.elements = param2.options.map((option, i) => {
    const attr2 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value3)) attr2.checked = true;
    const input = element2("input", attr2);
    input.addEventListener("change", () => bind3.update(option));
    const label = element2("label", {}, (labels3[i] || option) + "");
    label.prepend(input);
    group2.appendChild(label);
    return input;
  });
  bind3.set = (value4) => {
    const nodes = bind3.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value4)) nodes[i].checked = true;
    }
  };
}
function range3(bind3, el, param2, value3) {
  value3 = value3 !== void 0 ? value3 : (+param2.max + +param2.min) / 2;
  const max4 = param2.max != null ? param2.max : Math.max(100, +value3) || 100, min4 = param2.min || Math.min(0, max4, +value3) || 0, step = param2.step || tickStep(min4, max4, 100);
  const node = element2("input", {
    type: "range",
    name: param2.signal,
    min: min4,
    max: max4,
    step
  });
  node.value = value3;
  const span2 = element2("span", {}, +value3);
  el.appendChild(node);
  el.appendChild(span2);
  const update3 = () => {
    span2.textContent = node.value;
    bind3.update(+node.value);
  };
  node.addEventListener("input", update3);
  node.addEventListener("change", update3);
  bind3.elements = [node];
  bind3.set = (value4) => {
    node.value = value4;
    span2.textContent = value4;
  };
}
function valuesEqual(a, b2) {
  return a === b2 || a + "" === b2 + "";
}
function initializeRenderer(view, r2, el, constructor, scaleFactor, opt) {
  r2 = r2 || new constructor(view.loader());
  return r2.initialize(el, width(view), height(view), offset3(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error2) {
      view.error(error2);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset3(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h2) => {
      handler.on(h2.type, h2.handler);
    });
  }
  return handler;
}
function initialize2(el, elBind) {
  const view = this, type3 = view._renderType, config = view._eventConfig.bind, module4 = renderModule(type3);
  el = view._el = el ? lookup4(view, el, true) : null;
  initializeAria(view);
  if (!module4) view.error("Unrecognized renderer type: " + type3);
  const Handler3 = module4.handler || CanvasHandler, Renderer2 = el ? module4.renderer : module4.headless;
  view._renderer = !Renderer2 ? null : initializeRenderer(view, view._renderer, el, Renderer2);
  view._handler = initializeHandler(view, view._handler, el, Handler3);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup4(view, elBind, true) : el.appendChild(element2("form", {
      "class": "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup4(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach((_) => {
      bind2(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup4(view, el, clear2) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el && clear2) {
    try {
      el.textContent = "";
    } catch (e2) {
      el = null;
      view.error(e2);
    }
  }
  return el;
}
var number3 = (_) => +_ || 0;
var paddingObject = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding(_) {
  return isObject(_) ? {
    top: number3(_.top),
    bottom: number3(_.bottom),
    left: number3(_.left),
    right: number3(_.right)
  } : paddingObject(number3(_));
}
async function renderHeadless(view, type3, scaleFactor, opt) {
  const module4 = renderModule(type3), ctr = module4 && module4.headless;
  if (!ctr) error("Unrecognized renderer type: " + type3);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type3, scaleFactor) {
  if (type3 !== RenderType.Canvas && type3 !== RenderType.SVG && type3 !== RenderType.PNG) {
    error("Unrecognized image type: " + type3);
  }
  const r2 = await renderHeadless(this, type3, scaleFactor);
  return type3 === RenderType.SVG ? toBlobURL(r2.svg(), "image/svg+xml") : r2.canvas().toDataURL("image/png");
}
function toBlobURL(data3, mime) {
  const blob = new Blob([data3], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r2 = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
  return r2.canvas();
}
async function renderToSVG(scaleFactor) {
  const r2 = await renderHeadless(this, RenderType.SVG, scaleFactor);
  return r2.svg();
}
function runtime(view, spec, expr2) {
  return context2(view, transforms, functionContext, expr2).parse(spec);
}
function scale4(name4) {
  var scales2 = this._runtime.scales;
  if (!has(scales2, name4)) {
    error("Unrecognized scale or projection: " + name4);
  }
  return scales2[name4].value;
}
var Width = "width";
var Height = "height";
var Padding2 = "padding";
var Skip2 = {
  skip: true
};
function viewWidth(view, width2) {
  var a = view.autosize(), p = view.padding();
  return width2 - (a && a.contains === Padding2 ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a = view.autosize(), p = view.padding();
  return height2 - (a && a.contains === Padding2 ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals, w4 = s[Width], h2 = s[Height], p = s[Padding2];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w4
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h2
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w4.rank + 1;
  view._resizeHeight.rank = h2.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip2);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip2);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2) view.run("enter");
    if (auto) view.runAfter((v) => v.resize());
  }, false, 1);
}
function getState2(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name4, data3) {
  return data3.modified && isArray(data3.input.value) && !name4.startsWith("_:vega:_");
}
function signalTest(name4, op) {
  return !(name4 === "parent" || op instanceof transforms.proxy);
}
function setState2(state) {
  this.runAsync(null, (v) => {
    v._trigger = false;
    v._runtime.setState(state);
  }, (v) => {
    v._trigger = true;
  });
  return this;
}
function timer(callback, delay) {
  function tick2(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval_default(tick2, delay));
}
function defaultTooltip2(handler, event2, item, value3) {
  const el = handler.element();
  if (el) el.setAttribute("title", formatTooltip(value3));
}
function formatTooltip(value3) {
  return value3 == null ? "" : isArray(value3) ? formatArray(value3) : isObject(value3) && !isDate(value3) ? formatObject(value3) : value3 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key2) => {
    const v = obj[key2];
    return key2 + ": " + (isArray(v) ? formatArray(v) : formatValue2(v));
  }).join("\n");
}
function formatArray(value3) {
  return "[" + value3.map(formatValue2).join(", ") + "]";
}
function formatValue2(value3) {
  return isArray(value3) ? "[…]" : isObject(value3) && !isDate(value3) ? "{…}" : value3;
}
function watchPixelRatio() {
  if (this.renderer() === "canvas" && this._renderer._canvas) {
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const media = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      media.addEventListener("change", updatePixelRatio);
      remove2 = () => {
        media.removeEventListener("change", updatePixelRatio);
      };
      this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1;
      this._redraw = true;
      this._resize = 1;
      this.resize().runAsync();
    };
    updatePixelRatio();
  }
}
function View(spec, options) {
  const view = this;
  options = options || {};
  Dataflow.call(view);
  if (options.loader) view.loader(options.loader);
  if (options.logger) view.logger(options.logger);
  if (options.logLevel != null) view.logLevel(options.logLevel);
  if (options.locale || spec.locale) {
    const loc = extend({}, spec.locale, options.locale);
    view.locale(locale(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || RenderType.Canvas;
  view._scenegraph = new Scenegraph();
  const root = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip2, view._redraw = true;
  view._handler = new CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend({}, _)
  }));
  if (ctx.root) ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background2(view);
  cursor(view);
  view.description(spec.description);
  if (options.hover) view.hover();
  if (options.container) view.initialize(options.container, options.bind);
  if (options.watchPixelRatio) view._watchPixelRatio();
}
function lookupSignal(view, name4) {
  return has(view._signals, name4) ? view._signals[name4] : error("Unrecognized signal name: " + $(name4));
}
function findOperatorHandler(op, handler) {
  const h2 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h2.length ? h2[0] : null;
}
function addOperatorListener(view, name4, op, handler) {
  let h2 = findOperatorHandler(op, handler);
  if (!h2) {
    h2 = trap(view, () => handler(name4, op.value));
    h2.handler = handler;
    view.on(op, null, h2);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h2 = findOperatorHandler(op, handler);
  if (h2) op._targets.remove(h2);
  return view;
}
inherits(View, Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode2, prerun, postrun) {
    await Dataflow.prototype.evaluate.call(this, encode2, prerun);
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e2) {
        this.error(e2);
      }
    }
    if (postrun) asyncCallback(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  // -- GET / SET ----
  description(text4) {
    if (arguments.length) {
      const desc = text4 != null ? text4 + "" : null;
      if (desc !== this._desc) ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name4, value3, options) {
    const op = lookupSignal(this, name4);
    return arguments.length === 1 ? op.value : this.update(op, value3, options);
  },
  width(_) {
    return arguments.length ? this.signal("width", _) : this.signal("width");
  },
  height(_) {
    return arguments.length ? this.signal("height", _) : this.signal("height");
  },
  padding(_) {
    return arguments.length ? this.signal("padding", padding(_)) : padding(this.signal("padding"));
  },
  autosize(_) {
    return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
  },
  background(_) {
    return arguments.length ? this.signal("background", _) : this.signal("background");
  },
  renderer(type3) {
    if (!arguments.length) return this._renderType;
    if (!renderModule(type3)) error("Unrecognized renderer type: " + type3);
    if (type3 !== this._renderType) {
      this._renderType = type3;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length) return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader2) {
    if (!arguments.length) return this._loader;
    if (loader2 !== this._loader) {
      Dataflow.prototype.loader.call(this, loader2);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    this._autosize = 1;
    return this.touch(lookupSignal(this, "autosize"));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  // -- SIZING ----
  _resizeView: resizeView,
  // -- EVENT HANDLING ----
  addEventListener(type3, handler, options) {
    let callback = handler;
    if (!(options && options.trap === false)) {
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type3, callback);
    return this;
  },
  removeEventListener(type3, handler) {
    var handlers = this._handler.handlers(type3), i = handlers.length, h2, t2;
    while (--i >= 0) {
      t2 = handlers[i].type;
      h2 = handlers[i].handler;
      if (type3 === t2 && (handler === h2 || handler === h2.raw)) {
        this._handler.off(t2, h2);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (!l.includes(handler)) {
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners, i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name4, handler) {
    return addOperatorListener(this, name4, lookupSignal(this, name4), handler);
  },
  removeSignalListener(name4, handler) {
    return removeOperatorListener(this, lookupSignal(this, name4), handler);
  },
  addDataListener(name4, handler) {
    return addOperatorListener(this, name4, dataref(this, name4).values, handler);
  },
  removeDataListener(name4, handler) {
    return removeOperatorListener(this, dataref(this, name4).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null);
        this._globalCursor = !!_;
        if (prev) setCursor(this, prev);
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer,
  events: events2,
  finalize,
  hover,
  // -- DATA ----
  data: data2,
  change,
  insert,
  remove,
  // -- SCALES --
  scale: scale4,
  // -- INITIALIZATION ----
  initialize: initialize2,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState: getState2,
  setState: setState2,
  // RE-RENDER ON ZOOM
  _watchPixelRatio: watchPixelRatio
});

// node_modules/vega-event-selector/build/vega-event-selector.module.js
var VIEW2 = "view";
var LBRACK = "[";
var RBRACK = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var NAME = "@";
var GT = ">";
var ILLEGAL2 = /[[\]{}]/;
var DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var DEFAULT_SOURCE;
var MARKS;
function eventSelector(selector, source4, marks) {
  DEFAULT_SOURCE = source4 || VIEW2;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type3) {
  return MARKS[type3];
}
function find2(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0, c;
  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;
    else if (popChar && popChar.indexOf(c) >= 0) --count;
    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }
  return i;
}
function parseMerge(s) {
  const output3 = [], n = s.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find2(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output3.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s;
  }
  return output3;
}
function parseSelector(s) {
  return s[0] === "[" ? parseBetween(s) : parseStream2(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1, b2;
  i = find2(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s;
  }
  b2 = parseMerge(s.substring(1, i));
  if (b2.length !== 2) {
    throw "Between selector must have two elements: " + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw "Expected '>' after between selector: " + s;
  }
  b2 = b2.map(parseSelector);
  const stream2 = parseSelector(s.slice(1).trim());
  if (stream2.between) {
    return {
      between: b2,
      stream: stream2
    };
  } else {
    stream2.between = b2;
  }
  return stream2;
}
function parseStream2(s) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source4 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter3;
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e2) {
        throw "Invalid throttle specification: " + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else throw "Unmatched right brace: " + s;
    i = 0;
  }
  if (!n) throw s;
  if (s[0] === NAME) markname = ++i;
  j = find2(s, i, COLON);
  if (j < n) {
    source4.push(s.substring(start, j).trim());
    start = i = ++j;
  }
  i = find2(s, i, LBRACK);
  if (i === n) {
    source4.push(s.substring(start, n).trim());
  } else {
    source4.push(s.substring(start, i).trim());
    filter3 = [];
    start = ++i;
    if (start === n) throw "Unmatched left bracket: " + s;
  }
  while (i < n) {
    i = find2(s, i, RBRACK);
    if (i === n) throw "Unmatched left bracket: " + s;
    filter3.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw "Expected left bracket: " + s;
    start = ++i;
  }
  if (!(n = source4.length) || ILLEGAL2.test(source4[n - 1])) {
    throw "Invalid event selector: " + s;
  }
  if (n > 1) {
    stream2.type = source4[1];
    if (markname) {
      stream2.markname = source4[0].slice(1);
    } else if (isMarkType(source4[0])) {
      stream2.marktype = source4[0];
    } else {
      stream2.source = source4[0];
    }
  } else {
    stream2.type = source4[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter3 != null) stream2.filter = filter3;
  if (throttle[0]) stream2.throttle = throttle[0];
  if (throttle[1]) stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map((_) => {
    const x2 = +_;
    if (x2 !== x2) throw s;
    return x2;
  });
}

// node_modules/vega-parser/build/vega-parser.module.js
function parseAutosize(spec) {
  return isObject(spec) ? spec : {
    type: spec || "pad"
  };
}
var number4 = (_) => +_ || 0;
var paddingObject2 = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding(spec) {
  return !isObject(spec) ? paddingObject2(number4(spec)) : spec.signal ? spec : {
    top: number4(spec.top),
    bottom: number4(spec.bottom),
    left: number4(spec.left),
    right: number4(spec.right)
  };
}
var encoder = (_) => isObject(_) && !isArray(_) ? extend({}, _) : {
  value: _
};
function addEncode(object2, name4, value3, set5) {
  if (value3 != null) {
    const isEncoder = isObject(value3) && !isArray(value3) || isArray(value3) && value3.length && isObject(value3[0]);
    if (isEncoder) {
      object2.update[name4] = value3;
    } else {
      object2[set5 || "enter"][name4] = {
        value: value3
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update3) {
  for (const name4 in enter) {
    addEncode(object2, name4, enter[name4]);
  }
  for (const name4 in update3) {
    addEncode(object2, name4, update3[name4], "update");
  }
}
function extendEncode(encode2, extra, skip) {
  for (const name4 in extra) {
    if (skip && has(skip, name4)) continue;
    encode2[name4] = extend(encode2[name4] || {}, extra[name4]);
  }
  return encode2;
}
function has2(key2, encode2) {
  return encode2 && (encode2.enter && encode2.enter[key2] || encode2.update && encode2.update[key2]);
}
var MarkRole = "mark";
var FrameRole2 = "frame";
var ScopeRole2 = "scope";
var AxisRole2 = "axis";
var AxisDomainRole = "axis-domain";
var AxisGridRole = "axis-grid";
var AxisLabelRole = "axis-label";
var AxisTickRole = "axis-tick";
var AxisTitleRole = "axis-title";
var LegendRole2 = "legend";
var LegendBandRole = "legend-band";
var LegendEntryRole = "legend-entry";
var LegendGradientRole = "legend-gradient";
var LegendLabelRole = "legend-label";
var LegendSymbolRole = "legend-symbol";
var LegendTitleRole = "legend-title";
var TitleRole2 = "title";
var TitleTextRole = "title-text";
var TitleSubtitleRole = "title-subtitle";
function applyDefaults(encode2, type3, role, style2, config) {
  const defaults2 = {}, enter = {};
  let update3, key2, skip, props;
  key2 = "lineBreak";
  if (type3 === "text" && config[key2] != null && !has2(key2, encode2)) {
    applyDefault(defaults2, key2, config[key2]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole2 ? config.group : role === MarkRole ? extend({}, config.mark, config[type3]) : null;
  for (key2 in props) {
    skip = has2(key2, encode2) || (key2 === "fill" || key2 === "stroke") && (has2("fill", encode2) || has2("stroke", encode2));
    if (!skip) applyDefault(defaults2, key2, props[key2]);
  }
  array(style2).forEach((name4) => {
    const props2 = config.style && config.style[name4];
    for (const key3 in props2) {
      if (!has2(key3, encode2)) {
        applyDefault(defaults2, key3, props2[key3]);
      }
    }
  });
  encode2 = extend({}, encode2);
  for (key2 in defaults2) {
    props = defaults2[key2];
    if (props.signal) {
      (update3 = update3 || {})[key2] = props;
    } else {
      enter[key2] = props;
    }
  }
  encode2.enter = extend(enter, encode2.enter);
  if (update3) encode2.update = extend(update3, encode2.update);
  return encode2;
}
function applyDefault(defaults2, key2, value3) {
  defaults2[key2] = value3 && value3.signal ? {
    signal: value3.signal
  } : {
    value: value3
  };
}
var scaleRef = (scale6) => isString(scale6) ? $(scale6) : scale6.signal ? `(${scale6.signal})` : field2(scale6);
function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient2(enc);
  }
  let value3 = enc.signal ? `(${enc.signal})` : enc.color ? color2(enc.color) : enc.field != null ? field2(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
  if (enc.scale != null) {
    value3 = scale5(enc, value3);
  }
  if (value3 === void 0) {
    value3 = null;
  }
  if (enc.exponent != null) {
    value3 = `pow(${value3},${property(enc.exponent)})`;
  }
  if (enc.mult != null) {
    value3 += `*${property(enc.mult)}`;
  }
  if (enc.offset != null) {
    value3 += `+${property(enc.offset)}`;
  }
  if (enc.round) {
    value3 = `round(${value3})`;
  }
  return value3;
}
var _color = (type3, x2, y2, z) => `(${type3}(${[x2, y2, z].map(entry$1).join(",")})+'')`;
function color2(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient2(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
  while (args.length && peek(args) == null) args.pop();
  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(",")})`;
}
function property(property2) {
  return isObject(property2) ? "(" + entry$1(property2) + ")" : property2;
}
function field2(ref2) {
  return resolveField(isObject(ref2) ? ref2 : {
    datum: ref2
  });
}
function resolveField(ref2) {
  let object2, level, field3;
  if (ref2.signal) {
    object2 = "datum";
    field3 = ref2.signal;
  } else if (ref2.group || ref2.parent) {
    level = Math.max(1, ref2.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref2.parent) {
      field3 = ref2.parent;
      object2 += ".datum";
    } else {
      field3 = ref2.group;
    }
  } else if (ref2.datum) {
    object2 = "datum";
    field3 = ref2.datum;
  } else {
    error("Invalid field reference: " + $(ref2));
  }
  if (!ref2.signal) {
    field3 = isString(field3) ? splitAccessPath(field3).map($).join("][") : resolveField(field3);
  }
  return object2 + "[" + field3 + "]";
}
function scale5(enc, value3) {
  const scale6 = scaleRef(enc.scale);
  if (enc.range != null) {
    value3 = `lerp(_range(${scale6}), ${+enc.range})`;
  } else {
    if (value3 !== void 0) value3 = `_scale(${scale6}, ${value3})`;
    if (enc.band) {
      value3 = (value3 ? value3 + "+" : "") + `_bandwidth(${scale6})` + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value3 = `(datum.extra ? _scale(${scale6}, datum.extra.value) : ${value3})`;
      }
    }
    if (value3 == null) value3 = "0";
  }
  return value3;
}
function rule2(enc) {
  let code = "";
  enc.forEach((rule4) => {
    const value3 = entry$1(rule4);
    code += rule4.test ? `(${rule4.test})?${value3}:` : value3;
  });
  if (peek(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode2, type3, role, style2, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode2 = applyDefaults(encode2, type3, role, style2, scope.config);
  for (const key2 in encode2) {
    enc[key2] = parseBlock(encode2[key2], type3, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name4 in block) {
    if (block[name4] != null) {
      channels[name4] = parse$1(expr(block[name4]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray(enc) ? rule2(enc) : entry$1(enc);
}
function parse$1(code, scope, params2, fields) {
  const expr2 = parser2(code, scope);
  expr2.$fields.forEach((name4) => fields[name4] = 1);
  extend(params2, expr2.$params);
  return expr2.$expr;
}
var OUTER = "outer";
var OUTER_INVALID = ["value", "update", "init", "react", "bind"];
function outerError(prefix, name4) {
  error(prefix + ' for "outer" push: ' + $(name4));
}
function parseSignal(signal, scope) {
  const name4 = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name4]) outerError("No prior signal definition", name4);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0) outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name4, signal.value);
    if (signal.react === false) op.react = false;
    if (signal.bind) scope.addBinding(name4, signal.bind);
  }
}
function Entry(type3, value3, params2, parent) {
  this.id = -1;
  this.type = type3;
  this.value = value3;
  this.params = params2;
  if (parent) this.parent = parent;
}
function entry(type3, value3, params2, parent) {
  return new Entry(type3, value3, params2, parent);
}
function operator(value3, params2) {
  return entry("operator", value3, params2);
}
function ref(op) {
  const ref2 = {
    $ref: op.id
  };
  if (op.id < 0) (op.refs = op.refs || []).push(ref2);
  return ref2;
}
function fieldRef$1(field3, name4) {
  return name4 ? {
    $field: field3,
    $name: name4
  } : {
    $field: field3
  };
}
var keyFieldRef = fieldRef$1("key");
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref2 = {
    $key: fields
  };
  if (flat) ref2.$flat = true;
  return ref2;
}
var Ascending = "ascending";
var Descending = "descending";
function sortKey(sort3) {
  return !isObject(sort3) ? "" : (sort3.order === Descending ? "-" : "+") + aggrField(sort3.op, sort3.field);
}
function aggrField(op, field3) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field3 ? "_" : "") + (field3 && field3.signal ? "$" + field3.signal : field3 || "");
}
var Scope$1 = "scope";
var View2 = "view";
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_)) return true;
  if (isObject(_)) for (const key2 in _) {
    if (hasSignal(_[key2])) return true;
  }
  return false;
}
function value2(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}
var Timer = "timer";
function parseStream3(stream2, scope) {
  const method2 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
  return method2(stream2, scope);
}
function eventSource(source4) {
  return source4 === Scope$1 ? View2 : source4 || View2;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s) => parseStream3(s, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id2 = parseStream3(stream2.stream, scope), entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id2;
  if (stream2.type === Timer) {
    id2 = scope.event(Timer, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id2 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id2 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error('Stream "between" parameter must have 2 entries: ' + $(stream2));
    }
    entry2.between = [parseStream3(param2[0], scope), parseStream3(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope$1) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser2("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type3, name4, role) {
  const item = "event.item";
  return item + (type3 && type3 !== "*" ? "&&" + item + ".mark.marktype==='" + type3 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name4 ? "&&" + item + ".mark.name==='" + name4 + "'" : "");
}
var OP_VALUE_EXPR = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function parseUpdate2(spec, scope, target2) {
  const encode2 = spec.encode, entry2 = {
    target: target2
  };
  let events4 = spec.events, update3 = spec.update, sources = [];
  if (!events4) {
    error("Signal update missing events specification.");
  }
  if (isString(events4)) {
    events4 = eventSelector(events4, scope.isSubscope() ? Scope$1 : View2);
  }
  events4 = array(events4).filter((s) => s.signal || s.scale ? (sources.push(s), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events4.length) {
    sources.push(events4.length > 1 ? {
      merge: events4
    } : events4[0]);
  }
  if (encode2 != null) {
    if (update3) error("Signal encode and update are mutually exclusive.");
    update3 = "encode(item()," + $(encode2) + ")";
  }
  entry2.update = isString(update3) ? parser2(update3, scope) : update3.expr != null ? parser2(update3.expr, scope) : update3.value != null ? update3.value : update3.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update3.signal)
    }
  } : error("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source4) => scope.addUpdate(extend(streamSource(source4, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream3(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s) => s.scale ? 'scale("' + s.scale + '")' : s.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser2(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate2(_, scope, op.id));
  }
}
var transform3 = (name4) => (params2, value3, parent) => entry(name4, value3, params2 || void 0, parent);
var Aggregate2 = transform3("aggregate");
var AxisTicks2 = transform3("axisticks");
var Bound2 = transform3("bound");
var Collect2 = transform3("collect");
var Compare2 = transform3("compare");
var DataJoin2 = transform3("datajoin");
var Encode2 = transform3("encode");
var Expression2 = transform3("expression");
var Facet2 = transform3("facet");
var Field2 = transform3("field");
var Key2 = transform3("key");
var LegendEntries2 = transform3("legendentries");
var Load2 = transform3("load");
var Mark2 = transform3("mark");
var MultiExtent2 = transform3("multiextent");
var MultiValues2 = transform3("multivalues");
var Overlap2 = transform3("overlap");
var Params3 = transform3("params");
var PreFacet2 = transform3("prefacet");
var Projection2 = transform3("projection");
var Proxy2 = transform3("proxy");
var Relay2 = transform3("relay");
var Render2 = transform3("render");
var Scale2 = transform3("scale");
var Sieve2 = transform3("sieve");
var SortItems2 = transform3("sortitems");
var ViewLayout2 = transform3("viewlayout");
var Values2 = transform3("values");
var FIELD_REF_ID = 0;
var MULTIDOMAIN_SORT_OPS = {
  min: "min",
  max: "max",
  count: "sum"
};
function initScale(spec, scope) {
  const type3 = spec.type || "linear";
  if (!isValidScaleType(type3)) {
    error("Unrecognized scale type: " + $(type3));
  }
  scope.addScale(spec.name, {
    type: type3,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key2;
  params2.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice, scope);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key2 in spec) {
    if (has(params2, key2) || key2 === "name") continue;
    params2[key2] = parseLiteral(spec[key2], scope);
  }
}
function parseLiteral(v, scope) {
  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
}
function dataLookupError(name4) {
  error("Can not find data set: " + $(name4));
}
function parseScaleDomain(domain4, spec, scope) {
  if (!domain4) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain4.signal ? scope.signalRef(domain4.signal) : (isArray(domain4) ? explicitDomain : domain4.fields ? multipleDomain : singularDomain)(domain4, spec, scope);
}
function explicitDomain(domain4, spec, scope) {
  return domain4.map((v) => parseLiteral(v, scope));
}
function singularDomain(domain4, spec, scope) {
  const data3 = scope.getData(domain4.data);
  if (!data3) dataLookupError(domain4.data);
  return isDiscrete(spec.type) ? data3.valuesRef(scope, domain4.field, parseSort(domain4.sort, false)) : isQuantile(spec.type) ? data3.domainRef(scope, domain4.field) : data3.extentRef(scope, domain4.field);
}
function multipleDomain(domain4, spec, scope) {
  const data3 = domain4.data, fields = domain4.fields.reduce((dom, d) => {
    d = isString(d) ? {
      data: data3,
      field: d
    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain4, scope, fields);
}
function fieldRef(data3, scope) {
  const name4 = "_:vega:_" + FIELD_REF_ID++, coll = Collect2({});
  if (isArray(data3)) {
    coll.value = {
      $ingest: data3
    };
  } else if (data3.signal) {
    const code = "setdata(" + $(name4) + "," + data3.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name4, [coll, Sieve2({})]);
  return {
    data: name4,
    field: "data"
  };
}
function ordinalMultipleDomain(domain4, scope, fields) {
  const sort3 = parseSort(domain4.sort, true);
  let a, v;
  const counts = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3) dataLookupError(f.data);
    return data3.countsRef(scope, f.field, sort3);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort3) {
    a = sort3.op || "count";
    v = sort3.field ? aggrField(a, sort3.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a = scope.add(Aggregate2(p));
  const c = scope.add(Collect2({
    pulse: ref(a)
  }));
  v = scope.add(Values2({
    field: keyFieldRef,
    sort: scope.sortRef(sort3),
    pulse: ref(c)
  }));
  return ref(v);
}
function parseSort(sort3, multidomain) {
  if (sort3) {
    if (!sort3.field && !sort3.op) {
      if (isObject(sort3)) sort3.field = "key";
      else sort3 = {
        field: "key"
      };
    } else if (!sort3.field && sort3.op !== "count") {
      error("No field provided for sort aggregate op: " + sort3.op);
    } else if (multidomain && sort3.field) {
      if (sort3.op && !MULTIDOMAIN_SORT_OPS[sort3.op]) {
        error("Multiple domain scales can not be sorted using " + sort3.op);
      }
    }
  }
  return sort3;
}
function quantileMultipleDomain(domain4, scope, fields) {
  const values5 = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3) dataLookupError(f.data);
    return data3.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues2({
    values: values5
  })));
}
function numericMultipleDomain(domain4, scope, fields) {
  const extents = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3) dataLookupError(f.data);
    return data3.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent2({
    extents
  })));
}
function parseScaleBins(v, scope) {
  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);
}
function parseScaleNice(nice2, scope) {
  return nice2.signal ? scope.signalRef(nice2.signal) : isObject(nice2) ? {
    interval: parseLiteral(nice2.interval),
    step: parseLiteral(nice2.step)
  } : parseLiteral(nice2);
}
function parseScaleInterpolate(interpolate3, params2) {
  params2.interpolate = parseLiteral(interpolate3.type || interpolate3);
  if (interpolate3.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate3.gamma);
  }
}
function parseScaleRange(spec, scope, params2) {
  const config = scope.config.range;
  let range6 = spec.range;
  if (range6.signal) {
    return scope.signalRef(range6.signal);
  } else if (isString(range6)) {
    if (config && has(config, range6)) {
      spec = extend({}, spec, {
        range: config[range6]
      });
      return parseScaleRange(spec, scope, params2);
    } else if (range6 === "width") {
      range6 = [0, {
        signal: "width"
      }];
    } else if (range6 === "height") {
      range6 = isDiscrete(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error("Unrecognized scale range value: " + $(range6));
    }
  } else if (range6.scheme) {
    params2.scheme = isArray(range6.scheme) ? parseArray(range6.scheme, scope) : parseLiteral(range6.scheme, scope);
    if (range6.extent) params2.schemeExtent = parseArray(range6.extent, scope);
    if (range6.count) params2.schemeCount = parseLiteral(range6.count, scope);
    return;
  } else if (range6.step) {
    params2.rangeStep = parseLiteral(range6.step, scope);
    return;
  } else if (isDiscrete(spec.type) && !isArray(range6)) {
    return parseScaleDomain(range6, spec, scope);
  } else if (!isArray(range6)) {
    error("Unsupported range type: " + $(range6));
  }
  return range6.map((v) => (isArray(v) ? parseArray : parseLiteral)(v, scope));
}
function parseProjection(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name4 in proj) {
    if (name4 === "name") continue;
    params2[name4] = parseParameter$1(proj[name4], name4, scope);
  }
  for (const name4 in config) {
    if (params2[name4] == null) {
      params2[name4] = parseParameter$1(config[name4], name4, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter$1(_, name4, scope) {
  return isArray(_) ? _.map((_2) => parseParameter$1(_2, name4, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name4 === "fit" ? _ : error("Unsupported parameter object: " + $(_));
}
var Top2 = "top";
var Left2 = "left";
var Right2 = "right";
var Bottom2 = "bottom";
var Center2 = "center";
var Vertical = "vertical";
var Start2 = "start";
var Middle2 = "middle";
var End2 = "end";
var Index = "index";
var Label2 = "label";
var Offset = "offset";
var Perc = "perc";
var Perc2 = "perc2";
var Value = "value";
var GuideLabelStyle = "guide-label";
var GuideTitleStyle = "guide-title";
var GroupTitleStyle = "group-title";
var GroupSubtitleStyle = "group-subtitle";
var Symbols2 = "symbol";
var Gradient2 = "gradient";
var Discrete2 = "discrete";
var Size = "size";
var Shape = "shape";
var Fill = "fill";
var Stroke = "stroke";
var StrokeWidth = "strokeWidth";
var StrokeDash = "strokeDash";
var Opacity = "opacity";
var LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
var Skip3 = {
  name: 1,
  style: 1,
  interactive: 1
};
var zero2 = {
  value: 0
};
var one2 = {
  value: 1
};
var GroupMark = "group";
var RectMark = "rect";
var RuleMark = "rule";
var SymbolMark = "symbol";
var TextMark = "text";
function guideGroup(mark2) {
  mark2.type = GroupMark;
  mark2.interactive = mark2.interactive || false;
  return mark2;
}
function lookup5(spec, config) {
  const _ = (name4, dflt) => value2(spec[name4], value2(config[name4], dflt));
  _.isVertical = (s) => Vertical === value2(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value2(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value2(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value2(spec.columns, value2(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name4, encode2) {
  const v = encode2 && (encode2.update && encode2.update[name4] || encode2.enter && encode2.enter[name4]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name4, scope, style2) {
  const s = scope.config.style[style2];
  return s && s[name4];
}
function anchorExpr(s, e2, m) {
  return `item.anchor === '${Start2}' ? ${s} : item.anchor === '${End2}' ? ${e2} : ${m}`;
}
var alignExpr$1 = anchorExpr($(Left2), $(Right2), $(Center2));
function tickBand(_) {
  const v = _("tickBand");
  let offset4 = _("tickOffset"), band2, extra;
  if (!v) {
    band2 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v.signal) {
    band2 = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };
    if (!isObject(offset4)) {
      offset4 = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset4}`
      };
    }
  } else if (v === "extent") {
    band2 = 1;
    extra = true;
    offset4 = 0;
  } else {
    band2 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band2,
    offset: offset4
  };
}
function extendOffset(value3, offset4) {
  return !offset4 ? value3 : !value3 ? offset4 : !isObject(value3) ? {
    value: value3,
    offset: offset4
  } : Object.assign({}, value3, {
    offset: extendOffset(value3.offset, offset4)
  });
}
function guideMark(mark2, extras) {
  if (extras) {
    mark2.name = extras.name;
    mark2.style = extras.style || mark2.style;
    mark2.interactive = !!extras.interactive;
    mark2.encode = extendEncode(mark2.encode, extras, Skip3);
  } else {
    mark2.interactive = false;
  }
  return mark2;
}
function legendGradient(spec, scale6, config, userEncode) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length3 = _.gradientLength();
  let enter, start, stop3, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop3 = [0, 0];
    width2 = thickness;
    height2 = length3;
  } else {
    start = [0, 0];
    stop3 = [1, 0];
    width2 = length3;
    height2 = thickness;
  }
  const encode2 = {
    enter: enter = {
      opacity: zero2,
      x: zero2,
      y: zero2,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend({}, enter, {
      opacity: one2,
      fill: {
        gradient: scale6,
        start,
        stop: stop3
      }
    }),
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode2
  }, userEncode);
}
function legendGradientDiscrete(spec, scale6, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length3 = _.gradientLength();
  let u, v, uu, vv, adjust = "";
  vertical ? (u = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u = "x", uu = "x2", v = "y", vv = "height");
  const enter = {
    opacity: zero2,
    fill: {
      scale: scale6,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + "datum." + Perc,
    mult: length3
  };
  enter[v] = zero2;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length3
  };
  enter[vv] = encoder(thickness);
  const encode2 = {
    enter,
    update: extend({}, enter, {
      opacity: one2
    }),
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
var alignExpr = `datum.${Perc}<=0?"${Left2}":datum.${Perc}>=1?"${Right2}":"${Center2}"`;
var baselineExpr = `datum.${Perc}<=0?"${Bottom2}":datum.${Perc}>=1?"${Top2}":"${Middle2}"`;
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length3 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update3, u, v, adjust = "";
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2,
      text: {
        field: Label2
      }
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value2(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update3.baseline = {
      signal: baselineExpr
    };
    u = "y";
    v = "x";
    adjust = "1-";
  } else {
    enter.align = update3.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: "top"
    };
    u = "x";
    v = "y";
  }
  enter[u] = update3[u] = {
    signal: adjust + "datum." + Perc,
    mult: length3
  };
  enter[v] = update3[v] = thickness;
  thickness.offset = value2(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup5(spec, config), entries3 = userEncode.entries, interactive2 = !!(entries3 && entries3.interactive), name4 = entries3 ? entries3.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`, yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index3 = `datum.${Index}`, ncols = `max(1, ${columns})`;
  let encode2, enter, update3, nrows, sort3;
  yEncode.mult = 0.5;
  encode2 = {
    enter: enter = {
      opacity: zero2,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one2,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero2
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode2, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    // update
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale6) => {
    if (spec[scale6]) {
      update3[scale6] = enter[scale6] = {
        scale: spec[scale6],
        field: Value
      };
    }
  });
  const symbols4 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode2
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode2 = {
    enter: enter = {
      opacity: zero2,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one2,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels3 = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode2
  }, userEncode.labels);
  encode2 = {
    enter: {
      noBound: {
        value: !height2
      },
      // ignore width/height in bounds calc
      width: zero2,
      height: height2 ? encoder(height2) : zero2,
      opacity: zero2
    },
    exit: {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update3.row.signal = `${index3}%${nrows}`;
    update3.column.signal = `floor(${index3} / ${nrows})`;
    sort3 = {
      field: ["row", index3]
    };
  } else {
    update3.row.signal = `floor(${index3} / ${ncols})`;
    update3.column.signal = `${index3} % ${ncols}`;
    sort3 = {
      field: index3
    };
  }
  update3.column.signal = `(${columns})?${update3.column.signal}:${index3}`;
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole2,
    from: dataRef,
    encode: extendEncode(encode2, entries3, Skip3),
    marks: [symbols4, labels3],
    name: name4,
    interactive: interactive2,
    sort: sort3
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup5(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
var isL = 'item.orient === "left"';
var isR = 'item.orient === "right"';
var isLR = `(${isL} || ${isR})`;
var isVG = `datum.vgrad && ${isLR}`;
var baseline = anchorExpr('"top"', '"bottom"', '"middle"');
var alignFlip = anchorExpr('"right"', '"left"', '"center"');
var exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`;
var exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`;
var exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`;
var exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config);
  const encode2 = {
    enter: {
      opacity: zero2
    },
    update: {
      opacity: one2,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function clip2(clip3, scope) {
  let expr2;
  if (isObject(clip3)) {
    if (clip3.signal) {
      expr2 = clip3.signal;
    } else if (clip3.path) {
      expr2 = "pathShape(" + param(clip3.path) + ")";
    } else if (clip3.sphere) {
      expr2 = "geoShape(" + param(clip3.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip3;
}
function param(value3) {
  return isObject(value3) && value3.signal ? value3.signal : $(value3);
}
function getRole(spec) {
  const role = spec.role || "";
  return role.startsWith("axis") || role.startsWith("legend") || role.startsWith("title") ? role : spec.type === GroupMark ? ScopeRole2 : role || MarkRole;
}
function definition2(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def2 = definition(spec.type);
  if (!def2) error("Unrecognized transform type: " + $(spec.type));
  const t2 = entry(def2.type.toLowerCase(), null, parseParameters2(def2, spec, scope));
  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t2));
  t2.metadata = def2.metadata || {};
  return t2;
}
function parseParameters2(def2, spec, scope) {
  const params2 = {}, n = def2.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def2.params[i];
    params2[pdef.name] = parseParameter2(pdef, spec, scope);
  }
  return params2;
}
function parseParameter2(def2, spec, scope) {
  const type3 = def2.type, value3 = spec[def2.name];
  if (type3 === "index") {
    return parseIndexParameter(def2, spec, scope);
  } else if (value3 === void 0) {
    if (def2.required) {
      error("Missing required " + $(spec.type) + " parameter: " + $(def2.name));
    }
    return;
  } else if (type3 === "param") {
    return parseSubParameters(def2, spec, scope);
  } else if (type3 === "projection") {
    return scope.projectionRef(spec[def2.name]);
  }
  return def2.array && !isSignal(value3) ? value3.map((v) => parameterValue(def2, v, scope)) : parameterValue(def2, value3, scope);
}
function parameterValue(def2, value3, scope) {
  const type3 = def2.type;
  if (isSignal(value3)) {
    return isExpr(type3) ? error("Expression references can not be signals.") : isField(type3) ? scope.fieldRef(value3) : isCompare(type3) ? scope.compareRef(value3) : scope.signalRef(value3.signal);
  } else {
    const expr2 = def2.expr || isField(type3);
    return expr2 && outerExpr(value3) ? scope.exprRef(value3.expr, value3.as) : expr2 && outerField(value3) ? fieldRef$1(value3.field, value3.as) : isExpr(type3) ? parser2(value3, scope) : isData(type3) ? ref(scope.getData(value3).values) : isField(type3) ? fieldRef$1(value3) : isCompare(type3) ? scope.compareRef(value3) : value3;
  }
}
function parseIndexParameter(def2, spec, scope) {
  if (!isString(spec.from)) {
    error('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def2, spec, scope) {
  const value3 = spec[def2.name];
  if (def2.array) {
    if (!isArray(value3)) {
      error("Expected an array of sub-parameters. Instead: " + $(value3));
    }
    return value3.map((v) => parseSubParameter(def2, v, scope));
  } else {
    return parseSubParameter(def2, value3, scope);
  }
}
function parseSubParameter(def2, value3, scope) {
  const n = def2.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def2.params[i];
    for (const k2 in pdef.key) {
      if (pdef.key[k2] !== value3[k2]) {
        pdef = null;
        break;
      }
    }
    if (pdef) break;
  }
  if (!pdef) error("Unsupported parameter: " + $(value3));
  const params2 = extend(parseParameters2(pdef, value3, scope), pdef.key);
  return ref(scope.add(Params3(params2)));
}
var outerExpr = (_) => _ && _.expr;
var outerField = (_) => _ && _.field;
var isData = (_) => _ === "data";
var isExpr = (_) => _ === "expr";
var isField = (_) => _ === "field";
var isCompare = (_) => _ === "compare";
function parseData$1(from, group2, scope) {
  let facet, key2, op, dataRef, parent;
  if (!from) {
    dataRef = ref(scope.add(Collect2(null, [{}])));
  } else if (facet = from.facet) {
    if (!group2) error("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from.data) {
        op = parseTransform(extend({
          type: "aggregate",
          groupby: array(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key2 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key2,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}
function DataScope(scope, input, output3, values5, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output3;
  this.values = values5;
  this.aggregate = aggr;
  this.index = {};
}
DataScope.fromEntries = function(scope, entries3) {
  const n = entries3.length, values5 = entries3[n - 1], output3 = entries3[n - 2];
  let input = entries3[0], aggr = null, i = 1;
  if (input && input.type === "load") {
    input = entries3[1];
  }
  scope.add(entries3[0]);
  for (; i < n; ++i) {
    entries3[i].params.pulse = ref(entries3[i - 1]);
    scope.add(entries3[i]);
    if (entries3[i].type === "aggregate") aggr = entries3[i];
  }
  return new DataScope(scope, input, output3, values5, aggr);
};
function fieldKey(field3) {
  return isString(field3) ? field3 : null;
}
function addSortField(scope, p, sort3) {
  const as = aggrField(sort3.op, sort3.field);
  let s;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as) return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort3.op) {
    p.ops.push((s = sort3.op.signal) ? scope.signalRef(s) : sort3.op);
    p.fields.push(scope.fieldRef(sort3.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name4, optype, field3, counts, index3) {
  const cache2 = ds[name4] || (ds[name4] = {}), sort3 = sortKey(counts);
  let k2 = fieldKey(field3), v, op;
  if (k2 != null) {
    scope = ds.scope;
    k2 = k2 + (sort3 ? "|" + sort3 : "");
    v = cache2[k2];
  }
  if (!v) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field3, counts)
    } : {
      field: scope.fieldRef(field3),
      pulse: ref(ds.output)
    };
    if (sort3) params2.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, void 0, params2));
    if (index3) ds.index[field3] = op;
    v = ref(op);
    if (k2 != null) cache2[k2] = v;
  }
  return v;
}
DataScope.prototype = {
  countsRef(scope, field3, sort3) {
    const ds = this, cache2 = ds.counts || (ds.counts = {}), k2 = fieldKey(field3);
    let v, a, p;
    if (k2 != null) {
      scope = ds.scope;
      v = cache2[k2];
    }
    if (!v) {
      p = {
        groupby: scope.fieldRef(field3, "key"),
        pulse: ref(ds.output)
      };
      if (sort3 && sort3.field) addSortField(scope, p, sort3);
      a = scope.add(Aggregate2(p));
      v = scope.add(Collect2({
        pulse: ref(a)
      }));
      v = {
        agg: a,
        ref: ref(v)
      };
      if (k2 != null) cache2[k2] = v;
    } else if (sort3 && sort3.field) {
      addSortField(scope, v.agg.params, sort3);
    }
    return v.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field3) {
    return cache(scope, this, "extent", "extent", field3, false);
  },
  domainRef(scope, field3) {
    return cache(scope, this, "domain", "values", field3, false);
  },
  valuesRef(scope, field3, sort3) {
    return cache(scope, this, "vals", "values", field3, sort3 || true);
  },
  lookupRef(scope, field3) {
    return cache(scope, this, "lookup", "tupleindex", field3, false);
  },
  indataRef(scope, field3) {
    return cache(scope, this, "indata", "tupleindex", field3, true, true);
  }
};
function parseFacet(spec, scope, group2) {
  const facet = spec.from.facet, name4 = facet.name, data3 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error("Facet must have a name: " + $(facet));
  }
  if (!facet.data) {
    error("Facet must reference a data set: " + $(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet2({
      field: scope.fieldRef(facet.field),
      pulse: data3
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet2({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group2.parent)),
      pulse: data3
    }));
  } else {
    error("Facet must specify groupby or field: " + $(facet));
  }
  const subscope = scope.fork(), source4 = subscope.add(Collect2()), values5 = subscope.add(Sieve2({
    pulse: ref(source4)
  }));
  subscope.addData(name4, new DataScope(subscope, source4, source4, values5));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet2({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve2());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name4) {
  const remove2 = spec.remove, insert3 = spec.insert, toggle2 = spec.toggle, modify2 = spec.modify, values5 = spec.values, op = scope.add(operator());
  const update3 = "if(" + spec.trigger + ',modify("' + name4 + '",' + [insert3, remove2, toggle2, modify2, values5].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser2(update3, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group2 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole2 || role === FrameRole2, ops2, op, store, enc, name4, layoutRef, boundRef;
  const nested = role === MarkRole || layout || facet;
  const input = parseData$1(spec.from, group2, scope);
  op = scope.add(DataJoin2({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group2
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect2({
    pulse: joinRef
  }));
  op = scope.add(Mark2({
    markdef: definition2(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip2(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode2(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx = parseTransform(_, scope), md2 = tx.metadata;
      if (md2.generates || md2.changes) {
        error("Mark transforms should not generate new data.");
      }
      if (!md2.nomod) enc.params.mod = true;
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems2({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout2({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound2 = scope.add(Bound2({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound2);
  if (group2) {
    if (nested) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout) ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested) {
      if (layout) ops2.push(layout);
      ops2.push(bound2);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render = scope.add(Render2({
    pulse: boundRef
  })), sieve = scope.add(Sieve2({
    pulse: ref(render)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name4 = spec.name;
    scope.addData(name4, new DataScope(scope, store, render, sieve));
    if (spec.on) spec.on.forEach((on2) => {
      if (on2.insert || on2.remove || on2.toggle) {
        error("Marks only support modify triggers.");
      }
      parseTrigger(on2, scope, name4);
    });
  }
}
function parseOverlap(overlap, source4, scope) {
  const method2 = overlap.method, bound2 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method2) ? scope.signalRef(method2.signal) : method2,
    pulse: source4
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound2) {
    const tol = bound2.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound2.scale);
    params2.boundOrient = bound2.orient;
  }
  return ref(scope.add(Overlap2(params2)));
}
function parseLegend(spec, scope) {
  const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup5(spec, config), legendEncode = encode2.legend || {}, name4 = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style2 = legendEncode.style, scales2 = {};
  let scale6 = 0, entryLayout, params2, children4;
  LegendScales.forEach((s) => spec[s] ? (scales2[s] = spec[s], scale6 = scale6 || spec[s]) : 0);
  if (!scale6) error("Missing valid scale for legend.");
  const type3 = legendType(spec, scope.scaleType(scale6));
  const datum2 = {
    title: spec.title != null,
    scales: scales2,
    type: type3,
    vgrad: type3 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect2(null, [datum2])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries2(params2 = {
    type: type3,
    scale: scope.scaleRef(scale6),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type3 === Gradient2) {
    children4 = [legendGradient(spec, scale6, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
    params2.count = params2.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } else if (type3 === Discrete2) {
    children4 = [legendGradientDiscrete(spec, scale6, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children4 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children4[0].marks);
  }
  children4 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children4,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum2.title) {
    children4.push(legendTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole2,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip3),
    marks: children4,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style2
  }), scope);
}
function legendType(spec, scaleType2) {
  let type3 = spec.type || Symbols2;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type3 = isContinuous(scaleType2) ? Gradient2 : isDiscretizing(scaleType2) ? Discrete2 : Symbols2;
  }
  return type3 !== Gradient2 ? type3 : isDiscretizing(scaleType2) ? Discrete2 : Gradient2;
}
function scaleCount(spec) {
  return LegendScales.reduce((count, type3) => count + (spec[type3] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize2 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser2(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize2})`, scope);
}
function getChannel(name4, spec, marks) {
  return spec[name4] ? `scale("${spec[name4]}",datum)` : getEncoding(name4, marks[0].encode);
}
function getFontSize(encode2, scope, style2) {
  return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style2);
}
var angleExpr = `item.orient==="${Left2}"?-90:item.orient==="${Right2}"?90:0`;
function parseTitle(spec, scope) {
  spec = isString(spec) ? {
    text: spec
  } : spec;
  const _ = lookup5(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name4 = userEncode.name || void 0, interactive2 = userEncode.interactive, style2 = userEncode.style, children4 = [];
  const datum2 = {}, dataRef = ref(scope.add(Collect2(null, [datum2])));
  children4.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children4.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole2,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children4,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style2
  }), scope);
}
function titleEncode(spec) {
  const encode2 = spec.encode;
  return encode2 && encode2.title || extend({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode2);
}
function groupEncode(_, userEncode) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode2, userEncode, Skip3);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero4 = {
    value: 0
  }, text4 = spec.text, encode2 = {
    enter: {
      opacity: zero4
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    text: text4,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero4 = {
    value: 0
  }, text4 = spec.subtitle, encode2 = {
    enter: {
      opacity: zero4
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero4
    }
  };
  addEncoders(encode2, {
    text: text4,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function parseData(data3, scope) {
  const transforms2 = [];
  if (data3.transform) {
    data3.transform.forEach((tx) => {
      transforms2.push(parseTransform(tx, scope));
    });
  }
  if (data3.on) {
    data3.on.forEach((on2) => {
      parseTrigger(on2, scope, data3.name);
    });
  }
  scope.addDataPipeline(data3.name, analyze(data3, scope, transforms2));
}
function analyze(data3, scope, ops2) {
  const output3 = [];
  let source4 = null, modify2 = false, generate3 = false, upstream, i, n, t2, m;
  if (data3.values) {
    if (isSignal(data3.values) || hasSignal(data3.format)) {
      output3.push(load2(scope, data3));
      output3.push(source4 = collect());
    } else {
      output3.push(source4 = collect({
        $ingest: data3.values,
        $format: data3.format
      }));
    }
  } else if (data3.url) {
    if (hasSignal(data3.url) || hasSignal(data3.format)) {
      output3.push(load2(scope, data3));
      output3.push(source4 = collect());
    } else {
      output3.push(source4 = collect({
        $request: data3.url,
        $format: data3.format
      }));
    }
  } else if (data3.source) {
    source4 = upstream = array(data3.source).map((d) => ref(scope.getData(d).output));
    output3.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t2 = ops2[i];
    m = t2.metadata;
    if (!source4 && !m.source) {
      output3.push(source4 = collect());
    }
    output3.push(t2);
    if (m.generates) generate3 = true;
    if (m.modifies && !generate3) modify2 = true;
    if (m.source) source4 = t2;
    else if (m.changes) source4 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output3[0] = Relay2({
      derive: modify2,
      pulse: n ? upstream : upstream[0]
    });
    if (modify2 || n) {
      output3.splice(1, 0, collect());
    }
  }
  if (!source4) output3.push(collect());
  output3.push(Sieve2({}));
  return output3;
}
function collect(values5) {
  const s = Collect2({}, values5);
  s.metadata = {
    source: true
  };
  return s;
}
function load2(scope, data3) {
  return Load2({
    url: data3.url ? scope.property(data3.url) : void 0,
    async: data3.async ? scope.property(data3.async) : void 0,
    values: data3.values ? scope.property(data3.values) : void 0,
    format: scope.objectProperty(data3.format)
  });
}
var isX = (orient2) => orient2 === Bottom2 || orient2 === Top2;
var getSign = (orient2, a, b2) => isSignal(orient2) ? ifLeftTopExpr(orient2.signal, a, b2) : orient2 === Left2 || orient2 === Top2 ? a : b2;
var ifX = (orient2, a, b2) => isSignal(orient2) ? ifXEnc(orient2.signal, a, b2) : isX(orient2) ? a : b2;
var ifY = (orient2, a, b2) => isSignal(orient2) ? ifYEnc(orient2.signal, a, b2) : isX(orient2) ? b2 : a;
var ifTop = (orient2, a, b2) => isSignal(orient2) ? ifTopExpr(orient2.signal, a, b2) : orient2 === Top2 ? {
  value: a
} : {
  value: b2
};
var ifRight = (orient2, a, b2) => isSignal(orient2) ? ifRightExpr(orient2.signal, a, b2) : orient2 === Right2 ? {
  value: a
} : {
  value: b2
};
var ifXEnc = ($orient, a, b2) => ifEnc(`${$orient} === '${Top2}' || ${$orient} === '${Bottom2}'`, a, b2);
var ifYEnc = ($orient, a, b2) => ifEnc(`${$orient} !== '${Top2}' && ${$orient} !== '${Bottom2}'`, a, b2);
var ifLeftTopExpr = ($orient, a, b2) => ifExpr(`${$orient} === '${Left2}' || ${$orient} === '${Top2}'`, a, b2);
var ifTopExpr = ($orient, a, b2) => ifExpr(`${$orient} === '${Top2}'`, a, b2);
var ifRightExpr = ($orient, a, b2) => ifExpr(`${$orient} === '${Right2}'`, a, b2);
var ifEnc = (test2, a, b2) => {
  a = a != null ? encoder(a) : a;
  b2 = b2 != null ? encoder(b2) : b2;
  if (isSimple(a) && isSimple(b2)) {
    a = a ? a.signal || $(a.value) : null;
    b2 = b2 ? b2.signal || $(b2.value) : null;
    return {
      signal: `${test2} ? (${a}) : (${b2})`
    };
  } else {
    return [extend({
      test: test2
    }, a)].concat(b2 || []);
  }
};
var isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
var ifExpr = (test2, a, b2) => ({
  signal: `${test2} ? (${toExpr(a)}) : (${toExpr(b2)})`
});
var ifOrient = ($orient, t2, b2, l, r2) => ({
  signal: (l != null ? `${$orient} === '${Left2}' ? (${toExpr(l)}) : ` : "") + (b2 != null ? `${$orient} === '${Bottom2}' ? (${toExpr(b2)}) : ` : "") + (r2 != null ? `${$orient} === '${Right2}' ? (${toExpr(r2)}) : ` : "") + (t2 != null ? `${$orient} === '${Top2}' ? (${toExpr(t2)}) : ` : "") + "(null)"
});
var toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
var mult = (sign2, value3) => value3 === 0 ? 0 : isSignal(sign2) ? {
  signal: `(${sign2.signal}) * ${value3}`
} : {
  value: sign2 * value3
};
var patch = (value3, base) => {
  const s = value3.signal;
  return s && s.endsWith("(null)") ? {
    signal: s.slice(0, -6) + base.signal
  } : value3;
};
function fallback(prop, config, axisConfig2, style2) {
  let styleProp;
  if (config && has(config, prop)) {
    return config[prop];
  } else if (has(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys2(objects) {
  const map2 = {};
  for (const obj of objects) {
    if (!obj) continue;
    for (const key2 in obj) map2[key2] = 1;
  }
  return Object.keys(map2);
}
function axisConfig(spec, scope) {
  var config = scope.config, style2 = config.style, axis = config.axis, band2 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient2 = spec.orient, xy, or2, key2;
  if (isSignal(orient2)) {
    const xyKeys = keys2([config.axisX, config.axisY]), orientKeys = keys2([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key2 of xyKeys) {
      xy[key2] = ifX(orient2, fallback(key2, config.axisX, axis, style2), fallback(key2, config.axisY, axis, style2));
    }
    or2 = {};
    for (key2 of orientKeys) {
      or2[key2] = ifOrient(orient2.signal, fallback(key2, config.axisTop, axis, style2), fallback(key2, config.axisBottom, axis, style2), fallback(key2, config.axisLeft, axis, style2), fallback(key2, config.axisRight, axis, style2));
    }
  } else {
    xy = orient2 === Top2 || orient2 === Bottom2 ? config.axisX : config.axisY;
    or2 = config["axis" + orient2[0].toUpperCase() + orient2.slice(1)];
  }
  const result = xy || or2 || band2 ? extend({}, axis, xy, or2, band2) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient2 = spec.orient;
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update3.x = ifX(orient2, pos0, zero2);
  enter.x2 = update3.x2 = ifX(orient2, pos1);
  enter.y = update3.y = ifY(orient2, pos0, zero2);
  enter.y2 = update3.y2 = ifY(orient2, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band2) {
  const _ = lookup5(spec, config), orient2 = spec.orient, vscale = spec.gridScale, sign2 = getSign(orient2, 1, -1), offset4 = offsetValue2(spec.offset, sign2);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2
    },
    exit: exit = {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  const sz2 = ifX(orient2, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign2,
    offset: offset4
  } : {
    value: 0,
    offset: offset4
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign2,
    offset: offset4
  } : extend(sz2, {
    mult: sign2,
    offset: offset4
  });
  enter.x = update3.x = ifX(orient2, tickPos, gridStart);
  enter.y = update3.y = ifY(orient2, tickPos, gridStart);
  enter.x2 = update3.x2 = ifY(orient2, gridEnd);
  enter.y2 = update3.y2 = ifX(orient2, gridEnd);
  exit.x = ifX(orient2, tickPos);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function offsetValue2(offset4, sign2) {
  if (sign2 === 1) ;
  else if (!isObject(offset4)) {
    offset4 = isSignal(sign2) ? {
      signal: `(${sign2.signal}) * (${offset4 || 0})`
    } : sign2 * (offset4 || 0);
  } else {
    let entry2 = offset4 = extend({}, offset4);
    while (entry2.mult != null) {
      if (!isObject(entry2.mult)) {
        entry2.mult = isSignal(sign2) ? {
          signal: `(${entry2.mult}) * (${sign2.signal})`
        } : entry2.mult * sign2;
        return offset4;
      } else {
        entry2 = entry2.mult = extend({}, entry2.mult);
      }
    }
    entry2.mult = sign2;
  }
  return offset4;
}
function axisTicks(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient2 = spec.orient, sign2 = getSign(orient2, -1, 1);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2
    },
    exit: exit = {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign2;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  update3.y = enter.y = ifX(orient2, zero2, tickPos);
  update3.y2 = enter.y2 = ifX(orient2, tickSize);
  exit.x = ifX(orient2, tickPos);
  update3.x = enter.x = ifY(orient2, zero2, tickPos);
  update3.x2 = enter.x2 = ifY(orient2, tickSize);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function flushExpr(scale6, threshold2, a, b2, c) {
  return {
    signal: 'flush(range("' + scale6 + '"), scale("' + scale6 + '", datum.value), ' + threshold2 + "," + a + "," + b2 + "," + c + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient2 = spec.orient, scale6 = spec.scale, sign2 = getSign(orient2, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush2 === 0 || !!flush2, update3;
  const tickSize = encoder(size);
  tickSize.mult = sign2;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign2;
  const tickPos = {
    scale: scale6,
    field: Value,
    band: 0.5,
    offset: extendOffset(band2.offset, _("labelOffset"))
  };
  const align2 = ifX(orient2, flushOn ? flushExpr(scale6, flush2, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient2, "left", "right"));
  const baseline3 = ifX(orient2, ifTop(orient2, "bottom", "top"), flushOn ? flushExpr(scale6, flush2, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr = flushExpr(scale6, flush2, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero2,
    x: ifX(orient2, tickPos, tickSize),
    y: ifY(orient2, tickPos, tickSize)
  };
  const encode2 = {
    enter,
    update: update3 = {
      opacity: one2,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y,
      align: align2,
      baseline: baseline3
    },
    exit: {
      opacity: zero2,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode2, {
    dx: !labelAlign && flushOn ? ifX(orient2, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient2, offsetExpr) : null
  });
  addEncoders(encode2, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound2 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound2 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound2 ? {
      scale: scale6,
      orient: orient2,
      tolerance: bound2
    } : null
  } : void 0;
  if (update3.align !== align2) {
    update3.align = patch(update3.align, align2);
  }
  if (update3.baseline !== baseline3) {
    update3.baseline = patch(update3.baseline, baseline3);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient2 = spec.orient, sign2 = getSign(orient2, -1, 1);
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update3 = extend({}, enter, {
      opacity: one2,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero2
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update3.x = ifX(orient2, titlePos);
  update3.y = ifY(orient2, titlePos);
  enter.angle = ifX(orient2, zero2, mult(sign2, 90));
  enter.baseline = ifX(orient2, ifTop(orient2, Bottom2, Top2), {
    value: Bottom2
  });
  update3.angle = enter.angle;
  update3.baseline = enter.baseline;
  addEncoders(encode2, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient2, encode2, userEncode);
  encode2.update.align = patch(encode2.update.align, enter.align);
  encode2.update.angle = patch(encode2.update.angle, enter.angle);
  encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function autoLayout(_, orient2, encode2, userEncode) {
  const auto = (value3, dim) => value3 != null ? (encode2.update[dim] = patch(encoder(value3), encode2.update[dim]), false) : !has2(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient2, encoder(autoX), encoder(autoY));
}
function parseAxis(spec, scope) {
  const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name4 = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style2 = axisEncode.style, _ = lookup5(spec, config), band2 = tickBand(_);
  const datum2 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect2({}, [datum2])));
  const ticksRef = ref(scope.add(AxisTicks2({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band2.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children4 = [];
  let size;
  if (datum2.grid) {
    children4.push(axisGrid(spec, config, encode2.grid, ticksRef, band2));
  }
  if (datum2.ticks) {
    size = _("tickSize");
    children4.push(axisTicks(spec, config, encode2.ticks, ticksRef, size, band2));
  }
  if (datum2.labels) {
    size = datum2.ticks ? size : 0;
    children4.push(axisLabels(spec, config, encode2.labels, ticksRef, size, band2));
  }
  if (datum2.domain) {
    children4.push(axisDomain(spec, config, encode2.domain, dataRef));
  }
  if (datum2.title) {
    children4.push(axisTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole2,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip3),
    marks: children4,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style2
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value2(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _("translate"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array(spec.signals), scales2 = array(spec.scales);
  if (!preprocessed) signals.forEach((_) => parseSignal(_, scope));
  array(spec.projections).forEach((_) => parseProjection(_, scope));
  scales2.forEach((_) => initScale(_, scope));
  array(spec.data).forEach((_) => parseData(_, scope));
  scales2.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array(spec.axes).forEach((_) => parseAxis(_, scope));
  array(spec.marks).forEach((_) => parseMark(_, scope));
  array(spec.legends).forEach((_) => parseLegend(_, scope));
  if (spec.title) parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
var rootEncode = (spec) => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;
  const root = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect2());
  const encode2 = scope.add(Encode2(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole2, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout2({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root,
    pulse: ref(encode2)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode2), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound2({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render2({
    pulse: ref(op)
  }));
  op = scope.add(Sieve2({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name4, value3) {
  return value3 && value3.signal ? {
    name: name4,
    update: value3.signal
  } : {
    name: name4,
    value: value3
  };
}
function collectSignals(spec, config) {
  const _ = (name4) => value2(spec[name4], config[name4]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s) => (p[s.name] = s, p), {}), map2 = {};
  array(spec.signals).forEach((s) => {
    if (has(pre, s.name)) {
      s = extend(pre[s.name], s);
    } else {
      signals.push(s);
    }
    map2[s.name] = s;
  });
  array(config.signals).forEach((s) => {
    if (!has(map2, s.name) && !has(pre, s.name)) {
      signals.push(s);
    }
  });
  return signals;
}
function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    if (op.refs) {
      op.refs.forEach((ref2) => {
        ref2.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy2({
      value: vref
    }));
  },
  addStream(stream2) {
    this.streams.push(stream2);
    stream2.id = this.id();
    return stream2;
  },
  addUpdate(update3) {
    this.updates.push(update3);
    return update3;
  },
  // Apply metadata
  finish() {
    let name4, ds;
    if (this.root) this.root.root = true;
    for (name4 in this.signals) {
      this.signals[name4].signal = name4;
    }
    for (name4 in this.scales) {
      this.scales[name4].scale = name4;
    }
    function annotate(op, name5, type3) {
      let data3, list;
      if (op) {
        data3 = op.data || (op.data = {});
        list = data3[name5] || (data3[name5] = []);
        list.push(type3);
      }
    }
    for (name4 in this.data) {
      ds = this.data[name4];
      annotate(ds.input, name4, "input");
      annotate(ds.output, name4, "output");
      annotate(ds.values, name4, "values");
      for (const field3 in ds.index) {
        annotate(ds.index[field3], name4, "index:" + field3);
      }
    }
    return this;
  },
  // ----
  pushState(encode2, parent, lookup6) {
    this._encode.push(ref(this.add(Sieve2({
      pulse: encode2
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup6 ? ref(this.proxy(lookup6)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return peek(this._parent);
  },
  encode() {
    return peek(this._encode);
  },
  lookup() {
    return peek(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  // ----
  fieldRef(field3, name4) {
    if (isString(field3)) return fieldRef$1(field3, name4);
    if (!field3.signal) {
      error("Unsupported field reference: " + $(field3));
    }
    const s = field3.signal;
    let f = this.field[s];
    if (!f) {
      const params2 = {
        name: this.signalRef(s)
      };
      if (name4) params2.as = name4;
      this.field[s] = f = ref(this.add(Field2(params2)));
    }
    return f;
  },
  compareRef(cmp2) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = array(cmp2.field).map(check), orders = array(cmp2.order).map(check);
    return signal ? ref(this.add(Compare2({
      fields,
      orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = array(fields).map(check);
    return signal ? ref(this.add(Key2({
      fields,
      flat
    }))) : keyRef(fields, flat);
  },
  sortRef(sort3) {
    if (!sort3) return sort3;
    const a = aggrField(sort3.op, sort3.field), o = sort3.order || Ascending;
    return o.signal ? ref(this.add(Compare2({
      fields: a,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a, o);
  },
  // ----
  event(source4, type3) {
    const key2 = source4 + ":" + type3;
    if (!this.events[key2]) {
      const id2 = this.id();
      this.streams.push({
        id: id2,
        source: source4,
        type: type3
      });
      this.events[key2] = id2;
    }
    return this.events[key2];
  },
  // ----
  hasOwnSignal(name4) {
    return has(this.signals, name4);
  },
  addSignal(name4, value3) {
    if (this.hasOwnSignal(name4)) {
      error("Duplicate signal name: " + $(name4));
    }
    const op = value3 instanceof Entry ? value3 : this.add(operator(value3));
    return this.signals[name4] = op;
  },
  getSignal(name4) {
    if (!this.signals[name4]) {
      error("Unrecognized signal name: " + $(name4));
    }
    return this.signals[name4];
  },
  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!has(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }
    return ref(this.lambdas[s]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i], e2 = parser2(s, this), op = this.lambdas[s];
      op.params = e2.$params;
      op.update = e2.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name4) {
    const params2 = {
      expr: parser2(code, this)
    };
    if (name4) params2.expr.$name = name4;
    return ref(this.add(Expression2(params2)));
  },
  addBinding(name4, bind3) {
    if (!this.bindings) {
      error("Nested signals do not support binding: " + $(name4));
    }
    this.bindings.push(extend({
      signal: name4
    }, bind3));
  },
  // ----
  addScaleProj(name4, transform4) {
    if (has(this.scales, name4)) {
      error("Duplicate scale or projection name: " + $(name4));
    }
    this.scales[name4] = this.add(transform4);
  },
  addScale(name4, params2) {
    this.addScaleProj(name4, Scale2(params2));
  },
  addProjection(name4, params2) {
    this.addScaleProj(name4, Projection2(params2));
  },
  getScale(name4) {
    if (!this.scales[name4]) {
      error("Unrecognized scale name: " + $(name4));
    }
    return this.scales[name4];
  },
  scaleRef(name4) {
    return ref(this.getScale(name4));
  },
  scaleType(name4) {
    return this.getScale(name4).params.type;
  },
  projectionRef(name4) {
    return this.scaleRef(name4);
  },
  projectionType(name4) {
    return this.scaleType(name4);
  },
  // ----
  addData(name4, dataScope) {
    if (has(this.data, name4)) {
      error("Duplicate data set name: " + $(name4));
    }
    return this.data[name4] = dataScope;
  },
  getData(name4) {
    if (!this.data[name4]) {
      error("Undefined data set name: " + $(name4));
    }
    return this.data[name4];
  },
  addDataPipeline(name4, entries3) {
    if (has(this.data, name4)) {
      error("Duplicate data set name: " + $(name4));
    }
    return this.addData(name4, DataScope.fromEntries(this, entries3));
  }
};
function propertyLambda(spec) {
  return (isArray(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array4) {
  const n = array4.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value3 = array4[i];
    code += (i > 0 ? "," : "") + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key2, value3;
  for (key2 in obj) {
    value3 = obj[key2];
    code += (++i > 1 ? "," : "") + $(key2) + ":" + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "}";
}
function defaults() {
  const defaultFont2 = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray = "#888", lightGray = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont2,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: black,
        font: defaultFont2,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: black,
        font: defaultFont2,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: lightGray
      },
      view: {
        fill: "transparent"
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse6(spec, config, options) {
  if (!isObject(spec)) {
    error("Input Vega specification must be an object.");
  }
  config = mergeConfig(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}

// node_modules/vega/build/vega.module.js
var version = "5.32.0";
extend(transforms, vega_transforms_module_exports, vega_view_transforms_module_exports, vega_encode_module_exports, vega_geo_module_exports, vega_force_module_exports, vega_label_module_exports, vega_hierarchy_module_exports, vega_regression_module_exports, vega_voronoi_module_exports, vega_wordcloud_module_exports, vega_crossfilter_module_exports);

// node_modules/vega-interpreter/build/vega-interpreter.module.js
function adjustSpatial2(item, encode2, swap) {
  let t2;
  if (encode2.x2) {
    if (encode2.x) {
      if (swap && item.x > item.x2) {
        t2 = item.x;
        item.x = item.x2;
        item.x2 = t2;
      }
      item.width = item.x2 - item.x;
    } else {
      item.x = item.x2 - (item.width || 0);
    }
  }
  if (encode2.xc) {
    item.x = item.xc - (item.width || 0) / 2;
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (swap && item.y > item.y2) {
        t2 = item.y;
        item.y = item.y2;
        item.y2 = t2;
      }
      item.height = item.y2 - item.y;
    } else {
      item.y = item.y2 - (item.height || 0);
    }
  }
  if (encode2.yc) {
    item.y = item.yc - (item.height || 0) / 2;
  }
}
var Constants2 = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
};
var Ops = {
  "*": (a, b2) => a * b2,
  "+": (a, b2) => a + b2,
  "-": (a, b2) => a - b2,
  "/": (a, b2) => a / b2,
  "%": (a, b2) => a % b2,
  ">": (a, b2) => a > b2,
  "<": (a, b2) => a < b2,
  "<=": (a, b2) => a <= b2,
  ">=": (a, b2) => a >= b2,
  "==": (a, b2) => a == b2,
  "!=": (a, b2) => a != b2,
  "===": (a, b2) => a === b2,
  "!==": (a, b2) => a !== b2,
  "&": (a, b2) => a & b2,
  "|": (a, b2) => a | b2,
  "^": (a, b2) => a ^ b2,
  "<<": (a, b2) => a << b2,
  ">>": (a, b2) => a >> b2,
  ">>>": (a, b2) => a >>> b2
};
var Unary = {
  "+": (a) => +a,
  "-": (a) => -a,
  "~": (a) => ~a,
  "!": (a) => !a
};
var slice3 = Array.prototype.slice;
var apply2 = (m, args, cast) => {
  const obj = cast ? cast(args[0]) : args[0];
  return obj[m].apply(obj, slice3.call(args, 1));
};
var datetime = (y2, m, d, H, M, S, ms) => new Date(y2, m || 0, d != null ? d : 1, H || 0, M || 0, S || 0, ms || 0);
var Functions2 = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (a, b2, c) => Math.max(b2, Math.min(c, a)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime,
  date: (d) => new Date(d).getDate(),
  day: (d) => new Date(d).getDay(),
  year: (d) => new Date(d).getFullYear(),
  month: (d) => new Date(d).getMonth(),
  hours: (d) => new Date(d).getHours(),
  minutes: (d) => new Date(d).getMinutes(),
  seconds: (d) => new Date(d).getSeconds(),
  milliseconds: (d) => new Date(d).getMilliseconds(),
  time: (d) => new Date(d).getTime(),
  timezoneoffset: (d) => new Date(d).getTimezoneOffset(),
  utcdate: (d) => new Date(d).getUTCDate(),
  utcday: (d) => new Date(d).getUTCDay(),
  utcyear: (d) => new Date(d).getUTCFullYear(),
  utcmonth: (d) => new Date(d).getUTCMonth(),
  utchours: (d) => new Date(d).getUTCHours(),
  utcminutes: (d) => new Date(d).getUTCMinutes(),
  utcseconds: (d) => new Date(d).getUTCSeconds(),
  utcmilliseconds: (d) => new Date(d).getUTCMilliseconds(),
  // sequence functions
  length: (x2) => x2.length,
  join: function() {
    return apply2("join", arguments);
  },
  indexof: function() {
    return apply2("indexOf", arguments);
  },
  lastindexof: function() {
    return apply2("lastIndexOf", arguments);
  },
  slice: function() {
    return apply2("slice", arguments);
  },
  reverse: (x2) => x2.slice().reverse(),
  // string functions
  parseFloat,
  parseInt,
  upper: (x2) => String(x2).toUpperCase(),
  lower: (x2) => String(x2).toLowerCase(),
  substring: function() {
    return apply2("substring", arguments, String);
  },
  split: function() {
    return apply2("split", arguments, String);
  },
  replace: function() {
    return apply2("replace", arguments, String);
  },
  trim: (x2) => String(x2).trim(),
  // regexp functions
  regexp: RegExp,
  test: (r2, t2) => RegExp(r2).test(t2)
};
var EventFunctions = ["view", "item", "group", "xy", "x", "y"];
var Visitors = {
  Literal: ($2, n) => n.value,
  Identifier: ($2, n) => {
    const id2 = n.name;
    return $2.memberDepth > 0 ? id2 : id2 === "datum" ? $2.datum : id2 === "event" ? $2.event : id2 === "item" ? $2.item : Constants2[id2] || $2.params["$" + id2];
  },
  MemberExpression: ($2, n) => {
    const d = !n.computed, o = $2(n.object);
    if (d) $2.memberDepth += 1;
    const p = $2(n.property);
    if (d) $2.memberDepth -= 1;
    return o[p];
  },
  CallExpression: ($2, n) => {
    const args = n.arguments;
    let name4 = n.callee.name;
    if (name4.startsWith("_")) {
      name4 = name4.slice(1);
    }
    return name4 === "if" ? $2(args[0]) ? $2(args[1]) : $2(args[2]) : ($2.fn[name4] || Functions2[name4]).apply($2.fn, args.map($2));
  },
  ArrayExpression: ($2, n) => n.elements.map($2),
  BinaryExpression: ($2, n) => Ops[n.operator]($2(n.left), $2(n.right)),
  UnaryExpression: ($2, n) => Unary[n.operator]($2(n.argument)),
  ConditionalExpression: ($2, n) => $2(n.test) ? $2(n.consequent) : $2(n.alternate),
  LogicalExpression: ($2, n) => n.operator === "&&" ? $2(n.left) && $2(n.right) : $2(n.left) || $2(n.right),
  ObjectExpression: ($2, n) => n.properties.reduce((o, p) => {
    $2.memberDepth += 1;
    const k2 = $2(p.key);
    $2.memberDepth -= 1;
    o[k2] = $2(p.value);
    return o;
  }, {})
};
function interpret(ast, fn, params2, datum2, event2, item) {
  const $2 = (n) => Visitors[n.type]($2, n);
  $2.memberDepth = 0;
  $2.fn = Object.create(fn);
  $2.params = params2;
  $2.datum = datum2;
  $2.event = event2;
  $2.item = item;
  EventFunctions.forEach((f) => $2.fn[f] = (...args) => event2.vega[f](...args));
  return $2(ast);
}
var expression2 = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (_) => interpret(ast, fn, _);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (datum2, _) => interpret(ast, fn, _, datum2);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (event2) => interpret(ast, fn, void 0, void 0, event2);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (_, event2) => {
      const datum2 = event2.item && event2.item.datum;
      return interpret(ast, fn, _, datum2, event2);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(ctx, encode2) {
    const {
      marktype,
      channels
    } = encode2, fn = ctx.functions, swap = marktype === "group" || marktype === "image" || marktype === "rect";
    return (item, _) => {
      const datum2 = item.datum;
      let m = 0, v;
      for (const name4 in channels) {
        v = interpret(channels[name4].ast, fn, _, datum2, void 0, item);
        if (item[name4] !== v) {
          item[name4] = v;
          m = 1;
        }
      }
      if (marktype !== "rule") {
        adjustSpatial2(item, channels, swap);
      }
      return m;
    };
  }
};

// node_modules/vega-lite/build/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  accessPathDepth: () => accessPathDepth,
  accessPathWithDatum: () => accessPathWithDatum,
  compile: () => compile,
  contains: () => contains2,
  deepEqual: () => deepEqual,
  deleteNestedProperty: () => deleteNestedProperty,
  duplicate: () => duplicate,
  entries: () => entries,
  every: () => every,
  fieldIntersection: () => fieldIntersection,
  flatAccessWithDatum: () => flatAccessWithDatum,
  getFirstDefined: () => getFirstDefined,
  hasIntersection: () => hasIntersection,
  hash: () => hash,
  internalField: () => internalField,
  isBoolean: () => isBoolean3,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isInternalField: () => isInternalField,
  isNullOrFalse: () => isNullOrFalse,
  isNumeric: () => isNumeric,
  keys: () => keys3,
  logicalExpr: () => logicalExpr,
  mergeDeep: () => mergeDeep,
  never: () => never,
  normalize: () => normalize,
  normalizeAngle: () => normalizeAngle,
  omit: () => omit,
  pick: () => pick2,
  prefixGenerator: () => prefixGenerator,
  removePathFromField: () => removePathFromField,
  replaceAll: () => replaceAll,
  replacePathInField: () => replacePathInField,
  resetIdCounter: () => resetIdCounter,
  setEqual: () => setEqual,
  some: () => some,
  stringify: () => stringify,
  titleCase: () => titleCase,
  unique: () => unique,
  uniqueId: () => uniqueId,
  vals: () => vals,
  varName: () => varName,
  version: () => version2
});

// node_modules/vega-lite/build/package.json
var package_default = {
  name: "vega-lite",
  author: 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer',
  version: "5.2.0",
  collaborators: [
    "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
    "Dominik Moritz (https://www.domoritz.de)",
    "Arvind Satyanarayan (https://arvindsatya.com)",
    "Jeffrey Heer (https://jheer.org)"
  ],
  homepage: "https://vega.github.io/vega-lite/",
  description: "Vega-Lite is a concise high-level language for interactive visualization.",
  keywords: [
    "vega",
    "chart",
    "visualization"
  ],
  main: "build/vega-lite.js",
  unpkg: "build/vega-lite.min.js",
  jsdelivr: "build/vega-lite.min.js",
  module: "build/src/index",
  types: "build/src/index.d.ts",
  bin: {
    vl2png: "./bin/vl2png",
    vl2svg: "./bin/vl2svg",
    vl2pdf: "./bin/vl2pdf",
    vl2vg: "./bin/vl2vg"
  },
  files: [
    "bin",
    "build",
    "src",
    "vega-lite*",
    "tsconfig.json"
  ],
  scripts: {
    changelog: "conventional-changelog -p angular -r 2",
    prebuild: "yarn clean:build",
    build: "yarn build:only",
    "build:only": "tsc -p tsconfig.build.json && rollup -c",
    "prebuild:examples": "yarn build:only",
    "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
    "prebuild:examples-full": "yarn build:only",
    "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
    "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
    "build:toc": "yarn build:jekyll && scripts/generate-toc",
    "build:site": "rollup -c site/rollup.config.js",
    "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
    "build:versions": "scripts/update-version.sh",
    clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
    "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
    "predeploy:site": "yarn presite",
    "deploy:site": "gh-pages -d site",
    data: "rsync -r node_modules/vega-datasets/data/* site/data",
    schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
    renameschema: "scripts/rename-schema.sh",
    presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
    site: "yarn site:only",
    "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
    prettierbase: "prettier '**/*.{md,css,yml}'",
    eslintbase: "eslint .",
    format: "yarn eslintbase --fix && yarn prettierbase --write",
    lint: "yarn eslintbase && yarn prettierbase --check",
    jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
    test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
    "test:cover": "yarn jest --collectCoverage test/",
    "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
    "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
    "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
    watch: "tsc -p tsconfig.build.json -w",
    "watch:site": "yarn build:site -w",
    "watch:test": "yarn jest --watch test/",
    "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
    release: "yarn run prebuild && yarn build && yarn shipit",
    shipit: "auto shipit"
  },
  repository: {
    type: "git",
    url: "https://github.com/vega/vega-lite.git"
  },
  license: "BSD-3-Clause",
  bugs: {
    url: "https://github.com/vega/vega-lite/issues"
  },
  devDependencies: {
    "@auto-it/conventional-commits": "^10.34.1",
    "@auto-it/first-time-contributor": "^10.34.1",
    "@babel/core": "^7.17.5",
    "@babel/preset-env": "^7.16.11",
    "@babel/preset-typescript": "^7.16.7",
    "@rollup/plugin-alias": "^3.1.9",
    "@rollup/plugin-babel": "^5.3.1",
    "@rollup/plugin-commonjs": "^22.0.0",
    "@rollup/plugin-json": "^4.1.0",
    "@rollup/plugin-node-resolve": "^13.1.3",
    "@types/chai": "^4.3.0",
    "@types/d3": "^7.1.0",
    "@types/jest": "^27.4.1",
    "@types/mkdirp": "^1.0.2",
    "@types/pako": "^2.0.0",
    "@typescript-eslint/eslint-plugin": "^5.14.0",
    "@typescript-eslint/parser": "^5.14.0",
    ajv: "^8.10.0",
    "ajv-formats": "^2.1.1",
    auto: "^10.34.1",
    chai: "^4.3.6",
    cheerio: "^1.0.0-rc.10",
    "conventional-changelog-cli": "^2.2.2",
    d3: "^7.4.4",
    "del-cli": "^5.0.0",
    eslint: "^8.11.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-jest": "^26.1.1",
    "eslint-plugin-prettier": "^4.0.0",
    "gh-pages": "^4.0.0",
    "highlight.js": "^11.5.0",
    jest: "^27.5.1",
    "jest-dev-server": "^6.0.3",
    mkdirp: "^1.0.4",
    pako: "^2.0.4",
    prettier: "^2.5.1",
    puppeteer: "^15.0.0",
    rollup: "^2.70.1",
    "rollup-plugin-bundle-size": "^1.0.3",
    "rollup-plugin-sourcemaps": "^0.6.3",
    "rollup-plugin-terser": "^7.0.2",
    serve: "^14.0.1",
    terser: "^5.12.1",
    "ts-jest": "^27.1.3",
    "ts-json-schema-generator": "^1.0.0",
    "vega-cli": "^5.22.0",
    typescript: "~4.7.2",
    "vega-datasets": "~2.4.0",
    "vega-embed": "^6.20.8",
    "vega-tooltip": "^0.28.0",
    "yaml-front-matter": "^4.1.1"
  },
  dependencies: {
    "@types/clone": "~2.1.1",
    "array-flat-polyfill": "^1.0.1",
    clone: "~2.1.2",
    "fast-deep-equal": "~3.1.3",
    "fast-json-stable-stringify": "~2.1.0",
    "json-stringify-pretty-compact": "~3.0.0",
    tslib: "~2.4.0",
    "vega-event-selector": "~3.0.0",
    "vega-expression": "~5.0.0",
    "vega-util": "~1.17.0",
    yargs: "~17.5.1"
  },
  peerDependencies: {
    vega: "^5.22.0"
  },
  engines: {
    node: ">=12"
  }
};

// node_modules/array-flat-polyfill/index.mjs
Array.prototype.flat || Object.defineProperty(Array.prototype, "flat", { configurable: true, value: function r() {
  var t2 = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
  return t2 ? Array.prototype.reduce.call(this, function(a, e2) {
    return Array.isArray(e2) ? a.push.apply(a, r.call(e2, t2 - 1)) : a.push(e2), a;
  }, []) : Array.prototype.slice.call(this);
}, writable: true }), Array.prototype.flatMap || Object.defineProperty(Array.prototype, "flatMap", { configurable: true, value: function(r2) {
  return Array.prototype.map.apply(this, arguments).flat();
}, writable: true });

// node_modules/vega-lite/build/src/util.js
var import_clone = __toESM(require_clone());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());

// node_modules/vega-lite/build/src/logical.js
function isLogicalOr(op) {
  return !!op.or;
}
function isLogicalAnd(op) {
  return !!op.and;
}
function isLogicalNot(op) {
  return !!op.not;
}
function forEachLeaf(op, fn) {
  if (isLogicalNot(op)) {
    forEachLeaf(op.not, fn);
  } else if (isLogicalAnd(op)) {
    for (const subop of op.and) {
      forEachLeaf(subop, fn);
    }
  } else if (isLogicalOr(op)) {
    for (const subop of op.or) {
      forEachLeaf(subop, fn);
    }
  } else {
    fn(op);
  }
}
function normalizeLogicalComposition(op, normalizer) {
  if (isLogicalNot(op)) {
    return { not: normalizeLogicalComposition(op.not, normalizer) };
  } else if (isLogicalAnd(op)) {
    return { and: op.and.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else if (isLogicalOr(op)) {
    return { or: op.or.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else {
    return normalizer(op);
  }
}

// node_modules/vega-lite/build/src/util.js
var deepEqual = import_fast_deep_equal.default;
var duplicate = import_clone.default;
function never(message) {
  throw new Error(message);
}
function pick2(obj, props) {
  const copy2 = {};
  for (const prop of props) {
    if (has(obj, prop)) {
      copy2[prop] = obj[prop];
    }
  }
  return copy2;
}
function omit(obj, props) {
  const copy2 = Object.assign({}, obj);
  for (const prop of props) {
    delete copy2[prop];
  }
  return copy2;
}
Set.prototype["toJSON"] = function() {
  return `Set(${[...this].map((x2) => (0, import_fast_json_stable_stringify.default)(x2)).join(",")})`;
};
var stringify = import_fast_json_stable_stringify.default;
function hash(a) {
  if (isNumber(a)) {
    return a;
  }
  const str = isString(a) ? a : (0, import_fast_json_stable_stringify.default)(a);
  if (str.length < 250) {
    return str;
  }
  let h2 = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    h2 = (h2 << 5) - h2 + char;
    h2 = h2 & h2;
  }
  return h2;
}
function isNullOrFalse(x2) {
  return x2 === false || x2 === null;
}
function contains2(array4, item) {
  return array4.includes(item);
}
function some(arr, f) {
  let i = 0;
  for (const [k2, a] of arr.entries()) {
    if (f(a, k2, i++)) {
      return true;
    }
  }
  return false;
}
function every(arr, f) {
  let i = 0;
  for (const [k2, a] of arr.entries()) {
    if (!f(a, k2, i++)) {
      return false;
    }
  }
  return true;
}
function mergeDeep(dest, ...src) {
  for (const s of src) {
    deepMerge_(dest, s !== null && s !== void 0 ? s : {});
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (const property2 of keys3(src)) {
    writeConfig(dest, property2, src[property2], true);
  }
}
function unique(values5, f) {
  const results = [];
  const u = {};
  let v;
  for (const val of values5) {
    v = f(val);
    if (v in u) {
      continue;
    }
    u[v] = 1;
    results.push(val);
  }
  return results;
}
function isEqual(dict, other) {
  const dictKeys = keys3(dict);
  const otherKeys = keys3(other);
  if (dictKeys.length !== otherKeys.length) {
    return false;
  }
  for (const key2 of dictKeys) {
    if (dict[key2] !== other[key2]) {
      return false;
    }
  }
  return true;
}
function setEqual(a, b2) {
  if (a.size !== b2.size) {
    return false;
  }
  for (const e2 of a) {
    if (!b2.has(e2)) {
      return false;
    }
  }
  return true;
}
function hasIntersection(a, b2) {
  for (const key2 of a) {
    if (b2.has(key2)) {
      return true;
    }
  }
  return false;
}
function prefixGenerator(a) {
  const prefixes = /* @__PURE__ */ new Set();
  for (const x2 of a) {
    const splitField = splitAccessPath(x2);
    const wrappedWithAccessors = splitField.map((y2, i) => i === 0 ? y2 : `[${y2}]`);
    const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
    for (const y2 of computedPrefixes) {
      prefixes.add(y2);
    }
  }
  return prefixes;
}
function fieldIntersection(a, b2) {
  if (a === void 0 || b2 === void 0) {
    return true;
  }
  return hasIntersection(prefixGenerator(a), prefixGenerator(b2));
}
function isEmpty(obj) {
  return keys3(obj).length === 0;
}
var keys3 = Object.keys;
var vals = Object.values;
var entries = Object.entries;
function isBoolean3(b2) {
  return b2 === true || b2 === false;
}
function varName(s) {
  const alphanumericS = s.replace(/\W/g, "_");
  return (s.match(/^\d+/) ? "_" : "") + alphanumericS;
}
function logicalExpr(op, cb) {
  if (isLogicalNot(op)) {
    return `!(${logicalExpr(op.not, cb)})`;
  } else if (isLogicalAnd(op)) {
    return `(${op.and.map((and) => logicalExpr(and, cb)).join(") && (")})`;
  } else if (isLogicalOr(op)) {
    return `(${op.or.map((or2) => logicalExpr(or2, cb)).join(") || (")})`;
  } else {
    return cb(op);
  }
}
function deleteNestedProperty(obj, orderedProps) {
  if (orderedProps.length === 0) {
    return true;
  }
  const prop = orderedProps.shift();
  if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
    delete obj[prop];
  }
  return isEmpty(obj);
}
function titleCase(s) {
  return s.charAt(0).toUpperCase() + s.substr(1);
}
function accessPathWithDatum(path3, datum2 = "datum") {
  const pieces = splitAccessPath(path3);
  const prefixes = [];
  for (let i = 1; i <= pieces.length; i++) {
    const prefix = `[${pieces.slice(0, i).map($).join("][")}]`;
    prefixes.push(`${datum2}${prefix}`);
  }
  return prefixes.join(" && ");
}
function flatAccessWithDatum(path3, datum2 = "datum") {
  return `${datum2}[${$(splitAccessPath(path3).join("."))}]`;
}
function escapePathAccess(string) {
  return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(path3) {
  return `${splitAccessPath(path3).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(string, find3, replacement) {
  return string.replace(new RegExp(find3.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
}
function removePathFromField(path3) {
  return `${splitAccessPath(path3).join(".")}`;
}
function accessPathDepth(path3) {
  if (!path3) {
    return 0;
  }
  return splitAccessPath(path3).length;
}
function getFirstDefined(...args) {
  for (const arg of args) {
    if (arg !== void 0) {
      return arg;
    }
  }
  return void 0;
}
var idCounter = 42;
function uniqueId(prefix) {
  const id2 = ++idCounter;
  return prefix ? String(prefix) + id2 : id2;
}
function resetIdCounter() {
  idCounter = 42;
}
function internalField(name4) {
  return isInternalField(name4) ? name4 : `__${name4}`;
}
function isInternalField(name4) {
  return name4.startsWith("__");
}
function normalizeAngle(angle) {
  if (angle === void 0) {
    return void 0;
  }
  return (angle % 360 + 360) % 360;
}
function isNumeric(value3) {
  if (isNumber(value3)) {
    return true;
  }
  return !isNaN(value3) && !isNaN(parseFloat(value3));
}

// node_modules/vega-lite/build/src/channel.js
var __rest = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var ROW = "row";
var COLUMN = "column";
var FACET = "facet";
var X2 = "x";
var Y2 = "y";
var X22 = "x2";
var Y22 = "y2";
var XOFFSET = "xOffset";
var YOFFSET = "yOffset";
var RADIUS = "radius";
var RADIUS2 = "radius2";
var THETA = "theta";
var THETA2 = "theta2";
var LATITUDE = "latitude";
var LONGITUDE = "longitude";
var LATITUDE2 = "latitude2";
var LONGITUDE2 = "longitude2";
var COLOR = "color";
var FILL = "fill";
var STROKE = "stroke";
var SHAPE = "shape";
var SIZE2 = "size";
var ANGLE = "angle";
var OPACITY = "opacity";
var FILLOPACITY = "fillOpacity";
var STROKEOPACITY = "strokeOpacity";
var STROKEWIDTH = "strokeWidth";
var STROKEDASH = "strokeDash";
var TEXT = "text";
var ORDER = "order";
var DETAIL = "detail";
var KEY = "key";
var TOOLTIP = "tooltip";
var HREF = "href";
var URL2 = "url";
var DESCRIPTION = "description";
var POSITION_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
};
var POLAR_POSITION_CHANNEL_INDEX = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function isPolarPositionChannel(c) {
  return c in POLAR_POSITION_CHANNEL_INDEX;
}
var GEO_POSIITON_CHANNEL_INDEX = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function getPositionChannelFromLatLong(channel) {
  switch (channel) {
    case LATITUDE:
      return "y";
    case LATITUDE2:
      return "y2";
    case LONGITUDE:
      return "x";
    case LONGITUDE2:
      return "x2";
  }
}
function isGeoPositionChannel(c) {
  return c in GEO_POSIITON_CHANNEL_INDEX;
}
var GEOPOSITION_CHANNELS = keys3(GEO_POSIITON_CHANNEL_INDEX);
var UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {
  xOffset: 1,
  yOffset: 1,
  // color
  color: 1,
  fill: 1,
  stroke: 1,
  // other non-position with scale
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  // channels without scales
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
});
function isColorChannel(channel) {
  return channel === COLOR || channel === FILL || channel === STROKE;
}
var FACET_CHANNEL_INDEX = {
  row: 1,
  column: 1,
  facet: 1
};
var FACET_CHANNELS = keys3(FACET_CHANNEL_INDEX);
var CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);
var CHANNELS = keys3(CHANNEL_INDEX);
var { order: _o, detail: _d, tooltip: _tt1 } = CHANNEL_INDEX;
var SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, ["order", "detail", "tooltip"]);
var { row: _r, column: _c, facet: _f } = SINGLE_DEF_CHANNEL_INDEX;
var SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, ["row", "column", "facet"]);
var SINGLE_DEF_CHANNELS = keys3(SINGLE_DEF_CHANNEL_INDEX);
var SINGLE_DEF_UNIT_CHANNELS = keys3(SINGLE_DEF_UNIT_CHANNEL_INDEX);
function isSingleDefUnitChannel(str) {
  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];
}
function isChannel(str) {
  return !!CHANNEL_INDEX[str];
}
var SECONDARY_RANGE_CHANNEL = [X22, Y22, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];
function isSecondaryRangeChannel(c) {
  const main5 = getMainRangeChannel(c);
  return main5 !== c;
}
function getMainRangeChannel(channel) {
  switch (channel) {
    case X22:
      return X2;
    case Y22:
      return Y2;
    case LATITUDE2:
      return LATITUDE;
    case LONGITUDE2:
      return LONGITUDE;
    case THETA2:
      return THETA;
    case RADIUS2:
      return RADIUS;
  }
  return channel;
}
function getVgPositionChannel(channel) {
  if (isPolarPositionChannel(channel)) {
    switch (channel) {
      case THETA:
        return "startAngle";
      case THETA2:
        return "endAngle";
      case RADIUS:
        return "outerRadius";
      case RADIUS2:
        return "innerRadius";
    }
  }
  return channel;
}
function getSecondaryRangeChannel(channel) {
  switch (channel) {
    case X2:
      return X22;
    case Y2:
      return Y22;
    case LATITUDE:
      return LATITUDE2;
    case LONGITUDE:
      return LONGITUDE2;
    case THETA:
      return THETA2;
    case RADIUS:
      return RADIUS2;
  }
  return void 0;
}
function getSizeChannel(channel) {
  switch (channel) {
    case X2:
    case X22:
      return "width";
    case Y2:
    case Y22:
      return "height";
  }
  return void 0;
}
function getOffsetChannel(channel) {
  switch (channel) {
    case X2:
      return "xOffset";
    case Y2:
      return "yOffset";
    case X22:
      return "x2Offset";
    case Y22:
      return "y2Offset";
    case THETA:
      return "thetaOffset";
    case RADIUS:
      return "radiusOffset";
    case THETA2:
      return "theta2Offset";
    case RADIUS2:
      return "radius2Offset";
  }
  return void 0;
}
function getOffsetScaleChannel(channel) {
  switch (channel) {
    case X2:
      return "xOffset";
    case Y2:
      return "yOffset";
  }
  return void 0;
}
function getMainChannelFromOffsetChannel(channel) {
  switch (channel) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
var UNIT_CHANNELS = keys3(UNIT_CHANNEL_INDEX);
var {
  x: _x,
  y: _y,
  // x2 and y2 share the same scale as x and y
  x2: _x2,
  y2: _y2,
  //
  xOffset: _xo,
  yOffset: _yo,
  latitude: _latitude,
  longitude: _longitude,
  latitude2: _latitude2,
  longitude2: _longitude2,
  theta: _theta,
  theta2: _theta2,
  radius: _radius,
  radius2: _radius2
} = UNIT_CHANNEL_INDEX;
var NONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, ["x", "y", "x2", "y2", "xOffset", "yOffset", "latitude", "longitude", "latitude2", "longitude2", "theta", "theta2", "radius", "radius2"]);
var NONPOSITION_CHANNELS = keys3(NONPOSITION_CHANNEL_INDEX);
var POSITION_SCALE_CHANNEL_INDEX = {
  x: 1,
  y: 1
};
var POSITION_SCALE_CHANNELS = keys3(POSITION_SCALE_CHANNEL_INDEX);
function isXorY(channel) {
  return channel in POSITION_SCALE_CHANNEL_INDEX;
}
var POLAR_POSITION_SCALE_CHANNEL_INDEX = {
  theta: 1,
  radius: 1
};
var POLAR_POSITION_SCALE_CHANNELS = keys3(POLAR_POSITION_SCALE_CHANNEL_INDEX);
function getPositionScaleChannel(sizeType) {
  return sizeType === "width" ? X2 : Y2;
}
var OFFSET_SCALE_CHANNEL_INDEX = { xOffset: 1, yOffset: 1 };
var OFFSET_SCALE_CHANNELS = keys3(OFFSET_SCALE_CHANNEL_INDEX);
function isXorYOffset(channel) {
  return channel in OFFSET_SCALE_CHANNEL_INDEX;
}
var {
  // x2 and y2 share the same scale as x and y
  // text and tooltip have format instead of scale,
  // href has neither format, nor scale
  text: _t,
  tooltip: _tt,
  href: _hr,
  url: _u,
  description: _al,
  // detail and order have no scale
  detail: _dd,
  key: _k,
  order: _oo
} = NONPOSITION_CHANNEL_INDEX;
var NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, ["text", "tooltip", "href", "url", "description", "detail", "key", "order"]);
var NONPOSITION_SCALE_CHANNELS = keys3(NONPOSITION_SCALE_CHANNEL_INDEX);
function isNonPositionScaleChannel(channel) {
  return !!NONPOSITION_CHANNEL_INDEX[channel];
}
function supportLegend(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case SIZE2:
    case SHAPE:
    case OPACITY:
    case STROKEWIDTH:
    case STROKEDASH:
      return true;
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return false;
  }
}
var SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), OFFSET_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);
var SCALE_CHANNELS = keys3(SCALE_CHANNEL_INDEX);
function isScaleChannel(channel) {
  return !!SCALE_CHANNEL_INDEX[channel];
}
function supportMark(channel, mark2) {
  return getSupportedMark(channel)[mark2];
}
var ALL_MARKS = {
  // all marks
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
};
var { geoshape: _g } = ALL_MARKS;
var ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, ["geoshape"]);
function getSupportedMark(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case DESCRIPTION:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case ORDER:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case FACET:
    case ROW:
    case COLUMN:
      return ALL_MARKS;
    case X2:
    case Y2:
    case XOFFSET:
    case YOFFSET:
    case LATITUDE:
    case LONGITUDE:
      return ALL_MARKS_EXCEPT_GEOSHAPE;
    case X22:
    case Y22:
    case LATITUDE2:
    case LONGITUDE2:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case SIZE2:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case STROKEDASH:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case SHAPE:
      return { point: "always", geoshape: "always" };
    case TEXT:
      return { text: "always" };
    case ANGLE:
      return { point: "always", square: "always", text: "always" };
    case URL2:
      return { image: "always" };
    case THETA:
      return { text: "always", arc: "always" };
    case RADIUS:
      return { text: "always", arc: "always" };
    case THETA2:
    case RADIUS2:
      return { arc: "always" };
  }
}
function rangeType(channel) {
  switch (channel) {
    case X2:
    case Y2:
    case THETA:
    case RADIUS:
    case XOFFSET:
    case YOFFSET:
    case SIZE2:
    case ANGLE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case X22:
    case Y22:
    case THETA2:
    case RADIUS2:
      return void 0;
    case FACET:
    case ROW:
    case COLUMN:
    case SHAPE:
    case STROKEDASH:
    case TEXT:
    case TOOLTIP:
    case HREF:
    case URL2:
    case DESCRIPTION:
      return "discrete";
    case COLOR:
    case FILL:
    case STROKE:
      return "flexible";
    case LATITUDE:
    case LONGITUDE:
    case LATITUDE2:
    case LONGITUDE2:
    case DETAIL:
    case KEY:
    case ORDER:
      return void 0;
  }
}

// node_modules/vega-lite/build/src/aggregate.js
var AGGREGATE_OP_INDEX = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
};
var MULTIDOMAIN_SORT_OP_INDEX = {
  count: 1,
  min: 1,
  max: 1
};
function isArgminDef(a) {
  return !!a && !!a["argmin"];
}
function isArgmaxDef(a) {
  return !!a && !!a["argmax"];
}
function isAggregateOp(a) {
  return isString(a) && !!AGGREGATE_OP_INDEX[a];
}
var COUNTING_OPS = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function isCountingAggregateOp(aggregate) {
  return isString(aggregate) && COUNTING_OPS.has(aggregate);
}
function isMinMaxOp(aggregate) {
  return isString(aggregate) && contains2(["min", "max"], aggregate);
}
var SUM_OPS = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]);
var SHARED_DOMAIN_OPS = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);

// node_modules/vega-lite/build/src/bin.js
function binToString(bin3) {
  if (isBoolean(bin3)) {
    bin3 = normalizeBin(bin3, void 0);
  }
  return "bin" + keys3(bin3).map((p) => isParameterExtent(bin3[p]) ? varName(`_${p}_${entries(bin3[p])}`) : varName(`_${p}_${bin3[p]}`)).join("");
}
function isBinning(bin3) {
  return bin3 === true || isBinParams(bin3) && !bin3.binned;
}
function isBinned(bin3) {
  return bin3 === "binned" || isBinParams(bin3) && bin3.binned === true;
}
function isBinParams(bin3) {
  return isObject(bin3);
}
function isParameterExtent(extent2) {
  return extent2 === null || extent2 === void 0 ? void 0 : extent2["param"];
}
function autoMaxBins(channel) {
  switch (channel) {
    case ROW:
    case COLUMN:
    case SIZE2:
    case COLOR:
    case FILL:
    case STROKE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case SHAPE:
      return 6;
    case STROKEDASH:
      return 4;
    default:
      return 10;
  }
}

// node_modules/vega-lite/build/src/expr.js
function isExprRef(o) {
  return !!(o === null || o === void 0 ? void 0 : o.expr);
}
function replaceExprRef(index3) {
  const props = keys3(index3 || {});
  const newIndex = {};
  for (const prop of props) {
    newIndex[prop] = signalRefOrValue(index3[prop]);
  }
  return newIndex;
}

// node_modules/vega-lite/build/src/title.js
var __rest2 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function extractTitleConfig(titleConfig) {
  const {
    // These are non-mark title config that need to be hardcoded
    anchor,
    frame,
    offset: offset4,
    orient: orient2,
    angle,
    limit,
    // color needs to be redirect to fill
    color: color4,
    // subtitle properties
    subtitleColor,
    subtitleFont,
    subtitleFontSize,
    subtitleFontStyle,
    subtitleFontWeight,
    subtitleLineHeight,
    subtitlePadding
  } = titleConfig, rest = __rest2(titleConfig, ["anchor", "frame", "offset", "orient", "angle", "limit", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"]);
  const titleMarkConfig = Object.assign(Object.assign({}, rest), color4 ? { fill: color4 } : {});
  const nonMarkTitleProperties = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, anchor ? { anchor } : {}), frame ? { frame } : {}), offset4 ? { offset: offset4 } : {}), orient2 ? { orient: orient2 } : {}), angle !== void 0 ? { angle } : {}), limit !== void 0 ? { limit } : {});
  const subtitle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, subtitleColor ? { subtitleColor } : {}), subtitleFont ? { subtitleFont } : {}), subtitleFontSize ? { subtitleFontSize } : {}), subtitleFontStyle ? { subtitleFontStyle } : {}), subtitleFontWeight ? { subtitleFontWeight } : {}), subtitleLineHeight ? { subtitleLineHeight } : {}), subtitlePadding ? { subtitlePadding } : {});
  const subtitleMarkConfig = pick2(titleConfig, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig, subtitleMarkConfig, nonMarkTitleProperties, subtitle };
}
function isText(v) {
  return isString(v) || isArray(v) && isString(v[0]);
}

// node_modules/vega-lite/build/src/vega.schema.js
function isSignalRef(o) {
  return !!(o === null || o === void 0 ? void 0 : o.signal);
}
function isVgRangeStep(range6) {
  return !!range6["step"];
}
function isDataRefUnionedDomain(domain4) {
  if (!isArray(domain4)) {
    return "fields" in domain4 && !("data" in domain4);
  }
  return false;
}
function isFieldRefUnionDomain(domain4) {
  if (!isArray(domain4)) {
    return "fields" in domain4 && "data" in domain4;
  }
  return false;
}
function isDataRefDomain(domain4) {
  if (!isArray(domain4)) {
    return "field" in domain4 && "data" in domain4;
  }
  return false;
}
var VG_MARK_CONFIG_INDEX = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
  // commented below are vg channel that do not have mark config.
  // x: 1,
  // y: 1,
  // x2: 1,
  // y2: 1,
  // xc'|'yc'
  // clip: 1,
  // path: 1,
  // url: 1,
};
var VG_MARK_CONFIGS = keys3(VG_MARK_CONFIG_INDEX);
var VG_MARK_INDEX = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var VG_CORNERRADIUS_CHANNELS = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];

// node_modules/vega-lite/build/src/compile/common.js
var __rest3 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function signalOrValueRefWithCondition(val) {
  const condition = isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);
  return Object.assign(Object.assign({}, signalRefOrValue(val)), { condition });
}
function signalRefOrValue(value3) {
  if (isExprRef(value3)) {
    const { expr: expr2 } = value3, rest = __rest3(value3, ["expr"]);
    return Object.assign({ signal: expr2 }, rest);
  }
  return value3;
}
function conditionalSignalRefOrValue(value3) {
  if (isExprRef(value3)) {
    const { expr: expr2 } = value3, rest = __rest3(value3, ["expr"]);
    return Object.assign({ signal: expr2 }, rest);
  }
  return value3;
}
function signalOrValueRef(value3) {
  if (isExprRef(value3)) {
    const { expr: expr2 } = value3, rest = __rest3(value3, ["expr"]);
    return Object.assign({ signal: expr2 }, rest);
  }
  if (isSignalRef(value3)) {
    return value3;
  }
  return value3 !== void 0 ? { value: value3 } : void 0;
}
function exprFromSignalRefOrValue(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $(ref2);
}
function exprFromValueRefOrSignalRef(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $(ref2.value);
}
function signalOrStringValue(v) {
  if (isSignalRef(v)) {
    return v.signal;
  }
  return v == null ? null : $(v);
}
function applyMarkConfig(e2, model, propsList) {
  for (const property2 of propsList) {
    const value3 = getMarkConfig(property2, model.markDef, model.config);
    if (value3 !== void 0) {
      e2[property2] = signalOrValueRef(value3);
    }
  }
  return e2;
}
function getStyles(mark2) {
  var _a;
  return [].concat(mark2.type, (_a = mark2.style) !== null && _a !== void 0 ? _a : []);
}
function getMarkPropOrConfig(channel, mark2, config, opt = {}) {
  const { vgChannel, ignoreVgConfig } = opt;
  if (vgChannel && mark2[vgChannel] !== void 0) {
    return mark2[vgChannel];
  } else if (mark2[channel] !== void 0) {
    return mark2[channel];
  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
    return void 0;
  }
  return getMarkConfig(channel, mark2, config, opt);
}
function getMarkConfig(channel, mark2, config, { vgChannel } = {}) {
  return getFirstDefined(
    // style config has highest precedence
    vgChannel ? getMarkStyleConfig(channel, mark2, config.style) : void 0,
    getMarkStyleConfig(channel, mark2, config.style),
    // then mark-specific config
    vgChannel ? config[mark2.type][vgChannel] : void 0,
    config[mark2.type][channel],
    // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
    // If there is vgChannel, skip vl channel.
    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
    vgChannel ? config.mark[vgChannel] : config.mark[channel]
    // Need to cast for the same reason as above
  );
}
function getMarkStyleConfig(prop, mark2, styleConfigIndex) {
  return getStyleConfig(prop, getStyles(mark2), styleConfigIndex);
}
function getStyleConfig(p, styles, styleConfigIndex) {
  styles = array(styles);
  let value3;
  for (const style2 of styles) {
    const styleConfig = styleConfigIndex[style2];
    if (styleConfig && styleConfig[p] !== void 0) {
      value3 = styleConfig[p];
    }
  }
  return value3;
}
function sortParams(orderDef, fieldRefOption) {
  return array(orderDef).reduce((s, orderChannelDef) => {
    var _a;
    s.field.push(vgField(orderChannelDef, fieldRefOption));
    s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : "ascending");
    return s;
  }, { field: [], order: [] });
}
function mergeTitleFieldDefs(f1, f2) {
  const merged = [...f1];
  f2.forEach((fdToMerge) => {
    for (const fieldDef1 of merged) {
      if (deepEqual(fieldDef1, fdToMerge)) {
        return;
      }
    }
    merged.push(fdToMerge);
  });
  return merged;
}
function mergeTitle(title1, title2) {
  if (deepEqual(title1, title2) || !title2) {
    return title1;
  } else if (!title1) {
    return title2;
  } else {
    return [...array(title1), ...array(title2)].join(", ");
  }
}
function mergeTitleComponent(v1, v2) {
  const v1Val = v1.value;
  const v2Val = v2.value;
  if (v1Val == null || v2Val === null) {
    return {
      explicit: v1.explicit,
      value: null
    };
  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
    return {
      explicit: v1.explicit,
      value: mergeTitle(v1Val, v2Val)
    };
  } else if (isText(v1Val) || isSignalRef(v1Val)) {
    return {
      explicit: v1.explicit,
      value: v1Val
    };
  } else if (isText(v2Val) || isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: v2Val
    };
  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: mergeTitleFieldDefs(v1Val, v2Val)
    };
  }
  throw new Error("It should never reach here");
}

// node_modules/vega-lite/build/src/log/message.js
var message_exports = {};
__export(message_exports, {
  ADD_SAME_CHILD_TWICE: () => ADD_SAME_CHILD_TWICE,
  CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN: () => CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN,
  CONCAT_CANNOT_SHARE_AXIS: () => CONCAT_CANNOT_SHARE_AXIS,
  FACETED_INDEPENDENT_DIFFERENT_SOURCES: () => FACETED_INDEPENDENT_DIFFERENT_SOURCES,
  FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES: () => FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES,
  FACETED_INDEPENDENT_SAME_SOURCE: () => FACETED_INDEPENDENT_SAME_SOURCE,
  FIT_NON_SINGLE: () => FIT_NON_SINGLE,
  INTERVAL_INITIALIZED_WITH_X_Y: () => INTERVAL_INITIALIZED_WITH_X_Y,
  INVALID_CHANNEL_FOR_AXIS: () => INVALID_CHANNEL_FOR_AXIS,
  LEGEND_BINDINGS_MUST_HAVE_PROJECTION: () => LEGEND_BINDINGS_MUST_HAVE_PROJECTION,
  LINE_WITH_VARYING_SIZE: () => LINE_WITH_VARYING_SIZE,
  MORE_THAN_ONE_SORT: () => MORE_THAN_ONE_SORT,
  NEEDS_SAME_SELECTION: () => NEEDS_SAME_SELECTION,
  NO_FIELDS_NEEDS_AS: () => NO_FIELDS_NEEDS_AS,
  REPLACE_ANGLE_WITH_THETA: () => REPLACE_ANGLE_WITH_THETA,
  SCALE_BINDINGS_CONTINUOUS: () => SCALE_BINDINGS_CONTINUOUS,
  cannotApplySizeToNonOrientedMark: () => cannotApplySizeToNonOrientedMark,
  cannotLookupVariableParameter: () => cannotLookupVariableParameter,
  cannotProjectAggregate: () => cannotProjectAggregate,
  cannotProjectOnChannelWithoutField: () => cannotProjectOnChannelWithoutField,
  cannotStackNonLinearScale: () => cannotStackNonLinearScale,
  cannotStackRangedMark: () => cannotStackRangedMark,
  cannotUseRelativeBandSizeWithNonBandScale: () => cannotUseRelativeBandSizeWithNonBandScale,
  cannotUseScalePropertyWithNonColor: () => cannotUseScalePropertyWithNonColor,
  channelRequiredForBinned: () => channelRequiredForBinned,
  channelShouldBeDiscrete: () => channelShouldBeDiscrete,
  channelShouldBeDiscreteOrDiscretizing: () => channelShouldBeDiscreteOrDiscretizing,
  channelShouldNotBeUsedForBinned: () => channelShouldNotBeUsedForBinned,
  columnsNotSupportByRowCol: () => columnsNotSupportByRowCol,
  containerSizeNonSingle: () => containerSizeNonSingle,
  containerSizeNotCompatibleWithAutosize: () => containerSizeNotCompatibleWithAutosize,
  customFormatTypeNotAllowed: () => customFormatTypeNotAllowed,
  differentParse: () => differentParse,
  discreteChannelCannotEncode: () => discreteChannelCannotEncode,
  domainRequiredForThresholdScale: () => domainRequiredForThresholdScale,
  domainSortDropped: () => domainSortDropped,
  droppedDay: () => droppedDay,
  droppingColor: () => droppingColor,
  droppingFit: () => droppingFit,
  emptyFieldDef: () => emptyFieldDef,
  errorBand1DNotSupport: () => errorBand1DNotSupport,
  errorBarCenterAndExtentAreNotNeeded: () => errorBarCenterAndExtentAreNotNeeded,
  errorBarCenterIsUsedWithWrongExtent: () => errorBarCenterIsUsedWithWrongExtent,
  errorBarContinuousAxisHasCustomizedAggregate: () => errorBarContinuousAxisHasCustomizedAggregate,
  facetChannelDropped: () => facetChannelDropped,
  incompatibleChannel: () => incompatibleChannel,
  independentScaleMeansIndependentGuide: () => independentScaleMeansIndependentGuide,
  invalidAggregate: () => invalidAggregate,
  invalidEncodingChannel: () => invalidEncodingChannel,
  invalidFieldType: () => invalidFieldType,
  invalidFieldTypeForCountAggregate: () => invalidFieldTypeForCountAggregate,
  invalidSpec: () => invalidSpec,
  invalidTimeUnit: () => invalidTimeUnit,
  invalidTransformIgnored: () => invalidTransformIgnored,
  lineWithRange: () => lineWithRange,
  mergeConflictingDomainProperty: () => mergeConflictingDomainProperty,
  mergeConflictingProperty: () => mergeConflictingProperty,
  missingFieldType: () => missingFieldType,
  nearestNotSupportForContinuous: () => nearestNotSupportForContinuous,
  noSameUnitLookup: () => noSameUnitLookup,
  noSuchRepeatedValue: () => noSuchRepeatedValue,
  offsetEncodingScaleIgnored: () => offsetEncodingScaleIgnored,
  offsetNestedInsideContinuousPositionScaleDropped: () => offsetNestedInsideContinuousPositionScaleDropped,
  orientOverridden: () => orientOverridden,
  primitiveChannelDef: () => primitiveChannelDef,
  projectionOverridden: () => projectionOverridden,
  rangeMarkAlignmentCannotBeExpression: () => rangeMarkAlignmentCannotBeExpression,
  relativeBandSizeNotSupported: () => relativeBandSizeNotSupported,
  replaceOffsetWithMainChannel: () => replaceOffsetWithMainChannel,
  scalePropertyNotWorkWithScaleType: () => scalePropertyNotWorkWithScaleType,
  scaleTypeNotWorkWithChannel: () => scaleTypeNotWorkWithChannel,
  scaleTypeNotWorkWithFieldDef: () => scaleTypeNotWorkWithFieldDef,
  scaleTypeNotWorkWithMark: () => scaleTypeNotWorkWithMark,
  selectionNotFound: () => selectionNotFound,
  selectionNotSupported: () => selectionNotSupported,
  stackNonSummativeAggregate: () => stackNonSummativeAggregate,
  stepDropped: () => stepDropped,
  unaggregateDomainHasNoEffectForRawField: () => unaggregateDomainHasNoEffectForRawField,
  unaggregateDomainWithNonSharedDomainOp: () => unaggregateDomainWithNonSharedDomainOp,
  unaggregatedDomainWithLogScale: () => unaggregatedDomainWithLogScale,
  unknownField: () => unknownField,
  unrecognizedParse: () => unrecognizedParse
});
function invalidSpec(spec) {
  return `Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
var FIT_NON_SINGLE = 'Autosize "fit" only works for single views and layered views.';
function containerSizeNonSingle(name4) {
  const uName = name4 == "width" ? "Width" : "Height";
  return `${uName} "container" only works for single views and layered views.`;
}
function containerSizeNotCompatibleWithAutosize(name4) {
  const uName = name4 == "width" ? "Width" : "Height";
  const fitDirection = name4 == "width" ? "x" : "y";
  return `${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`;
}
function droppingFit(channel) {
  return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping "fit" because spec has discrete size.`;
}
function unknownField(channel) {
  return `Unknown field for ${channel}. Cannot calculate view size.`;
}
function cannotProjectOnChannelWithoutField(channel) {
  return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
}
function cannotProjectAggregate(channel, aggregate) {
  return `Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`;
}
function nearestNotSupportForContinuous(mark2) {
  return `The "nearest" transform is not supported for ${mark2} marks.`;
}
function selectionNotSupported(mark2) {
  return `Selection not supported for ${mark2} yet.`;
}
function selectionNotFound(name4) {
  return `Cannot find a selection named "${name4}".`;
}
var SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.";
var LEGEND_BINDINGS_MUST_HAVE_PROJECTION = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function cannotLookupVariableParameter(name4) {
  return `Lookups can only be performed on selection parameters. "${name4}" is a variable parameter.`;
}
function noSameUnitLookup(name4) {
  return `Cannot define and lookup the "${name4}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
var NEEDS_SAME_SELECTION = "The same selection must be used to override scale domains in a layered view.";
var INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using "x" and/or "y" keys.';
function noSuchRepeatedValue(field3) {
  return `Unknown repeated value "${field3}".`;
}
function columnsNotSupportByRowCol(type3) {
  return `The "columns" property cannot be used when "${type3}" has nested row/column.`;
}
var CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function unrecognizedParse(p) {
  return `Unrecognized parse "${p}".`;
}
function differentParse(field3, local, ancestor) {
  return `An ancestor parsed field "${field3}" as ${ancestor} but a child wants to parse the field as ${local}.`;
}
var ADD_SAME_CHILD_TWICE = "Attempt to add the same child twice.";
function invalidTransformIgnored(transform4) {
  return `Ignoring an invalid transform: ${stringify(transform4)}.`;
}
var NO_FIELDS_NEEDS_AS = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function customFormatTypeNotAllowed(channel) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
}
function projectionOverridden(opt) {
  const { parentProjection, projection: projection3 } = opt;
  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection3)}.`;
}
var REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {
  return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;
}
function replaceOffsetWithMainChannel(mainChannel) {
  return `There is no ${mainChannel} encoding. Replacing ${mainChannel}Offset encoding as ${mainChannel}.`;
}
function primitiveChannelDef(channel, type3, value3) {
  return `Channel ${channel} is a ${type3}. Converted to {value: ${stringify(value3)}}.`;
}
function invalidFieldType(type3) {
  return `Invalid field type "${type3}".`;
}
function invalidFieldTypeForCountAggregate(type3, aggregate) {
  return `Invalid field type "${type3}" for aggregate: "${aggregate}", using "quantitative" instead.`;
}
function invalidAggregate(aggregate) {
  return `Invalid aggregation operator "${aggregate}".`;
}
function missingFieldType(channel, newType) {
  return `Missing type for channel "${channel}", using "${newType}" instead.`;
}
function droppingColor(type3, opt) {
  const { fill: fill2, stroke: stroke2 } = opt;
  return `Dropping color ${type3} as the plot also has ${fill2 && stroke2 ? "fill and stroke" : fill2 ? "fill" : "stroke"}.`;
}
function relativeBandSizeNotSupported(sizeChannel) {
  return `Position range does not support relative band size for ${sizeChannel}.`;
}
function emptyFieldDef(fieldDef, channel) {
  return `Dropping ${stringify(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
}
var LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function incompatibleChannel(channel, markOrFacet, when) {
  return `${channel} dropped as it is incompatible with "${markOrFacet}"${when ? ` when ${when}` : ""}.`;
}
function offsetEncodingScaleIgnored(channel) {
  return `${channel} encoding has no scale, so specified scale is ignored.`;
}
function invalidEncodingChannel(channel) {
  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;
}
function channelShouldBeDiscrete(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;
}
function channelShouldBeDiscreteOrDiscretizing(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function facetChannelDropped(channels) {
  return `Facet encoding dropped as ${channels.join(" and ")} ${channels.length > 1 ? "are" : "is"} also specified.`;
}
function discreteChannelCannotEncode(channel, type3) {
  return `Using discrete channel "${channel}" to encode "${type3}" field can be misleading as it does not encode ${type3 === "ordinal" ? "order" : "magnitude"}.`;
}
function rangeMarkAlignmentCannotBeExpression(align2) {
  return `The ${align2} for range marks cannot be an expression`;
}
function lineWithRange(hasX2, hasY2) {
  const channels = hasX2 && hasY2 ? "x2 and y2" : hasX2 ? "x2" : "y2";
  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;
}
function orientOverridden(original, actual) {
  return `Specified orient "${original}" overridden with "${actual}".`;
}
var CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = "Custom domain scale cannot be unioned with default field-based domain.";
function cannotUseScalePropertyWithNonColor(prop) {
  return `Cannot use the scale property "${prop}" with non-color channel.`;
}
function cannotUseRelativeBandSizeWithNonBandScale(scaleType2) {
  return `Cannot use the relative band size with ${scaleType2} scale.`;
}
function unaggregateDomainHasNoEffectForRawField(fieldDef) {
  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;
}
function unaggregateDomainWithNonSharedDomainOp(aggregate) {
  return `Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`;
}
function unaggregatedDomainWithLogScale(fieldDef) {
  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;
}
function cannotApplySizeToNonOrientedMark(mark2) {
  return `Cannot apply size to non-oriented mark "${mark2}".`;
}
function scaleTypeNotWorkWithChannel(channel, scaleType2, defaultScaleType) {
  return `Channel "${channel}" does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scaleTypeNotWorkWithFieldDef(scaleType2, defaultScaleType) {
  return `FieldDef does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scalePropertyNotWorkWithScaleType(scaleType2, propName, channel) {
  return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType2} scale.`;
}
function scaleTypeNotWorkWithMark(mark2, scaleType2) {
  return `Scale type "${scaleType2}" does not work with mark "${mark2}".`;
}
function stepDropped(channel) {
  return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
}
function mergeConflictingProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;
}
function mergeConflictingDomainProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;
}
function independentScaleMeansIndependentGuide(channel) {
  return `Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`;
}
function domainSortDropped(sort3) {
  return `Dropping sort property ${stringify(sort3)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
var MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";
var FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";
var FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";
var FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
var INVALID_CHANNEL_FOR_AXIS = "Invalid channel for axis.";
function cannotStackRangedMark(channel) {
  return `Cannot stack "${channel}" if there is already "${channel}2".`;
}
function cannotStackNonLinearScale(scaleType2) {
  return `Cannot stack non-linear scale (${scaleType2}).`;
}
function stackNonSummativeAggregate(aggregate) {
  return `Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`;
}
function invalidTimeUnit(unitName2, value3) {
  return `Invalid ${unitName2}: ${stringify(value3)}.`;
}
function droppedDay(d) {
  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;
}
function errorBarCenterAndExtentAreNotNeeded(center, extent2) {
  return `${extent2 ? "extent " : ""}${extent2 && center ? "and " : ""}${center ? "center " : ""}${extent2 && center ? "are " : "is "}not needed when data are aggregated.`;
}
function errorBarCenterIsUsedWithWrongExtent(center, extent2, mark2) {
  return `${center} is not usually used with ${extent2} for ${mark2}.`;
}
function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {
  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;
}
function errorBand1DNotSupport(property2) {
  return `1D error band does not support ${property2}.`;
}
function channelRequiredForBinned(channel) {
  return `Channel ${channel} is required for "binned" bin.`;
}
function channelShouldNotBeUsedForBinned(channel) {
  return `Channel ${channel} should not be used with "binned" bin.`;
}
function domainRequiredForThresholdScale(channel) {
  return `Domain for ${channel} is required for threshold scale.`;
}

// node_modules/vega-lite/build/src/log/index.js
var _LocalLogger_level;
var main = logger(Warn);
var current = main;
_LocalLogger_level = /* @__PURE__ */ new WeakMap();
function set4(newLogger) {
  current = newLogger;
  return current;
}
function reset2() {
  current = main;
  return current;
}
function warn2(...args) {
  current.warn(...args);
}
function debug2(...args) {
  current.debug(...args);
}

// node_modules/vega-lite/build/src/datetime.js
function isDateTime(o) {
  if (o && isObject(o)) {
    for (const part of TIMEUNIT_PARTS) {
      if (part in o) {
        return true;
      }
    }
  }
  return false;
}
var MONTHS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
var SHORT_MONTHS = MONTHS.map((m) => m.substr(0, 3));
var DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
var SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
function normalizeQuarter(q) {
  if (isNumeric(q)) {
    q = +q;
  }
  if (isNumber(q)) {
    if (q > 4) {
      warn2(message_exports.invalidTimeUnit("quarter", q));
    }
    return q - 1;
  } else {
    throw new Error(message_exports.invalidTimeUnit("quarter", q));
  }
}
function normalizeMonth(m) {
  if (isNumeric(m)) {
    m = +m;
  }
  if (isNumber(m)) {
    return m - 1;
  } else {
    const lowerM = m.toLowerCase();
    const monthIndex = MONTHS.indexOf(lowerM);
    if (monthIndex !== -1) {
      return monthIndex;
    }
    const shortM = lowerM.substr(0, 3);
    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
    if (shortMonthIndex !== -1) {
      return shortMonthIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("month", m));
  }
}
function normalizeDay(d) {
  if (isNumeric(d)) {
    d = +d;
  }
  if (isNumber(d)) {
    return d % 7;
  } else {
    const lowerD = d.toLowerCase();
    const dayIndex = DAYS.indexOf(lowerD);
    if (dayIndex !== -1) {
      return dayIndex;
    }
    const shortD = lowerD.substr(0, 3);
    const shortDayIndex = SHORT_DAYS.indexOf(shortD);
    if (shortDayIndex !== -1) {
      return shortDayIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("day", d));
  }
}
function dateTimeParts(d, normalize2) {
  const parts = [];
  if (normalize2 && d.day !== void 0) {
    if (keys3(d).length > 1) {
      warn2(message_exports.droppedDay(d));
      d = duplicate(d);
      delete d.day;
    }
  }
  if (d.year !== void 0) {
    parts.push(d.year);
  } else {
    parts.push(2012);
  }
  if (d.month !== void 0) {
    const month = normalize2 ? normalizeMonth(d.month) : d.month;
    parts.push(month);
  } else if (d.quarter !== void 0) {
    const quarter2 = normalize2 ? normalizeQuarter(d.quarter) : d.quarter;
    parts.push(isNumber(quarter2) ? quarter2 * 3 : `${quarter2}*3`);
  } else {
    parts.push(0);
  }
  if (d.date !== void 0) {
    parts.push(d.date);
  } else if (d.day !== void 0) {
    const day = normalize2 ? normalizeDay(d.day) : d.day;
    parts.push(isNumber(day) ? day + 1 : `${day}+1`);
  } else {
    parts.push(1);
  }
  for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
    const unit = d[timeUnit];
    parts.push(typeof unit === "undefined" ? 0 : unit);
  }
  return parts;
}
function dateTimeToExpr(d) {
  const parts = dateTimeParts(d, true);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeExprToExpr(d) {
  const parts = dateTimeParts(d, false);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeToTimestamp(d) {
  const parts = dateTimeParts(d, true);
  if (d.utc) {
    return +new Date(Date.UTC(...parts));
  } else {
    return +new Date(...parts);
  }
}

// node_modules/vega-lite/build/src/timeunit.js
var __rest4 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var LOCAL_SINGLE_TIMEUNIT_INDEX = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
var TIMEUNIT_PARTS = keys3(LOCAL_SINGLE_TIMEUNIT_INDEX);
function isLocalSingleTimeUnit(timeUnit) {
  return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];
}
function isUTCTimeUnit(t2) {
  return t2.startsWith("utc");
}
function getLocalTimeUnit(t2) {
  return t2.substr(3);
}
var VEGALITE_TIMEFORMAT = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function getTimeUnitParts(timeUnit) {
  return TIMEUNIT_PARTS.filter((part) => containsTimeUnit(timeUnit, part));
}
function containsTimeUnit(fullTimeUnit, timeUnit) {
  const index3 = fullTimeUnit.indexOf(timeUnit);
  if (index3 < 0) {
    return false;
  }
  if (index3 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index3 - 1) === "i") {
    return false;
  }
  if (fullTimeUnit.length > index3 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index3 + 3) === "o") {
    return false;
  }
  if (index3 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index3 - 1) === "f") {
    return false;
  }
  return true;
}
function fieldExpr(fullTimeUnit, field3, { end } = { end: false }) {
  const fieldRef2 = accessPathWithDatum(field3);
  const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
  function func(timeUnit) {
    if (timeUnit === "quarter") {
      return `(${utc}quarter(${fieldRef2})-1)`;
    } else {
      return `${utc}${timeUnit}(${fieldRef2})`;
    }
  }
  let lastTimeUnit;
  const dateExpr = {};
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(fullTimeUnit, part)) {
      dateExpr[part] = func(part);
      lastTimeUnit = part;
    }
  }
  if (end) {
    dateExpr[lastTimeUnit] += "+1";
  }
  return dateTimeExprToExpr(dateExpr);
}
function timeUnitSpecifierExpression(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  const timeUnitParts = getTimeUnitParts(timeUnit);
  return `timeUnitSpecifier(${stringify(timeUnitParts)}, ${stringify(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(timeUnit, field3, isUTCScale) {
  if (!timeUnit) {
    return void 0;
  }
  const expr2 = timeUnitSpecifierExpression(timeUnit);
  const utc = isUTCScale || isUTCTimeUnit(timeUnit);
  return `${utc ? "utc" : "time"}Format(${field3}, ${expr2})`;
}
function normalizeTimeUnit(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  let params2;
  if (isString(timeUnit)) {
    params2 = {
      unit: timeUnit
    };
  } else if (isObject(timeUnit)) {
    params2 = Object.assign(Object.assign({}, timeUnit), timeUnit.unit ? { unit: timeUnit.unit } : {});
  }
  if (isUTCTimeUnit(params2.unit)) {
    params2.utc = true;
    params2.unit = getLocalTimeUnit(params2.unit);
  }
  return params2;
}
function timeUnitToString(tu) {
  const _a = normalizeTimeUnit(tu), { utc } = _a, rest = __rest4(_a, ["utc"]);
  if (rest.unit) {
    return (utc ? "utc" : "") + keys3(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
  } else {
    return (utc ? "utc" : "") + "timeunit" + keys3(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("");
  }
}

// node_modules/vega-lite/build/src/predicate.js
function isSelectionPredicate(predicate) {
  return predicate === null || predicate === void 0 ? void 0 : predicate["param"];
}
function isFieldEqualPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.equal !== void 0;
}
function isFieldLTPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lt !== void 0;
}
function isFieldLTEPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lte !== void 0;
}
function isFieldGTPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gt !== void 0;
}
function isFieldGTEPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gte !== void 0;
}
function isFieldRangePredicate(predicate) {
  if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {
    if (isArray(predicate.range) && predicate.range.length === 2) {
      return true;
    } else if (isSignalRef(predicate.range)) {
      return true;
    }
  }
  return false;
}
function isFieldOneOfPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && (isArray(predicate.oneOf) || isArray(predicate.in));
}
function isFieldValidPredicate(predicate) {
  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.valid !== void 0;
}
function isFieldPredicate(predicate) {
  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
}
function predicateValueExpr(v, timeUnit) {
  return valueExpr(v, { timeUnit, wrapTime: true });
}
function predicateValuesExpr(vals2, timeUnit) {
  return vals2.map((v) => predicateValueExpr(v, timeUnit));
}
function fieldFilterExpression(predicate, useInRange = true) {
  var _a;
  const { field: field3 } = predicate;
  const timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
  const fieldExpr2 = timeUnit ? (
    // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
    // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
    // TODO: support utc
    `time(${fieldExpr(timeUnit, field3)})`
  ) : vgField(predicate, { expr: "datum" });
  if (isFieldEqualPredicate(predicate)) {
    return `${fieldExpr2}===${predicateValueExpr(predicate.equal, timeUnit)}`;
  } else if (isFieldLTPredicate(predicate)) {
    const upper = predicate.lt;
    return `${fieldExpr2}<${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTPredicate(predicate)) {
    const lower = predicate.gt;
    return `${fieldExpr2}>${predicateValueExpr(lower, timeUnit)}`;
  } else if (isFieldLTEPredicate(predicate)) {
    const upper = predicate.lte;
    return `${fieldExpr2}<=${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTEPredicate(predicate)) {
    const lower = predicate.gte;
    return `${fieldExpr2}>=${predicateValueExpr(lower, timeUnit)}`;
  } else if (isFieldOneOfPredicate(predicate)) {
    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(",")}], ${fieldExpr2}) !== -1`;
  } else if (isFieldValidPredicate(predicate)) {
    return fieldValidPredicate(fieldExpr2, predicate.valid);
  } else if (isFieldRangePredicate(predicate)) {
    const { range: range6 } = predicate;
    const lower = isSignalRef(range6) ? { signal: `${range6.signal}[0]` } : range6[0];
    const upper = isSignalRef(range6) ? { signal: `${range6.signal}[1]` } : range6[1];
    if (lower !== null && upper !== null && useInRange) {
      return "inrange(" + fieldExpr2 + ", [" + predicateValueExpr(lower, timeUnit) + ", " + predicateValueExpr(upper, timeUnit) + "])";
    }
    const exprs = [];
    if (lower !== null) {
      exprs.push(`${fieldExpr2} >= ${predicateValueExpr(lower, timeUnit)}`);
    }
    if (upper !== null) {
      exprs.push(`${fieldExpr2} <= ${predicateValueExpr(upper, timeUnit)}`);
    }
    return exprs.length > 0 ? exprs.join(" && ") : "true";
  }
  throw new Error(`Invalid field predicate: ${stringify(predicate)}`);
}
function fieldValidPredicate(fieldExpr2, valid = true) {
  if (valid) {
    return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
  } else {
    return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
  }
}
function normalizePredicate(f) {
  var _a;
  if (isFieldPredicate(f) && f.timeUnit) {
    return Object.assign(Object.assign({}, f), { timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit });
  }
  return f;
}

// node_modules/vega-lite/build/src/type.js
var Type = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function isContinuous2(type3) {
  return type3 === "quantitative" || type3 === "temporal";
}
function isDiscrete2(type3) {
  return type3 === "ordinal" || type3 === "nominal";
}
var QUANTITATIVE = Type.quantitative;
var ORDINAL = Type.ordinal;
var TEMPORAL = Type.temporal;
var NOMINAL = Type.nominal;
var GEOJSON = Type.geojson;
var TYPES = keys3(Type);
function getFullName(type3) {
  if (type3) {
    type3 = type3.toLowerCase();
    switch (type3) {
      case "q":
      case QUANTITATIVE:
        return "quantitative";
      case "t":
      case TEMPORAL:
        return "temporal";
      case "o":
      case ORDINAL:
        return "ordinal";
      case "n":
      case NOMINAL:
        return "nominal";
      case GEOJSON:
        return "geojson";
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/scale.js
var __rest5 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var ScaleType = {
  // Continuous - Quantitative
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  SYMLOG: "symlog",
  IDENTITY: "identity",
  SEQUENTIAL: "sequential",
  // Continuous - Time
  TIME: "time",
  UTC: "utc",
  // Discretizing scales
  QUANTILE: "quantile",
  QUANTIZE: "quantize",
  THRESHOLD: "threshold",
  BIN_ORDINAL: "bin-ordinal",
  // Discrete scales
  ORDINAL: "ordinal",
  POINT: "point",
  BAND: "band"
};
var SCALE_CATEGORY_INDEX = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
var SCALE_TYPES = keys3(SCALE_CATEGORY_INDEX);
function scaleCompatible(scaleType1, scaleType2) {
  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];
  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];
  return scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time";
}
var SCALE_PRECEDENCE_INDEX = {
  // numeric
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  // time
  time: 0,
  utc: 0,
  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
  point: 10,
  band: 11,
  // non grouped types
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function scaleTypePrecedence(scaleType2) {
  return SCALE_PRECEDENCE_INDEX[scaleType2];
}
var QUANTITATIVE_SCALES = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]);
var CONTINUOUS_TO_CONTINUOUS_SCALES = /* @__PURE__ */ new Set([
  ...QUANTITATIVE_SCALES,
  "time",
  "utc"
]);
function isQuantitative(type3) {
  return QUANTITATIVE_SCALES.has(type3);
}
var CONTINUOUS_TO_DISCRETE_SCALES = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]);
var CONTINUOUS_DOMAIN_SCALES = /* @__PURE__ */ new Set([
  ...CONTINUOUS_TO_CONTINUOUS_SCALES,
  ...CONTINUOUS_TO_DISCRETE_SCALES,
  "sequential",
  "identity"
]);
var DISCRETE_DOMAIN_SCALES = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function hasDiscreteDomain(type3) {
  return DISCRETE_DOMAIN_SCALES.has(type3);
}
function hasContinuousDomain(type3) {
  return CONTINUOUS_DOMAIN_SCALES.has(type3);
}
function isContinuousToContinuous(type3) {
  return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type3);
}
function isContinuousToDiscrete(type3) {
  return CONTINUOUS_TO_DISCRETE_SCALES.has(type3);
}
var defaultScaleConfig = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  // FIXME: revise if these *can* become ratios of width/height step
  minSize: 9,
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4
};
function isExtendedScheme(scheme3) {
  return !isString(scheme3) && !!scheme3["name"];
}
function isParameterDomain(domain4) {
  return domain4 === null || domain4 === void 0 ? void 0 : domain4["param"];
}
function isDomainUnionWith(domain4) {
  return domain4 === null || domain4 === void 0 ? void 0 : domain4["unionWith"];
}
function isFieldRange(range6) {
  return isObject(range6) && "field" in range6;
}
var SCALE_PROPERTY_INDEX = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  // Other properties
  reverse: 1,
  round: 1,
  // quantitative / time
  clamp: 1,
  nice: 1,
  // quantitative
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  // band/point
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
};
var SCALE_PROPERTIES = keys3(SCALE_PROPERTY_INDEX);
var { type: type2, domain: domain2, range: range4, rangeMax, rangeMin, scheme: scheme2 } = SCALE_PROPERTY_INDEX;
var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest5(SCALE_PROPERTY_INDEX, ["type", "domain", "range", "rangeMax", "rangeMin", "scheme"]);
var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys3(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
function scaleTypeSupportProperty(scaleType2, propName) {
  switch (propName) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return true;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(scaleType2);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(scaleType2);
    case "round":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "band" || scaleType2 === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return isContinuousToContinuous(scaleType2) || ["point", "band"].includes(scaleType2);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(scaleType2);
    case "paddingInner":
      return scaleType2 === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "clamp":
      return isContinuousToContinuous(scaleType2);
    case "nice":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "quantize" || scaleType2 === "threshold";
    case "exponent":
      return scaleType2 === "pow";
    case "base":
      return scaleType2 === "log";
    case "constant":
      return scaleType2 === "symlog";
    case "zero":
      return hasContinuousDomain(scaleType2) && !contains2([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
        // quantile depends on distribution so zero does not matter
      ], scaleType2);
  }
}
function channelScalePropertyIncompatability(channel, propName) {
  switch (propName) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      if (!isColorChannel(channel)) {
        return message_exports.cannotUseScalePropertyWithNonColor(propName);
      }
      return void 0;
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return void 0;
  }
}
function scaleTypeSupportDataType(specifiedType, fieldDefType) {
  if (contains2([ORDINAL, NOMINAL], fieldDefType)) {
    return specifiedType === void 0 || hasDiscreteDomain(specifiedType);
  } else if (fieldDefType === TEMPORAL) {
    return contains2([ScaleType.TIME, ScaleType.UTC, void 0], specifiedType);
  } else if (fieldDefType === QUANTITATIVE) {
    return isQuantitative(specifiedType) || isContinuousToDiscrete(specifiedType) || specifiedType === void 0;
  }
  return true;
}
function channelSupportScaleType(channel, scaleType2, hasNestedOffsetScale = false) {
  if (!isScaleChannel(channel)) {
    return false;
  }
  switch (channel) {
    case X2:
    case Y2:
    case XOFFSET:
    case YOFFSET:
    case THETA:
    case RADIUS:
      if (isContinuousToContinuous(scaleType2)) {
        return true;
      } else if (scaleType2 === "band") {
        return true;
      } else if (scaleType2 === "point") {
        return !hasNestedOffsetScale;
      }
      return false;
    case SIZE2:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return isContinuousToContinuous(scaleType2) || isContinuousToDiscrete(scaleType2) || contains2(["band", "point", "ordinal"], scaleType2);
    case COLOR:
    case FILL:
    case STROKE:
      return scaleType2 !== "band";
    case STROKEDASH:
    case SHAPE:
      return scaleType2 === "ordinal" || isContinuousToDiscrete(scaleType2);
  }
}

// node_modules/vega-lite/build/src/mark.js
var Mark3 = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
};
var ARC = Mark3.arc;
var AREA = Mark3.area;
var BAR = Mark3.bar;
var IMAGE = Mark3.image;
var LINE = Mark3.line;
var POINT = Mark3.point;
var RECT = Mark3.rect;
var RULE = Mark3.rule;
var TEXT2 = Mark3.text;
var TICK = Mark3.tick;
var TRAIL = Mark3.trail;
var CIRCLE = Mark3.circle;
var SQUARE = Mark3.square;
var GEOSHAPE = Mark3.geoshape;
function isPathMark(m) {
  return ["line", "area", "trail"].includes(m);
}
function isRectBasedMark(m) {
  return [
    "rect",
    "bar",
    "image",
    "arc"
    /* arc is rect/interval in polar coordinate */
  ].includes(m);
}
var PRIMITIVE_MARKS = new Set(keys3(Mark3));
function isMarkDef(mark2) {
  return mark2["type"];
}
var STROKE_CONFIG = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
];
var FILL_CONFIG = ["fill", "fillOpacity"];
var FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
var VL_ONLY_MARK_CONFIG_INDEX = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
};
var VL_ONLY_MARK_CONFIG_PROPERTIES = keys3(VL_ONLY_MARK_CONFIG_INDEX);
var VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
};
var defaultMarkConfig = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
};
var MARK_CONFIG_INDEX = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
};
var MARK_CONFIGS = keys3(MARK_CONFIG_INDEX);
function isRelativeBandSize(o) {
  return o && o["band"] != void 0;
}
var BAR_CORNER_RADIUS_INDEX = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
};
var DEFAULT_RECT_BAND_SIZE = 5;
var defaultBarConfig = {
  binSpacing: 1,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultRectConfig = {
  binSpacing: 0,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultTickConfig = {
  thickness: 1
};
function getMarkType(m) {
  return isMarkDef(m) ? m.type : m;
}

// node_modules/vega-lite/build/src/compile/mark/encode/valueref.js
function midPointRefWithPositionInvalidTest(params2) {
  const { channel, channelDef, markDef, scale: scale6, config } = params2;
  const ref2 = midPoint(params2);
  if (
    // Only this for field def without counting aggregate (as count wouldn't be null)
    isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale
    scale6 && isContinuousToContinuous(scale6.get("type"))
  ) {
    return wrapPositionInvalidTest({
      fieldDef: channelDef,
      channel,
      markDef,
      ref: ref2,
      config
    });
  }
  return ref2;
}
function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref: ref2, config }) {
  if (isPathMark(markDef.type)) {
    return ref2;
  }
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === null) {
    return [fieldInvalidTestValueRef(fieldDef, channel), ref2];
  }
  return ref2;
}
function fieldInvalidTestValueRef(fieldDef, channel) {
  const test2 = fieldInvalidPredicate(fieldDef, true);
  const mainChannel = getMainRangeChannel(channel);
  const zeroValueRef = mainChannel === "y" ? { field: { group: "height" } } : (
    // x / angle / radius can all use 0
    { value: 0 }
  );
  return Object.assign({ test: test2 }, zeroValueRef);
}
function fieldInvalidPredicate(field3, invalid = true) {
  return fieldValidPredicate(isString(field3) ? field3 : vgField(field3, { expr: "datum" }), !invalid);
}
function datumDefToExpr(datumDef) {
  const { datum: datum2 } = datumDef;
  if (isDateTime(datum2)) {
    return dateTimeToExpr(datum2);
  }
  return `${stringify(datum2)}`;
}
function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode2) {
  const ref2 = {};
  if (scaleName) {
    ref2.scale = scaleName;
  }
  if (isDatumDef(fieldDef)) {
    const { datum: datum2 } = fieldDef;
    if (isDateTime(datum2)) {
      ref2.signal = dateTimeToExpr(datum2);
    } else if (isSignalRef(datum2)) {
      ref2.signal = datum2.signal;
    } else if (isExprRef(datum2)) {
      ref2.signal = datum2.expr;
    } else {
      ref2.value = datum2;
    }
  } else {
    ref2.field = vgField(fieldDef, opt);
  }
  if (encode2) {
    const { offset: offset4, band: band2 } = encode2;
    if (offset4) {
      ref2.offset = offset4;
    }
    if (band2) {
      ref2.band = band2;
    }
  }
  return ref2;
}
function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset: offset4, startSuffix, bandPosition = 0.5 }) {
  const expr2 = 0 < bandPosition && bandPosition < 1 ? "datum" : void 0;
  const start = vgField(fieldOrDatumDef, { expr: expr2, suffix: startSuffix });
  const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, { expr: expr2 }) : vgField(fieldOrDatumDef, { suffix: "end", expr: expr2 });
  const ref2 = {};
  if (bandPosition === 0 || bandPosition === 1) {
    ref2.scale = scaleName;
    const val = bandPosition === 0 ? start : end;
    ref2.field = val;
  } else {
    const datum2 = isSignalRef(bandPosition) ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}` : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;
    ref2.signal = `scale("${scaleName}", ${datum2})`;
  }
  if (offset4) {
    ref2.offset = offset4;
  }
  return ref2;
}
function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale6, stack: stack2, offset: offset4, defaultRef, bandPosition }) {
  var _a;
  if (channelDef) {
    if (isFieldOrDatumDef(channelDef)) {
      const scaleType2 = scale6 === null || scale6 === void 0 ? void 0 : scale6.get("type");
      if (isTypedFieldDef(channelDef)) {
        bandPosition !== null && bandPosition !== void 0 ? bandPosition : bandPosition = getBandPosition({
          fieldDef: channelDef,
          fieldDef2: channel2Def,
          markDef,
          config
        });
        const { bin: bin3, timeUnit, type: type3 } = channelDef;
        if (isBinning(bin3) || bandPosition && timeUnit && type3 === TEMPORAL) {
          if (stack2 === null || stack2 === void 0 ? void 0 : stack2.impute) {
            return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: "mid" }, { offset: offset4 });
          }
          if (bandPosition && !hasDiscreteDomain(scaleType2)) {
            return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset: offset4 });
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: "range" } : {}, {
            offset: offset4
          });
        } else if (isBinned(bin3)) {
          if (isFieldDef(channel2Def)) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              fieldOrDatumDef2: channel2Def,
              bandPosition,
              offset: offset4
            });
          } else {
            const channel2 = channel === X2 ? X22 : Y22;
            warn2(message_exports.channelRequiredForBinned(channel2));
          }
        }
      }
      return valueRefForFieldOrDatumDef(
        channelDef,
        scaleName,
        hasDiscreteDomain(scaleType2) ? { binSuffix: "range" } : {},
        // no need for bin suffix if there is no scale
        {
          offset: offset4,
          // For band, to get mid point, need to offset by half of the band
          band: scaleType2 === "band" ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : void 0
        }
      );
    } else if (isValueDef(channelDef)) {
      const value3 = channelDef.value;
      const offsetMixins = offset4 ? { offset: offset4 } : {};
      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value3)), offsetMixins);
    }
  }
  if (isFunction(defaultRef)) {
    defaultRef = defaultRef();
  }
  if (defaultRef) {
    return Object.assign(Object.assign({}, defaultRef), offset4 ? { offset: offset4 } : {});
  }
  return defaultRef;
}
function widthHeightValueOrSignalRef(channel, value3) {
  if (contains2(["x", "x2"], channel) && value3 === "width") {
    return { field: { group: "width" } };
  } else if (contains2(["y", "y2"], channel) && value3 === "height") {
    return { field: { group: "height" } };
  }
  return signalOrValueRef(value3);
}

// node_modules/vega-lite/build/src/compile/format.js
function isCustomFormatType(formatType) {
  return formatType && formatType !== "number" && formatType !== "time";
}
function customFormatExpr(formatType, field3, format5) {
  return `${formatType}(${field3}${format5 ? `, ${stringify(format5)}` : ""})`;
}
var BIN_RANGE_DELIMITER = " – ";
function formatSignalRef({ fieldOrDatumDef, format: format5, formatType, expr: expr2, normalizeStack, config }) {
  var _a, _b;
  if (isCustomFormatType(formatType)) {
    return formatCustomType({
      fieldOrDatumDef,
      format: format5,
      formatType,
      expr: expr2,
      config
    });
  }
  const field3 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  const type3 = channelDefType(fieldOrDatumDef);
  if (format5 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (type3 === "quantitative") {
      if (normalizeStack && config.normalizedNumberFormatType)
        return formatCustomType({
          fieldOrDatumDef,
          format: config.normalizedNumberFormat,
          formatType: config.normalizedNumberFormatType,
          expr: expr2,
          config
        });
      if (config.numberFormatType) {
        return formatCustomType({
          fieldOrDatumDef,
          format: config.numberFormat,
          formatType: config.numberFormatType,
          expr: expr2,
          config
        });
      }
    }
    if (type3 === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
      return formatCustomType({
        fieldOrDatumDef,
        format: config.timeFormat,
        formatType: config.timeFormatType,
        expr: expr2,
        config
      });
    }
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const signal = timeFormatExpression({
      field: field3,
      timeUnit: isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0,
      format: format5,
      formatType: config.timeFormatType,
      rawTimeFormat: config.timeFormat,
      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC
    });
    return signal ? { signal } : void 0;
  }
  format5 = numberFormat({ type: type3, specifiedFormat: format5, config, normalizeStack });
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field3, endField, format5, formatType, config)
    };
  } else if (format5 || channelDefType(fieldOrDatumDef) === "quantitative") {
    return {
      signal: `${formatExpr(field3, format5)}`
    };
  } else {
    return { signal: `isValid(${field3}) ? ${field3} : ""+${field3}` };
  }
}
function fieldToFormat(fieldOrDatumDef, expr2, normalizeStack) {
  if (isFieldDef(fieldOrDatumDef)) {
    if (normalizeStack) {
      return `${vgField(fieldOrDatumDef, { expr: expr2, suffix: "end" })}-${vgField(fieldOrDatumDef, {
        expr: expr2,
        suffix: "start"
      })}`;
    } else {
      return vgField(fieldOrDatumDef, { expr: expr2 });
    }
  } else {
    return datumDefToExpr(fieldOrDatumDef);
  }
}
function formatCustomType({ fieldOrDatumDef, format: format5, formatType, expr: expr2, normalizeStack, config, field: field3 }) {
  field3 !== null && field3 !== void 0 ? field3 : field3 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  if (field3 !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
  isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field3, endField, format5, formatType, config)
    };
  }
  return { signal: customFormatExpr(formatType, field3, format5) };
}
function guideFormat(fieldOrDatumDef, type3, format5, formatType, config, omitTimeFormatConfig) {
  var _a;
  if (isCustomFormatType(formatType)) {
    return void 0;
  } else if (format5 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (channelDefType(fieldOrDatumDef) === "quantitative") {
      if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize") {
        return void 0;
      }
      if (config.numberFormatType) {
        return void 0;
      }
    }
  }
  if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormat) {
    return numberFormat({
      type: "quantitative",
      config,
      normalizeStack: true
    });
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0;
    if (timeUnit === void 0 && config.customFormatTypes && config.timeFormatType) {
      return void 0;
    }
    return timeFormat3({ specifiedFormat: format5, timeUnit, config, omitTimeFormatConfig });
  }
  return numberFormat({ type: type3, specifiedFormat: format5, config });
}
function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
  var _a;
  if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
    return formatType;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
    return isFieldDef(fieldOrDatumDef) && ((_a = normalizeTimeUnit(fieldOrDatumDef === null || fieldOrDatumDef === void 0 ? void 0 : fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.utc) ? "utc" : "time";
  }
  return void 0;
}
function numberFormat({ type: type3, specifiedFormat, config, normalizeStack }) {
  if (isString(specifiedFormat)) {
    return specifiedFormat;
  }
  if (type3 === QUANTITATIVE) {
    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;
  }
  return void 0;
}
function timeFormat3({ specifiedFormat, timeUnit, config, omitTimeFormatConfig }) {
  if (specifiedFormat) {
    return specifiedFormat;
  }
  if (timeUnit) {
    return {
      signal: timeUnitSpecifierExpression(timeUnit)
    };
  }
  return omitTimeFormatConfig ? void 0 : config.timeFormat;
}
function formatExpr(field3, format5) {
  return `format(${field3}, "${format5 || ""}")`;
}
function binNumberFormatExpr(field3, format5, formatType, config) {
  var _a;
  if (isCustomFormatType(formatType)) {
    return customFormatExpr(formatType, field3, format5);
  }
  return formatExpr(field3, (_a = isString(format5) ? format5 : void 0) !== null && _a !== void 0 ? _a : config.numberFormat);
}
function binFormatExpression(startField, endField, format5, formatType, config) {
  if (format5 === void 0 && formatType === void 0 && config.customFormatTypes && config.numberFormatType) {
    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);
  }
  const start = binNumberFormatExpr(startField, format5, formatType, config);
  const end = binNumberFormatExpr(endField, format5, formatType, config);
  return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
function timeFormatExpression({ field: field3, timeUnit, format: format5, formatType, rawTimeFormat, isUTCScale }) {
  if (!timeUnit || format5) {
    if (!timeUnit && formatType) {
      return `${formatType}(${field3}, '${format5}')`;
    }
    format5 = isString(format5) ? format5 : rawTimeFormat;
    return `${isUTCScale ? "utc" : "time"}Format(${field3}, '${format5}')`;
  } else {
    return formatExpression(timeUnit, field3, isUTCScale);
  }
}

// node_modules/vega-lite/build/src/sort.js
var DEFAULT_SORT_OP = "min";
var SORT_BY_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function isSortByChannel(c) {
  return c in SORT_BY_CHANNEL_INDEX;
}
function isSortByEncoding(sort3) {
  return !!(sort3 === null || sort3 === void 0 ? void 0 : sort3["encoding"]);
}
function isSortField(sort3) {
  return sort3 && (sort3["op"] === "count" || !!sort3["field"]);
}
function isSortArray(sort3) {
  return sort3 && isArray(sort3);
}

// node_modules/vega-lite/build/src/spec/facet.js
function isFacetMapping(f) {
  return "row" in f || "column" in f;
}
function isFacetFieldDef(channelDef) {
  return !!channelDef && "header" in channelDef;
}
function isFacetSpec(spec) {
  return "facet" in spec;
}

// node_modules/vega-lite/build/src/channeldef.js
var __rest6 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function isConditionalParameter(c) {
  return c["param"];
}
function isRepeatRef(field3) {
  return field3 && !isString(field3) && "repeat" in field3;
}
function toFieldDefBase(fieldDef) {
  const { field: field3, timeUnit, bin: bin3, aggregate } = fieldDef;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? { timeUnit } : {}), bin3 ? { bin: bin3 } : {}), aggregate ? { aggregate } : {}), { field: field3 });
}
function isSortableFieldDef(fieldDef) {
  return "sort" in fieldDef;
}
function getBandPosition({ fieldDef, fieldDef2, markDef: mark2, config }) {
  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== void 0) {
    return fieldDef.bandPosition;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin3 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return isRectBasedMark(mark2.type) ? 0 : getMarkConfig("timeUnitBandPosition", mark2, config);
    } else if (isBinning(bin3)) {
      return 0.5;
    }
  }
  return void 0;
}
function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark2, config, scaleType: scaleType2, useVlSizeChannel }) {
  var _a, _b, _c2;
  const sizeChannel = getSizeChannel(channel);
  const size = getMarkPropOrConfig(useVlSizeChannel ? "size" : sizeChannel, mark2, config, {
    vgChannel: sizeChannel
  });
  if (size !== void 0) {
    return size;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin3 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return { band: getMarkConfig("timeUnitBandSize", mark2, config) };
    } else if (isBinning(bin3) && !hasDiscreteDomain(scaleType2)) {
      return { band: 1 };
    }
  }
  if (isRectBasedMark(mark2.type)) {
    if (scaleType2) {
      if (hasDiscreteDomain(scaleType2)) {
        return ((_a = config[mark2.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || { band: 1 };
      } else {
        return (_b = config[mark2.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;
      }
    }
    return (_c2 = config[mark2.type]) === null || _c2 === void 0 ? void 0 : _c2.discreteBandSize;
  }
  return void 0;
}
function hasBandEnd(fieldDef, fieldDef2, markDef, config) {
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
    return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== void 0;
  }
  return false;
}
function isConditionalDef(channelDef) {
  return channelDef && "condition" in channelDef;
}
function hasConditionalFieldDef(channelDef) {
  const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef["condition"];
  return !!condition && !isArray(condition) && isFieldDef(condition);
}
function hasConditionalFieldOrDatumDef(channelDef) {
  const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef["condition"];
  return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);
}
function hasConditionalValueDef(channelDef) {
  const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef["condition"];
  return !!condition && (isArray(condition) || isValueDef(condition));
}
function isFieldDef(channelDef) {
  return channelDef && (!!channelDef["field"] || channelDef["aggregate"] === "count");
}
function channelDefType(channelDef) {
  return channelDef === null || channelDef === void 0 ? void 0 : channelDef["type"];
}
function isDatumDef(channelDef) {
  return channelDef && "datum" in channelDef;
}
function isContinuousFieldOrDatumDef(cd) {
  return isTypedFieldDef(cd) && !isDiscrete3(cd) || isNumericDataDef(cd);
}
function isNumericDataDef(cd) {
  return isDatumDef(cd) && isNumber(cd.datum);
}
function isFieldOrDatumDef(channelDef) {
  return isFieldDef(channelDef) || isDatumDef(channelDef);
}
function isTypedFieldDef(channelDef) {
  return channelDef && ("field" in channelDef || channelDef["aggregate"] === "count") && "type" in channelDef;
}
function isValueDef(channelDef) {
  return channelDef && "value" in channelDef && "value" in channelDef;
}
function isScaleFieldDef(channelDef) {
  return channelDef && ("scale" in channelDef || "sort" in channelDef);
}
function isPositionFieldOrDatumDef(channelDef) {
  return channelDef && ("axis" in channelDef || "stack" in channelDef || "impute" in channelDef);
}
function isMarkPropFieldOrDatumDef(channelDef) {
  return channelDef && "legend" in channelDef;
}
function isStringFieldOrDatumDef(channelDef) {
  return channelDef && ("format" in channelDef || "formatType" in channelDef);
}
function toStringFieldDef(fieldDef) {
  return omit(fieldDef, ["legend", "axis", "header", "scale"]);
}
function isOpFieldDef(fieldDef) {
  return "op" in fieldDef;
}
function vgField(fieldDef, opt = {}) {
  var _a, _b, _c2;
  let field3 = fieldDef.field;
  const prefix = opt.prefix;
  let suffix = opt.suffix;
  let argAccessor = "";
  if (isCount(fieldDef)) {
    field3 = internalField("count");
  } else {
    let fn;
    if (!opt.nofn) {
      if (isOpFieldDef(fieldDef)) {
        fn = fieldDef.op;
      } else {
        const { bin: bin3, aggregate, timeUnit } = fieldDef;
        if (isBinning(bin3)) {
          fn = binToString(bin3);
          suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : "") + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : "");
        } else if (aggregate) {
          if (isArgmaxDef(aggregate)) {
            argAccessor = `["${field3}"]`;
            field3 = `argmax_${aggregate.argmax}`;
          } else if (isArgminDef(aggregate)) {
            argAccessor = `["${field3}"]`;
            field3 = `argmin_${aggregate.argmin}`;
          } else {
            fn = String(aggregate);
          }
        } else if (timeUnit) {
          fn = timeUnitToString(timeUnit);
          suffix = (!["range", "mid"].includes(opt.binSuffix) && opt.binSuffix || "") + ((_c2 = opt.suffix) !== null && _c2 !== void 0 ? _c2 : "");
        }
      }
    }
    if (fn) {
      field3 = field3 ? `${fn}_${field3}` : fn;
    }
  }
  if (suffix) {
    field3 = `${field3}_${suffix}`;
  }
  if (prefix) {
    field3 = `${prefix}_${field3}`;
  }
  if (opt.forAs) {
    return removePathFromField(field3);
  } else if (opt.expr) {
    return flatAccessWithDatum(field3, opt.expr) + argAccessor;
  } else {
    return replacePathInField(field3) + argAccessor;
  }
}
function isDiscrete3(def2) {
  switch (def2.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return true;
    case "quantitative":
      return isFieldDef(def2) && !!def2.bin;
    case "temporal":
      return false;
  }
  throw new Error(message_exports.invalidFieldType(def2.type));
}
function isDiscretizing2(def2) {
  var _a;
  return isScaleFieldDef(def2) && isContinuousToDiscrete((_a = def2.scale) === null || _a === void 0 ? void 0 : _a.type);
}
function isCount(fieldDef) {
  return fieldDef.aggregate === "count";
}
function verbalTitleFormatter(fieldDef, config) {
  var _a;
  const { field: field3, bin: bin3, timeUnit, aggregate } = fieldDef;
  if (aggregate === "count") {
    return config.countTitle;
  } else if (isBinning(bin3)) {
    return `${field3} (binned)`;
  } else if (timeUnit) {
    const unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
    if (unit) {
      return `${field3} (${getTimeUnitParts(unit).join("-")})`;
    }
  } else if (aggregate) {
    if (isArgmaxDef(aggregate)) {
      return `${field3} for max ${aggregate.argmax}`;
    } else if (isArgminDef(aggregate)) {
      return `${field3} for min ${aggregate.argmin}`;
    } else {
      return `${titleCase(aggregate)} of ${field3}`;
    }
  }
  return field3;
}
function functionalTitleFormatter(fieldDef) {
  const { aggregate, bin: bin3, timeUnit, field: field3 } = fieldDef;
  if (isArgmaxDef(aggregate)) {
    return `${field3} for argmax(${aggregate.argmax})`;
  } else if (isArgminDef(aggregate)) {
    return `${field3} for argmin(${aggregate.argmin})`;
  }
  const timeUnitParams = normalizeTimeUnit(timeUnit);
  const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin3) && "bin";
  if (fn) {
    return `${fn.toUpperCase()}(${field3})`;
  } else {
    return field3;
  }
}
var defaultTitleFormatter = (fieldDef, config) => {
  switch (config.fieldTitle) {
    case "plain":
      return fieldDef.field;
    case "functional":
      return functionalTitleFormatter(fieldDef);
    default:
      return verbalTitleFormatter(fieldDef, config);
  }
};
var titleFormatter = defaultTitleFormatter;
function setTitleFormatter(formatter) {
  titleFormatter = formatter;
}
function resetTitleFormatter() {
  setTitleFormatter(defaultTitleFormatter);
}
function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {
  var _a, _b;
  const guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;
  if (!isFieldDef(fieldOrDatumDef)) {
    return guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldOrDatumDef.title;
  }
  const fieldDef = fieldOrDatumDef;
  const def2 = includeDefault ? defaultTitle(fieldDef, config) : void 0;
  if (allowDisabling) {
    return getFirstDefined(guideTitle, fieldDef.title, def2);
  } else {
    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def2;
  }
}
function getGuide(fieldDef) {
  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
    return fieldDef.axis;
  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
    return fieldDef.legend;
  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
    return fieldDef.header;
  }
  return void 0;
}
function defaultTitle(fieldDef, config) {
  return titleFormatter(fieldDef, config);
}
function getFormatMixins(fieldDef) {
  var _a;
  if (isStringFieldOrDatumDef(fieldDef)) {
    const { format: format5, formatType } = fieldDef;
    return { format: format5, formatType };
  } else {
    const guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};
    const { format: format5, formatType } = guide;
    return { format: format5, formatType };
  }
}
function defaultType(fieldDef, channel) {
  var _a;
  switch (channel) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {
    return "ordinal";
  }
  const { aggregate, bin: bin3, timeUnit } = fieldDef;
  if (timeUnit) {
    return "temporal";
  }
  if (bin3 || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    return "quantitative";
  }
  if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {
    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  }
  return "nominal";
}
function getFieldDef(channelDef) {
  if (isFieldDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function getFieldOrDatumDef(channelDef) {
  if (isFieldOrDatumDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function initChannelDef(channelDef, channel, config, opt = {}) {
  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {
    const primitiveType = isString(channelDef) ? "string" : isNumber(channelDef) ? "number" : "boolean";
    warn2(message_exports.primitiveChannelDef(channel, primitiveType, channelDef));
    return { value: channelDef };
  }
  if (isFieldOrDatumDef(channelDef)) {
    return initFieldOrDatumDef(channelDef, channel, config, opt);
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return Object.assign(Object.assign({}, channelDef), {
      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)
    });
  }
  return channelDef;
}
function initFieldOrDatumDef(fd, channel, config, opt) {
  if (isStringFieldOrDatumDef(fd)) {
    const { format: format5, formatType } = fd, rest = __rest6(fd, ["format", "formatType"]);
    if (isCustomFormatType(formatType) && !config.customFormatTypes) {
      warn2(message_exports.customFormatTypeNotAllowed(channel));
      return initFieldOrDatumDef(rest, channel, config, opt);
    }
  } else {
    const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
    if (guideType && fd[guideType]) {
      const _a = fd[guideType], { format: format5, formatType } = _a, newGuide = __rest6(_a, ["format", "formatType"]);
      if (isCustomFormatType(formatType) && !config.customFormatTypes) {
        warn2(message_exports.customFormatTypeNotAllowed(channel));
        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config, opt);
      }
    }
  }
  if (isFieldDef(fd)) {
    return initFieldDef(fd, channel, opt);
  }
  return initDatumDef(fd);
}
function initDatumDef(datumDef) {
  let type3 = datumDef["type"];
  if (type3) {
    return datumDef;
  }
  const { datum: datum2 } = datumDef;
  type3 = isNumber(datum2) ? "quantitative" : isString(datum2) ? "nominal" : isDateTime(datum2) ? "temporal" : void 0;
  return Object.assign(Object.assign({}, datumDef), { type: type3 });
}
function initFieldDef(fd, channel, { compositeMark = false } = {}) {
  const { aggregate, timeUnit, bin: bin3, field: field3 } = fd;
  const fieldDef = Object.assign({}, fd);
  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    warn2(message_exports.invalidAggregate(aggregate));
    delete fieldDef.aggregate;
  }
  if (timeUnit) {
    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
  }
  if (field3) {
    fieldDef.field = `${field3}`;
  }
  if (isBinning(bin3)) {
    fieldDef.bin = normalizeBin(bin3, channel);
  }
  if (isBinned(bin3) && !isXorY(channel)) {
    warn2(message_exports.channelShouldNotBeUsedForBinned(channel));
  }
  if (isTypedFieldDef(fieldDef)) {
    const { type: type3 } = fieldDef;
    const fullType = getFullName(type3);
    if (type3 !== fullType) {
      fieldDef.type = fullType;
    }
    if (type3 !== "quantitative") {
      if (isCountingAggregateOp(aggregate)) {
        warn2(message_exports.invalidFieldTypeForCountAggregate(type3, aggregate));
        fieldDef.type = "quantitative";
      }
    }
  } else if (!isSecondaryRangeChannel(channel)) {
    const newType = defaultType(fieldDef, channel);
    fieldDef["type"] = newType;
  }
  if (isTypedFieldDef(fieldDef)) {
    const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};
    if (compatible === false) {
      warn2(warning);
    }
  }
  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {
    const { sort: sort3 } = fieldDef;
    if (isSortByChannel(sort3)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort3 } });
    }
    const sub = sort3.substr(1);
    if (sort3.charAt(0) === "-" && isSortByChannel(sub)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: "descending" } });
    }
  }
  if (isFacetFieldDef(fieldDef)) {
    const { header } = fieldDef;
    if (header) {
      const { orient: orient2 } = header, rest = __rest6(header, ["orient"]);
      if (orient2) {
        return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient2, titleOrient: header.titleOrient || orient2 }) });
      }
    }
  }
  return fieldDef;
}
function normalizeBin(bin3, channel) {
  if (isBoolean(bin3)) {
    return { maxbins: autoMaxBins(channel) };
  } else if (bin3 === "binned") {
    return {
      binned: true
    };
  } else if (!bin3.maxbins && !bin3.step) {
    return Object.assign(Object.assign({}, bin3), { maxbins: autoMaxBins(channel) });
  } else {
    return bin3;
  }
}
var COMPATIBLE = { compatible: true };
function channelCompatibility(fieldDef, channel) {
  const type3 = fieldDef.type;
  if (type3 === "geojson" && channel !== "shape") {
    return {
      compatible: false,
      warning: `Channel ${channel} should not be used with a geojson data.`
    };
  }
  switch (channel) {
    case ROW:
    case COLUMN:
    case FACET:
      if (!isDiscrete3(fieldDef)) {
        return {
          compatible: false,
          warning: message_exports.channelShouldBeDiscrete(channel)
        };
      }
      return COMPATIBLE;
    case X2:
    case Y2:
    case XOFFSET:
    case YOFFSET:
    case COLOR:
    case FILL:
    case STROKE:
    case TEXT:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case URL2:
    case ANGLE:
    case THETA:
    case RADIUS:
    case DESCRIPTION:
      return COMPATIBLE;
    case LONGITUDE:
    case LONGITUDE2:
    case LATITUDE:
    case LATITUDE2:
      if (type3 !== QUANTITATIVE) {
        return {
          compatible: false,
          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
        };
      }
      return COMPATIBLE;
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case SIZE2:
    case THETA2:
    case RADIUS2:
    case X22:
    case Y22:
      if (type3 === "nominal" && !fieldDef["sort"]) {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with an unsorted discrete field.`
        };
      }
      return COMPATIBLE;
    case SHAPE:
    case STROKEDASH:
      if (!isDiscrete3(fieldDef) && !isDiscretizing2(fieldDef)) {
        return {
          compatible: false,
          warning: message_exports.channelShouldBeDiscreteOrDiscretizing(channel)
        };
      }
      return COMPATIBLE;
    case ORDER:
      if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
        return {
          compatible: false,
          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
        };
      }
      return COMPATIBLE;
  }
}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
  const { formatType } = getFormatMixins(fieldOrDatumDef);
  return formatType === "time" || !formatType && isTimeFieldDef(fieldOrDatumDef);
}
function isTimeFieldDef(def2) {
  return def2 && (def2["type"] === "temporal" || isFieldDef(def2) && !!def2.timeUnit);
}
function valueExpr(v, { timeUnit, type: type3, wrapTime, undefinedIfExprNotRequired }) {
  var _a;
  const unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);
  let isTime = unit || type3 === "temporal";
  let expr2;
  if (isExprRef(v)) {
    expr2 = v.expr;
  } else if (isSignalRef(v)) {
    expr2 = v.signal;
  } else if (isDateTime(v)) {
    isTime = true;
    expr2 = dateTimeToExpr(v);
  } else if (isString(v) || isNumber(v)) {
    if (isTime) {
      expr2 = `datetime(${stringify(v)})`;
      if (isLocalSingleTimeUnit(unit)) {
        if (isNumber(v) && v < 1e4 || isString(v) && isNaN(Date.parse(v))) {
          expr2 = dateTimeToExpr({ [unit]: v });
        }
      }
    }
  }
  if (expr2) {
    return wrapTime && isTime ? `time(${expr2})` : expr2;
  }
  return undefinedIfExprNotRequired ? void 0 : stringify(v);
}
function valueArray(fieldOrDatumDef, values5) {
  const { type: type3 } = fieldOrDatumDef;
  return values5.map((v) => {
    const expr2 = valueExpr(v, {
      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : void 0,
      type: type3,
      undefinedIfExprNotRequired: true
    });
    if (expr2 !== void 0) {
      return { signal: expr2 };
    }
    return v;
  });
}
function binRequiresRange(fieldDef, channel) {
  if (!isBinning(fieldDef.bin)) {
    console.warn("Only call this method for binned field defs.");
    return false;
  }
  return isScaleChannel(channel) && ["ordinal", "nominal"].includes(fieldDef.type);
}

// node_modules/vega-lite/build/src/axis.js
var CONDITIONAL_AXIS_PROP_INDEX = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function isConditionalAxisValue(v) {
  return v === null || v === void 0 ? void 0 : v.condition;
}
var AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
var AXIS_PROPERTY_TYPE = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
  // this is actually set afterward, so it doesn't matter
};
var COMMON_AXIS_PROPERTIES_INDEX = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
};
var AXIS_PROPERTIES_INDEX = Object.assign(Object.assign({}, COMMON_AXIS_PROPERTIES_INDEX), { style: 1, labelExpr: 1, encoding: 1 });
function isAxisProperty(prop) {
  return !!AXIS_PROPERTIES_INDEX[prop];
}
var AXIS_PROPERTIES = keys3(AXIS_PROPERTIES_INDEX);
var AXIS_CONFIGS_INDEX = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
};
var AXIS_CONFIGS = keys3(AXIS_CONFIGS_INDEX);

// node_modules/vega-lite/build/src/spec/unit.js
function isUnitSpec(spec) {
  return "mark" in spec;
}

// node_modules/vega-lite/build/src/compositemark/base.js
var CompositeMarkNormalizer = class {
  constructor(name4, run2) {
    this.name = name4;
    this.run = run2;
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      return getMarkType(spec.mark) === this.name;
    }
    return false;
  }
};

// node_modules/vega-lite/build/src/encoding.js
var __rest7 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function channelHasField(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray(channelDef)) {
      return some(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
    }
  }
  return false;
}
function channelHasFieldOrDatum(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray(channelDef)) {
      return some(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);
    }
  }
  return false;
}
function channelHasNestedOffsetScale(encoding, channel) {
  if (isXorY(channel)) {
    const fieldDef = encoding[channel];
    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && isDiscrete2(fieldDef.type)) {
      const offsetChannel = getOffsetScaleChannel(channel);
      return channelHasFieldOrDatum(encoding, offsetChannel);
    }
  }
  return false;
}
function isAggregate(encoding) {
  return some(CHANNELS, (channel) => {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      if (isArray(channelDef)) {
        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);
      } else {
        const fieldDef = getFieldDef(channelDef);
        return fieldDef && !!fieldDef.aggregate;
      }
    }
    return false;
  });
}
function extractTransformsFromEncoding(oldEncoding, config) {
  const groupby = [];
  const bins2 = [];
  const timeUnits2 = [];
  const aggregate = [];
  const encoding = {};
  forEach(oldEncoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      const { field: field3, aggregate: aggOp, bin: bin3, timeUnit } = channelDef, remaining = __rest7(channelDef, ["field", "aggregate", "bin", "timeUnit"]);
      if (aggOp || timeUnit || bin3) {
        const guide = getGuide(channelDef);
        const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;
        let newField = vgField(channelDef, { forAs: true });
        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) }), remaining), {
          // Always overwrite field
          field: newField
        });
        if (aggOp) {
          let op;
          if (isArgmaxDef(aggOp)) {
            op = "argmax";
            newField = vgField({ op: "argmax", field: aggOp.argmax }, { forAs: true });
            newFieldDef.field = `${newField}.${field3}`;
          } else if (isArgminDef(aggOp)) {
            op = "argmin";
            newField = vgField({ op: "argmin", field: aggOp.argmin }, { forAs: true });
            newFieldDef.field = `${newField}.${field3}`;
          } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
            op = aggOp;
          }
          if (op) {
            const aggregateEntry = {
              op,
              as: newField
            };
            if (field3) {
              aggregateEntry.field = field3;
            }
            aggregate.push(aggregateEntry);
          }
        } else {
          groupby.push(newField);
          if (isTypedFieldDef(channelDef) && isBinning(bin3)) {
            bins2.push({ bin: bin3, field: field3, as: newField });
            groupby.push(vgField(channelDef, { binSuffix: "end" }));
            if (binRequiresRange(channelDef, channel)) {
              groupby.push(vgField(channelDef, { binSuffix: "range" }));
            }
            if (isXorY(channel)) {
              const secondaryChannel = {
                field: `${newField}_end`
              };
              encoding[`${channel}2`] = secondaryChannel;
            }
            newFieldDef.bin = "binned";
            if (!isSecondaryRangeChannel(channel)) {
              newFieldDef["type"] = QUANTITATIVE;
            }
          } else if (timeUnit) {
            timeUnits2.push({
              timeUnit,
              field: field3,
              as: newField
            });
            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
            if (formatType) {
              if (channel === TEXT || channel === TOOLTIP) {
                newFieldDef["formatType"] = formatType;
              } else if (isNonPositionScaleChannel(channel)) {
                newFieldDef["legend"] = Object.assign({ formatType }, newFieldDef["legend"]);
              } else if (isXorY(channel)) {
                newFieldDef["axis"] = Object.assign({ formatType }, newFieldDef["axis"]);
              }
            }
          }
        }
        encoding[channel] = newFieldDef;
      } else {
        groupby.push(field3);
        encoding[channel] = oldEncoding[channel];
      }
    } else {
      encoding[channel] = oldEncoding[channel];
    }
  });
  return {
    bins: bins2,
    timeUnits: timeUnits2,
    aggregate,
    groupby,
    encoding
  };
}
function markChannelCompatible(encoding, channel, mark2) {
  const markSupported = supportMark(channel, mark2);
  if (!markSupported) {
    return false;
  } else if (markSupported === "binned") {
    const primaryFieldDef = encoding[channel === X22 ? X2 : Y2];
    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function initEncoding(encoding, mark2, filled, config) {
  const normalizedEncoding = {};
  for (const key2 of keys3(encoding)) {
    if (!isChannel(key2)) {
      warn2(message_exports.invalidEncodingChannel(key2));
    }
  }
  for (let channel of UNIT_CHANNELS) {
    if (!encoding[channel]) {
      continue;
    }
    const channelDef = encoding[channel];
    if (isXorYOffset(channel)) {
      const mainChannel = getMainChannelFromOffsetChannel(channel);
      const positionDef = normalizedEncoding[mainChannel];
      if (isFieldDef(positionDef)) {
        if (isContinuous2(positionDef.type)) {
          if (isFieldDef(channelDef)) {
            warn2(message_exports.offsetNestedInsideContinuousPositionScaleDropped(mainChannel));
            continue;
          }
        }
      } else {
        channel = mainChannel;
        warn2(message_exports.replaceOffsetWithMainChannel(mainChannel));
      }
    }
    if (channel === "angle" && mark2 === "arc" && !encoding.theta) {
      warn2(message_exports.REPLACE_ANGLE_WITH_THETA);
      channel = THETA;
    }
    if (!markChannelCompatible(encoding, channel, mark2)) {
      warn2(message_exports.incompatibleChannel(channel, mark2));
      continue;
    }
    if (channel === SIZE2 && mark2 === "line") {
      const fieldDef = getFieldDef(encoding[channel]);
      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {
        warn2(message_exports.LINE_WITH_VARYING_SIZE);
        continue;
      }
    }
    if (channel === COLOR && (filled ? "fill" in encoding : "stroke" in encoding)) {
      warn2(message_exports.droppingColor("encoding", { fill: "fill" in encoding, stroke: "stroke" in encoding }));
      continue;
    }
    if (channel === DETAIL || channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray(channelDef)) {
      if (channelDef) {
        normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {
          if (!isFieldDef(fieldDef)) {
            warn2(message_exports.emptyFieldDef(fieldDef, channel));
          } else {
            defs.push(initFieldDef(fieldDef, channel));
          }
          return defs;
        }, []);
      }
    } else {
      if (channel === TOOLTIP && channelDef === null) {
        normalizedEncoding[channel] = null;
      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
        warn2(message_exports.emptyFieldDef(channelDef, channel));
        continue;
      }
      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
    }
  }
  return normalizedEncoding;
}
function normalizeEncoding(encoding, config) {
  const normalizedEncoding = {};
  for (const channel of keys3(encoding)) {
    const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });
    normalizedEncoding[channel] = newChannelDef;
  }
  return normalizedEncoding;
}
function fieldDefs(encoding) {
  const arr = [];
  for (const channel of keys3(encoding)) {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      const channelDefArray = array(channelDef);
      for (const def2 of channelDefArray) {
        if (isFieldDef(def2)) {
          arr.push(def2);
        } else if (hasConditionalFieldDef(def2)) {
          arr.push(def2.condition);
        }
      }
    }
  }
  return arr;
}
function forEach(mapping, f, thisArg) {
  if (!mapping) {
    return;
  }
  for (const channel of keys3(mapping)) {
    const el = mapping[channel];
    if (isArray(el)) {
      for (const channelDef of el) {
        f.call(thisArg, channelDef, channel);
      }
    } else {
      f.call(thisArg, el, channel);
    }
  }
}
function reduce(mapping, f, init2, thisArg) {
  if (!mapping) {
    return init2;
  }
  return keys3(mapping).reduce((r2, channel) => {
    const map2 = mapping[channel];
    if (isArray(map2)) {
      return map2.reduce((r1, channelDef) => {
        return f.call(thisArg, r1, channelDef, channel);
      }, r2);
    } else {
      return f.call(thisArg, r2, map2, channel);
    }
  }, init2);
}
function pathGroupingFields(mark2, encoding) {
  return keys3(encoding).reduce((details, channel) => {
    switch (channel) {
      case X2:
      case Y2:
      case HREF:
      case DESCRIPTION:
      case URL2:
      case X22:
      case Y22:
      case XOFFSET:
      case YOFFSET:
      case THETA:
      case THETA2:
      case RADIUS:
      case RADIUS2:
      case LATITUDE:
      case LONGITUDE:
      case LATITUDE2:
      case LONGITUDE2:
      case TEXT:
      case SHAPE:
      case ANGLE:
      case TOOLTIP:
        return details;
      case ORDER:
        if (mark2 === "line" || mark2 === "trail") {
          return details;
        }
      case DETAIL:
      case KEY: {
        const channelDef = encoding[channel];
        if (isArray(channelDef) || isFieldDef(channelDef)) {
          for (const fieldDef of array(channelDef)) {
            if (!fieldDef.aggregate) {
              details.push(vgField(fieldDef, {}));
            }
          }
        }
        return details;
      }
      case SIZE2:
        if (mark2 === "trail") {
          return details;
        }
      case COLOR:
      case FILL:
      case STROKE:
      case OPACITY:
      case FILLOPACITY:
      case STROKEOPACITY:
      case STROKEDASH:
      case STROKEWIDTH: {
        const fieldDef = getFieldDef(encoding[channel]);
        if (fieldDef && !fieldDef.aggregate) {
          details.push(vgField(fieldDef, {}));
        }
        return details;
      }
    }
  }, []);
}

// node_modules/vega-lite/build/src/compositemark/common.js
var __rest8 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function filterTooltipWithAggregatedField(oldEncoding) {
  const { tooltip: tooltip2 } = oldEncoding, filteredEncoding = __rest8(oldEncoding, ["tooltip"]);
  if (!tooltip2) {
    return { filteredEncoding };
  }
  let customTooltipWithAggregatedField;
  let customTooltipWithoutAggregatedField;
  if (isArray(tooltip2)) {
    for (const t2 of tooltip2) {
      if (t2.aggregate) {
        if (!customTooltipWithAggregatedField) {
          customTooltipWithAggregatedField = [];
        }
        customTooltipWithAggregatedField.push(t2);
      } else {
        if (!customTooltipWithoutAggregatedField) {
          customTooltipWithoutAggregatedField = [];
        }
        customTooltipWithoutAggregatedField.push(t2);
      }
    }
    if (customTooltipWithAggregatedField) {
      filteredEncoding.tooltip = customTooltipWithAggregatedField;
    }
  } else {
    if (tooltip2["aggregate"]) {
      filteredEncoding.tooltip = tooltip2;
    } else {
      customTooltipWithoutAggregatedField = tooltip2;
    }
  }
  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
  }
  return { customTooltipWithoutAggregatedField, filteredEncoding };
}
function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
  if ("tooltip" in encodingWithoutContinuousAxis) {
    return { tooltip: encodingWithoutContinuousAxis.tooltip };
  }
  const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {
    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : "";
    return {
      field: fieldPrefix + continuousAxisChannelDef.field,
      type: continuousAxisChannelDef.type,
      title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}"${escape(mainTitle)}"` } : titlePrefix + mainTitle
    };
  });
  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);
  return {
    tooltip: [
      ...fiveSummaryTooltip,
      // need to cast because TextFieldDef supports fewer types of bin
      ...unique(tooltipFieldDefs, hash)
    ]
  };
}
function getTitle(continuousAxisChannelDef) {
  const { title: title2, field: field3 } = continuousAxisChannelDef;
  return getFirstDefined(title2, field3);
}
function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
  const { scale: scale6, axis } = continuousAxisChannelDef;
  return ({ partName, mark: mark2, positionPrefix, endPositionPrefix = void 0, extraEncoding = {} }) => {
    const title2 = getTitle(continuousAxisChannelDef);
    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {
      mark: mark2,
      encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: `${positionPrefix}_${continuousAxisChannelDef.field}`, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale6 !== void 0 ? { scale: scale6 } : {}), axis !== void 0 ? { axis } : {}) }, isString(endPositionPrefix) ? {
        [`${continuousAxis}2`]: {
          field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`
        }
      } : {}), sharedEncoding), extraEncoding)
    });
  };
}
function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {
  const { clip: clip3, color: color4, opacity: opacity2 } = markDef;
  const mark2 = markDef.type;
  if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
    return [
      Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip3 ? { clip: clip3 } : {}), color4 ? { color: color4 } : {}), opacity2 ? { opacity: opacity2 } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark }), { style: `${mark2}-${String(part)}` }), isBoolean(markDef[part]) ? {} : markDef[part]) })
    ];
  }
  return [];
}
function compositeMarkContinuousAxis(spec, orient2, compositeMark) {
  const { encoding } = spec;
  const continuousAxis = orient2 === "vertical" ? "y" : "x";
  const continuousAxisChannelDef = encoding[continuousAxis];
  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];
  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];
  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];
  return {
    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
    continuousAxis
  };
}
function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {
    const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest8(continuousAxisChannelDef, ["aggregate"]);
    if (aggregate !== compositeMark) {
      warn2(message_exports.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
    }
    return continuousAxisWithoutAggregate;
  } else {
    return continuousAxisChannelDef;
  }
}
function compositeMarkOrient(spec, compositeMark) {
  const { mark: mark2, encoding } = spec;
  const { x: x2, y: y2 } = encoding;
  if (isMarkDef(mark2) && mark2.orient) {
    return mark2.orient;
  }
  if (isContinuousFieldOrDatumDef(x2)) {
    if (isContinuousFieldOrDatumDef(y2)) {
      const xAggregate = isFieldDef(x2) && x2.aggregate;
      const yAggregate = isFieldDef(y2) && y2.aggregate;
      if (!xAggregate && yAggregate === compositeMark) {
        return "vertical";
      } else if (!yAggregate && xAggregate === compositeMark) {
        return "horizontal";
      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
        throw new Error("Both x and y cannot have aggregate");
      } else {
        if (isFieldOrDatumDefForTimeFormat(y2) && !isFieldOrDatumDefForTimeFormat(x2)) {
          return "horizontal";
        }
        return "vertical";
      }
    }
    return "horizontal";
  } else if (isContinuousFieldOrDatumDef(y2)) {
    return "vertical";
  } else {
    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);
  }
}

// node_modules/vega-lite/build/src/compositemark/boxplot.js
var __rest9 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var BOXPLOT = "boxplot";
var BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
function getBoxPlotType(extent2) {
  if (isNumber(extent2)) {
    return "tukey";
  }
  return extent2;
}
function normalizeBoxPlot(spec, { config }) {
  var _a, _b;
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { mark: mark2, encoding: _encoding, params: params2, projection: _p } = spec, outerSpec = __rest9(spec, ["mark", "encoding", "params", "projection"]);
  const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
  if (params2) {
    warn2(message_exports.selectionNotSupported("boxplot"));
  }
  const extent2 = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;
  const sizeValue = getMarkPropOrConfig(
    "size",
    markDef,
    // TODO: https://github.com/vega/vega-lite/issues/6245
    config
  );
  const boxPlotType = getBoxPlotType(extent2);
  const { bins: bins2, timeUnits: timeUnits2, transform: transform4, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent2, config);
  const { color: color4, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest9(encodingWithoutContinuousAxis, ["color", "size"]);
  const makeBoxPlotPart = (sharedEncoding) => {
    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
  };
  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? { size } : {}));
  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
    { fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const endTick = { type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid: null, aria: false };
  const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : (
    // for tukey / k-IQR, just show upper/lower-whisker
    getCompositeMarkTooltip([
      { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
      { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
    ], continuousAxisChannelDef, encodingWithoutContinuousAxis)
  );
  const whiskerLayers = [
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null, aria: false },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null, aria: false },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "lower_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    })
  ];
  const boxLayers = [
    ...boxPlotType !== "tukey" ? whiskerLayers : [],
    ...makeBoxPlotBox({
      partName: "box",
      mark: Object.assign(Object.assign({ type: "bar" }, sizeValue ? { size: sizeValue } : {}), { orient: boxOrient, invalid: null, ariaRoleDescription: "box" }),
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: fiveSummaryTooltipEncoding
    }),
    ...makeBoxPlotMidTick({
      partName: "median",
      mark: Object.assign(Object.assign(Object.assign({ type: "tick", invalid: null }, isObject(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {}), sizeValue ? { size: sizeValue } : {}), { orient: ticksOrient, aria: false }),
      positionPrefix: "mid_box",
      extraEncoding: fiveSummaryTooltipEncoding
    })
  ];
  if (boxPlotType === "min-max") {
    return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform4), layer: boxLayers });
  }
  const lowerBoxExpr = `datum["lower_box_${continuousAxisChannelDef.field}"]`;
  const upperBoxExpr = `datum["upper_box_${continuousAxisChannelDef.field}"]`;
  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent2} * ${iqrExpr}`;
  const upperWhiskerExpr = `${upperBoxExpr} + ${extent2} * ${iqrExpr}`;
  const fieldExpr2 = `datum["${continuousAxisChannelDef.field}"]`;
  const joinaggregateTransform = {
    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
    groupby
  };
  const filteredWhiskerSpec = {
    transform: [
      {
        filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: continuousAxisChannelDef.field,
            as: `lower_whisker_${continuousAxisChannelDef.field}`
          },
          {
            op: "max",
            field: continuousAxisChannelDef.field,
            as: `upper_whisker_${continuousAxisChannelDef.field}`
          },
          // preserve lower_box / upper_box
          {
            op: "min",
            field: `lower_box_${continuousAxisChannelDef.field}`,
            as: `lower_box_${continuousAxisChannelDef.field}`
          },
          {
            op: "max",
            field: `upper_box_${continuousAxisChannelDef.field}`,
            as: `upper_box_${continuousAxisChannelDef.field}`
          },
          ...aggregate
        ],
        groupby
      }
    ],
    layer: whiskerLayers
  };
  const { tooltip: tooltip2 } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest9(encodingWithoutSizeColorAndContinuousAxis, ["tooltip"]);
  const { scale: scale6, axis } = continuousAxisChannelDef;
  const title2 = getTitle(continuousAxisChannelDef);
  const axisWithoutTitle = omit(axis, ["title"]);
  const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, {
    transform: [{ filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})` }],
    mark: "point",
    encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale6 !== void 0 ? { scale: scale6 } : {}), isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle }) }, encodingWithoutSizeColorContinuousAxisAndTooltip), color4 ? { color: color4 } : {}), customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {})
  })[0];
  let filteredLayersMixins;
  const filteredLayersMixinsTransforms = [...bins2, ...timeUnits2, joinaggregateTransform];
  if (outlierLayersMixins) {
    filteredLayersMixins = {
      transform: filteredLayersMixinsTransforms,
      layer: [outlierLayersMixins, filteredWhiskerSpec]
    };
  } else {
    filteredLayersMixins = filteredWhiskerSpec;
    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);
  }
  return Object.assign(Object.assign({}, outerSpec), { layer: [
    filteredLayersMixins,
    {
      // boxplot
      transform: transform4,
      layer: boxLayers
    }
  ] });
}
function boxParamsQuartiles(continousAxisField) {
  return [
    {
      op: "q1",
      field: continousAxisField,
      as: `lower_box_${continousAxisField}`
    },
    {
      op: "q3",
      field: continousAxisField,
      as: `upper_box_${continousAxisField}`
    }
  ];
}
function boxParams(spec, extent2, config) {
  const orient2 = compositeMarkOrient(spec, BOXPLOT);
  const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, BOXPLOT);
  const continuousFieldName = continuousAxisChannelDef.field;
  const boxPlotType = getBoxPlotType(extent2);
  const boxplotSpecificAggregate = [
    ...boxParamsQuartiles(continuousFieldName),
    {
      op: "median",
      field: continuousFieldName,
      as: `mid_box_${continuousFieldName}`
    },
    {
      op: "min",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + continuousFieldName
    },
    {
      op: "max",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + continuousFieldName
    }
  ];
  const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
    // This is for the  original k-IQR, which we do not expose
    {
      calculate: `datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,
      as: `iqr_${continuousFieldName}`
    },
    {
      calculate: `min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent2}, datum["max_${continuousFieldName}"])`,
      as: `upper_whisker_${continuousFieldName}`
    },
    {
      calculate: `max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent2}, datum["min_${continuousFieldName}"])`,
      as: `lower_whisker_${continuousFieldName}`
    }
  ];
  const _a = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a[_b], oldEncodingWithoutContinuousAxis = __rest9(_a, [typeof _b === "symbol" ? _b : _b + ""]);
  const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
  const { bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);
  const ticksOrient = orient2 === "vertical" ? "horizontal" : "vertical";
  const boxOrient = orient2;
  const transform4 = [
    ...bins2,
    ...timeUnits2,
    {
      aggregate: [...aggregate, ...boxplotSpecificAggregate],
      groupby
    },
    ...postAggregateCalculates
  ];
  return {
    bins: bins2,
    timeUnits: timeUnits2,
    transform: transform4,
    groupby,
    aggregate,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient,
    boxOrient,
    customTooltipWithoutAggregatedField
  };
}

// node_modules/vega-lite/build/src/compositemark/errorbar.js
var __rest10 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var ERRORBAR = "errorbar";
var ERRORBAR_PARTS = ["ticks", "rule"];
var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
function normalizeErrorBar(spec, { config }) {
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);
  delete encodingWithoutContinuousAxis["size"];
  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
  const thickness = markDef.thickness;
  const size = markDef.size;
  const tick2 = Object.assign(Object.assign({ type: "tick", orient: ticksOrient, aria: false }, thickness !== void 0 ? { thickness } : {}), size !== void 0 ? { size } : {});
  const layer = [
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "rule",
      mark: Object.assign({ type: "rule", ariaRoleDescription: "errorbar" }, thickness !== void 0 ? { size: thickness } : {}),
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ];
  return Object.assign(Object.assign(Object.assign({}, outerSpec), { transform: transform4 }), layer.length > 1 ? { layer } : Object.assign({}, layer[0]));
}
function errorBarOrientAndInputType(spec, compositeMark) {
  const { encoding } = spec;
  if (errorBarIsInputTypeRaw(encoding)) {
    return {
      orient: compositeMarkOrient(spec, compositeMark),
      inputType: "raw"
    };
  }
  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
  const x2 = encoding.x;
  const y2 = encoding.y;
  if (isTypeAggregatedUpperLower) {
    if (isTypeAggregatedError) {
      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
    }
    const x22 = encoding.x2;
    const y22 = encoding.y2;
    if (isFieldOrDatumDef(x22) && isFieldOrDatumDef(y22)) {
      throw new Error(`${compositeMark} cannot have both x2 and y2`);
    } else if (isFieldOrDatumDef(x22)) {
      if (isContinuousFieldOrDatumDef(x2)) {
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
      }
    } else if (isFieldOrDatumDef(y22)) {
      if (isContinuousFieldOrDatumDef(y2)) {
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
      }
    }
    throw new Error("No ranged axis");
  } else {
    const xError = encoding.xError;
    const xError2 = encoding.xError2;
    const yError = encoding.yError;
    const yError2 = encoding.yError2;
    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
      throw new Error(`${compositeMark} cannot have xError2 without xError`);
    }
    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have yError2 without yError`);
    }
    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
    } else if (isFieldOrDatumDef(xError)) {
      if (isContinuousFieldOrDatumDef(x2)) {
        return { orient: "horizontal", inputType: "aggregated-error" };
      } else {
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      }
    } else if (isFieldOrDatumDef(yError)) {
      if (isContinuousFieldOrDatumDef(y2)) {
        return { orient: "vertical", inputType: "aggregated-error" };
      } else {
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
    }
    throw new Error("No ranged axis");
  }
}
function errorBarIsInputTypeRaw(encoding) {
  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(encoding) {
  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
}
function errorBarIsInputTypeAggregatedError(encoding) {
  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
}
function errorBarParams(spec, compositeMark, config) {
  var _a;
  const { mark: mark2, encoding, params: params2, projection: _p } = spec, outerSpec = __rest10(spec, ["mark", "encoding", "params", "projection"]);
  const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
  if (params2) {
    warn2(message_exports.selectionNotSupported(compositeMark));
  }
  const { orient: orient2, inputType } = errorBarOrientAndInputType(spec, compositeMark);
  const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, compositeMark);
  const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
  const _b = encoding, _c2 = continuousAxis, oldContinuousAxisChannelDef = _b[_c2], _d2 = continuousAxis === "x" ? "x2" : "y2", oldContinuousAxisChannelDef2 = _b[_d2], _e = continuousAxis === "x" ? "xError" : "yError", oldContinuousAxisChannelDefError = _b[_e], _f2 = continuousAxis === "x" ? "xError2" : "yError2", oldContinuousAxisChannelDefError2 = _b[_f2], oldEncodingWithoutContinuousAxis = __rest10(_b, [typeof _c2 === "symbol" ? _c2 : _c2 + "", typeof _d2 === "symbol" ? _d2 : _d2 + "", typeof _e === "symbol" ? _e : _e + "", typeof _f2 === "symbol" ? _f2 : _f2 + ""]);
  const { bins: bins2, timeUnits: timeUnits2, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
  const groupby = inputType !== "raw" ? [] : oldGroupBy;
  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
  return {
    transform: [
      ...(_a = outerSpec.transform) !== null && _a !== void 0 ? _a : [],
      ...bins2,
      ...timeUnits2,
      ...aggregate.length === 0 ? [] : [{ aggregate, groupby }],
      ...postAggregateCalculates
    ],
    groupby,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient: orient2 === "vertical" ? "horizontal" : "vertical",
    markDef,
    outerSpec,
    tooltipEncoding
  };
}
function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
  let errorBarSpecificAggregate = [];
  let postAggregateCalculates = [];
  const continuousFieldName = continuousAxisChannelDef.field;
  let tooltipSummary;
  let tooltipTitleWithFieldName = false;
  if (inputType === "raw") {
    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
    const extent2 = markDef.extent ? markDef.extent : center === "mean" ? "stderr" : "iqr";
    if (center === "median" !== (extent2 === "iqr")) {
      warn2(message_exports.errorBarCenterIsUsedWithWrongExtent(center, extent2, compositeMark));
    }
    if (extent2 === "stderr" || extent2 === "stdev") {
      errorBarSpecificAggregate = [
        { op: extent2, field: continuousFieldName, as: `extent_${continuousFieldName}` },
        { op: center, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      postAggregateCalculates = [
        {
          calculate: `datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,
          as: `upper_${continuousFieldName}`
        },
        {
          calculate: `datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,
          as: `lower_${continuousFieldName}`
        }
      ];
      tooltipSummary = [
        { fieldPrefix: "center_", titlePrefix: titleCase(center) },
        { fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center, extent2, "+") },
        { fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center, extent2, "-") }
      ];
      tooltipTitleWithFieldName = true;
    } else {
      let centerOp;
      let lowerExtentOp;
      let upperExtentOp;
      if (extent2 === "ci") {
        centerOp = "mean";
        lowerExtentOp = "ci0";
        upperExtentOp = "ci1";
      } else {
        centerOp = "median";
        lowerExtentOp = "q1";
        upperExtentOp = "q3";
      }
      errorBarSpecificAggregate = [
        { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },
        { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },
        { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      tooltipSummary = [
        {
          fieldPrefix: "upper_",
          titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        }
      ];
    }
  } else {
    if (markDef.center || markDef.extent) {
      warn2(message_exports.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
    }
    if (inputType === "aggregated-upper-lower") {
      tooltipSummary = [];
      postAggregateCalculates = [
        { calculate: `datum["${continuousAxisChannelDef2.field}"]`, as: `upper_${continuousFieldName}` },
        { calculate: `datum["${continuousFieldName}"]`, as: `lower_${continuousFieldName}` }
      ];
    } else if (inputType === "aggregated-error") {
      tooltipSummary = [{ fieldPrefix: "", titlePrefix: continuousFieldName }];
      postAggregateCalculates = [
        {
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,
          as: `upper_${continuousFieldName}`
        }
      ];
      if (continuousAxisChannelDefError2) {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,
          as: `lower_${continuousFieldName}`
        });
      } else {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
          as: `lower_${continuousFieldName}`
        });
      }
    }
    for (const postAggregateCalculate of postAggregateCalculates) {
      tooltipSummary.push({
        fieldPrefix: postAggregateCalculate.as.substring(0, 6),
        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum["', ""), '"]', "")
      });
    }
  }
  return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };
}
function getTitlePrefix(center, extent2, operation) {
  return `${titleCase(center)} ${operation} ${extent2}`;
}

// node_modules/vega-lite/build/src/compositemark/errorband.js
var ERRORBAND = "errorband";
var ERRORBAND_PARTS = ["band", "borders"];
var errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
function normalizeErrorBand(spec, { config }) {
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);
  const errorBandDef = markDef;
  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
  const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
  let bandMark = { type: is2D ? "area" : "rect" };
  let bordersMark = { type: is2D ? "line" : "rule" };
  const interpolate3 = Object.assign(Object.assign({}, errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {}), errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {});
  if (is2D) {
    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate3), { ariaRoleDescription: "errorband" });
    bordersMark = Object.assign(Object.assign(Object.assign({}, bordersMark), interpolate3), { aria: false });
  } else if (errorBandDef.interpolate) {
    warn2(message_exports.errorBand1DNotSupport("interpolate"));
  } else if (errorBandDef.tension) {
    warn2(message_exports.errorBand1DNotSupport("tension"));
  }
  return Object.assign(Object.assign({}, outerSpec), { transform: transform4, layer: [
    ...makeErrorBandPart({
      partName: "band",
      mark: bandMark,
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ] });
}

// node_modules/vega-lite/build/src/compositemark/index.js
var compositeMarkRegistry = {};
function add4(mark2, run2, parts) {
  const normalizer = new CompositeMarkNormalizer(mark2, run2);
  compositeMarkRegistry[mark2] = { normalizer, parts };
}
function getAllCompositeMarks() {
  return keys3(compositeMarkRegistry);
}
add4(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
add4(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
add4(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);

// node_modules/vega-lite/build/src/guide.js
var VL_ONLY_LEGEND_CONFIG = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
];

// node_modules/vega-lite/build/src/header.js
var HEADER_TITLE_PROPERTIES_MAP = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
};
var HEADER_LABEL_PROPERTIES_MAP = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
};
var HEADER_TITLE_PROPERTIES = keys3(HEADER_TITLE_PROPERTIES_MAP);
var HEADER_LABEL_PROPERTIES = keys3(HEADER_LABEL_PROPERTIES_MAP);
var HEADER_CONFIGS_INDEX = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
};
var HEADER_CONFIGS = keys3(HEADER_CONFIGS_INDEX);

// node_modules/vega-lite/build/src/legend.js
var LEGEND_SCALE_CHANNELS = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
];
var defaultLegendConfig = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
};
var COMMON_LEGEND_PROPERTY_INDEX = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
};
var LEGEND_PROPERTIES = keys3(COMMON_LEGEND_PROPERTY_INDEX);

// node_modules/vega-lite/build/src/selection.js
var SELECTION_ID = "_vgsid_";
var defaultConfig = {
  point: {
    on: "click",
    fields: [SELECTION_ID],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[mousedown, window:mouseup] > window:mousemove!",
    encodings: ["x", "y"],
    translate: "[mousedown, window:mouseup] > window:mousemove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function isLegendBinding(bind3) {
  return bind3 === "legend" || !!(bind3 === null || bind3 === void 0 ? void 0 : bind3.legend);
}
function isLegendStreamBinding(bind3) {
  return isLegendBinding(bind3) && isObject(bind3);
}
function isSelectionParameter(param2) {
  return !!(param2 === null || param2 === void 0 ? void 0 : param2["select"]);
}

// node_modules/vega-lite/build/src/parameter.js
var __rest11 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleParameterSignals(params2) {
  const signals = [];
  for (const param2 of params2 || []) {
    if (isSelectionParameter(param2))
      continue;
    const { expr: expr2, bind: bind3 } = param2, rest = __rest11(param2, ["expr", "bind"]);
    if (bind3 && expr2) {
      const signal = Object.assign(Object.assign({}, rest), { bind: bind3, init: expr2 });
      signals.push(signal);
    } else {
      const signal = Object.assign(Object.assign(Object.assign({}, rest), expr2 ? { update: expr2 } : {}), bind3 ? { bind: bind3 } : {});
      signals.push(signal);
    }
  }
  return signals;
}

// node_modules/vega-lite/build/src/spec/concat.js
function isAnyConcatSpec(spec) {
  return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
}
function isConcatSpec(spec) {
  return "concat" in spec;
}
function isVConcatSpec(spec) {
  return "vconcat" in spec;
}
function isHConcatSpec(spec) {
  return "hconcat" in spec;
}

// node_modules/vega-lite/build/src/spec/base.js
function getStepFor({ step, offsetIsDiscrete }) {
  var _a;
  if (offsetIsDiscrete) {
    return (_a = step.for) !== null && _a !== void 0 ? _a : "offset";
  } else {
    return "position";
  }
}
function isStep(size) {
  return isObject(size) && size["step"] !== void 0;
}
function isFrameMixins(o) {
  return o["view"] || o["width"] || o["height"];
}
var DEFAULT_SPACING = 20;
var COMPOSITION_LAYOUT_INDEX = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
};
var COMPOSITION_LAYOUT_PROPERTIES = keys3(COMPOSITION_LAYOUT_INDEX);
function extractCompositionLayout(spec, specType, config) {
  var _a, _b;
  const compositionConfig = config[specType];
  const layout = {};
  const { spacing: spacingConfig, columns } = compositionConfig;
  if (spacingConfig !== void 0) {
    layout.spacing = spacingConfig;
  }
  if (columns !== void 0) {
    if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
      layout.columns = columns;
    }
  }
  if (isVConcatSpec(spec)) {
    layout.columns = 1;
  }
  for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
    if (spec[prop] !== void 0) {
      if (prop === "spacing") {
        const spacing = spec[prop];
        layout[prop] = isNumber(spacing) ? spacing : {
          row: (_a = spacing.row) !== null && _a !== void 0 ? _a : spacingConfig,
          column: (_b = spacing.column) !== null && _b !== void 0 ? _b : spacingConfig
        };
      } else {
        layout[prop] = spec[prop];
      }
    }
  }
  return layout;
}

// node_modules/vega-lite/build/src/config.js
var __rest12 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function getViewConfigContinuousSize(viewConfig, channel) {
  var _a;
  return (_a = viewConfig[channel]) !== null && _a !== void 0 ? _a : viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(viewConfig, channel) {
  const size = getViewConfigDiscreteSize(viewConfig, channel);
  return isStep(size) ? size.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(viewConfig, channel) {
  var _a;
  const size = (_a = viewConfig[channel]) !== null && _a !== void 0 ? _a : viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
  return getFirstDefined(size, { step: viewConfig.step });
}
var DEFAULT_STEP = 20;
var defaultViewConfig = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: DEFAULT_STEP
};
var defaultConfig2 = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: defaultViewConfig,
  mark: defaultMarkConfig,
  arc: {},
  area: {},
  bar: defaultBarConfig,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: defaultRectConfig,
  rule: { color: "black" },
  square: {},
  text: { color: "black" },
  tick: defaultTickConfig,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: true,
    ticks: false
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: false
  },
  scale: defaultScaleConfig,
  projection: {},
  legend: defaultLegendConfig,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: defaultConfig,
  style: {},
  title: {},
  facet: { spacing: DEFAULT_SPACING },
  concat: { spacing: DEFAULT_SPACING },
  normalizedNumberFormat: ".0%"
};
var tab10 = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
];
var DEFAULT_FONT_SIZE = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
};
var DEFAULT_COLOR = {
  blue: tab10[0],
  orange: tab10[1],
  red: tab10[2],
  teal: tab10[3],
  green: tab10[4],
  yellow: tab10[5],
  purple: tab10[6],
  pink: tab10[7],
  brown: tab10[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function colorSignalConfig(color4 = {}) {
  return {
    signals: [
      {
        name: "color",
        value: isObject(color4) ? Object.assign(Object.assign({}, DEFAULT_COLOR), color4) : DEFAULT_COLOR
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function fontSizeSignalConfig(fontSize2) {
  return {
    signals: [
      {
        name: "fontSize",
        value: isObject(fontSize2) ? Object.assign(Object.assign({}, DEFAULT_FONT_SIZE), fontSize2) : DEFAULT_FONT_SIZE
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function fontConfig(font3) {
  return {
    text: { font: font3 },
    style: {
      "guide-label": { font: font3 },
      "guide-title": { font: font3 },
      "group-title": { font: font3 },
      "group-subtitle": { font: font3 }
    }
  };
}
function getAxisConfigInternal(axisConfig2) {
  const props = keys3(axisConfig2 || {});
  const axisConfigInternal = {};
  for (const prop of props) {
    const val = axisConfig2[prop];
    axisConfigInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
  }
  return axisConfigInternal;
}
function getStyleConfigInternal(styleConfig) {
  const props = keys3(styleConfig);
  const styleConfigInternal = {};
  for (const prop of props) {
    styleConfigInternal[prop] = getAxisConfigInternal(styleConfig[prop]);
  }
  return styleConfigInternal;
}
var configPropsWithExpr = [
  ...MARK_CONFIGS,
  ...AXIS_CONFIGS,
  ...HEADER_CONFIGS,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function initConfig(specifiedConfig = {}) {
  const { color: color4, font: font3, fontSize: fontSize2, selection } = specifiedConfig, restConfig = __rest12(specifiedConfig, ["color", "font", "fontSize", "selection"]);
  const mergedConfig = mergeConfig({}, duplicate(defaultConfig2), font3 ? fontConfig(font3) : {}, color4 ? colorSignalConfig(color4) : {}, fontSize2 ? fontSizeSignalConfig(fontSize2) : {}, restConfig || {});
  if (selection) {
    writeConfig(mergedConfig, "selection", selection, true);
  }
  const outputConfig = omit(mergedConfig, configPropsWithExpr);
  for (const prop of ["background", "lineBreak", "padding"]) {
    if (mergedConfig[prop]) {
      outputConfig[prop] = signalRefOrValue(mergedConfig[prop]);
    }
  }
  for (const markConfigType of MARK_CONFIGS) {
    if (mergedConfig[markConfigType]) {
      outputConfig[markConfigType] = replaceExprRef(mergedConfig[markConfigType]);
    }
  }
  for (const axisConfigType of AXIS_CONFIGS) {
    if (mergedConfig[axisConfigType]) {
      outputConfig[axisConfigType] = getAxisConfigInternal(mergedConfig[axisConfigType]);
    }
  }
  for (const headerConfigType of HEADER_CONFIGS) {
    if (mergedConfig[headerConfigType]) {
      outputConfig[headerConfigType] = replaceExprRef(mergedConfig[headerConfigType]);
    }
  }
  if (mergedConfig.legend) {
    outputConfig.legend = replaceExprRef(mergedConfig.legend);
  }
  if (mergedConfig.scale) {
    outputConfig.scale = replaceExprRef(mergedConfig.scale);
  }
  if (mergedConfig.style) {
    outputConfig.style = getStyleConfigInternal(mergedConfig.style);
  }
  if (mergedConfig.title) {
    outputConfig.title = replaceExprRef(mergedConfig.title);
  }
  if (mergedConfig.view) {
    outputConfig.view = replaceExprRef(mergedConfig.view);
  }
  return outputConfig;
}
var MARK_STYLES = /* @__PURE__ */ new Set(["view", ...PRIMITIVE_MARKS]);
var VL_ONLY_CONFIG_PROPERTIES = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
  // FIXME: Redesign and unhide this
];
var VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = Object.assign({ view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"] }, VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX);
function stripAndRedirectConfig(config) {
  config = duplicate(config);
  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
    delete config[prop];
  }
  if (config.axis) {
    for (const prop in config.axis) {
      if (isConditionalAxisValue(config.axis[prop])) {
        delete config.axis[prop];
      }
    }
  }
  if (config.legend) {
    for (const prop of VL_ONLY_LEGEND_CONFIG) {
      delete config.legend[prop];
    }
  }
  if (config.mark) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config.mark[prop];
    }
    if (config.mark.tooltip && isObject(config.mark.tooltip)) {
      delete config.mark.tooltip;
    }
  }
  if (config.params) {
    config.signals = (config.signals || []).concat(assembleParameterSignals(config.params));
    delete config.params;
  }
  for (const markType2 of MARK_STYLES) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config[markType2][prop];
    }
    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType2];
    if (vlOnlyMarkSpecificConfigs) {
      for (const prop of vlOnlyMarkSpecificConfigs) {
        delete config[markType2][prop];
      }
    }
    redirectConfigToStyleConfig(config, markType2);
  }
  for (const m of getAllCompositeMarks()) {
    delete config[m];
  }
  redirectTitleConfig(config);
  for (const prop in config) {
    if (isObject(config[prop]) && isEmpty(config[prop])) {
      delete config[prop];
    }
  }
  return isEmpty(config) ? void 0 : config;
}
function redirectTitleConfig(config) {
  const { titleMarkConfig, subtitleMarkConfig, subtitle } = extractTitleConfig(config.title);
  if (!isEmpty(titleMarkConfig)) {
    config.style["group-title"] = Object.assign(
      Object.assign({}, config.style["group-title"]),
      titleMarkConfig
      // config.title has higher precedence than config.style.group-title in Vega
    );
  }
  if (!isEmpty(subtitleMarkConfig)) {
    config.style["group-subtitle"] = Object.assign(Object.assign({}, config.style["group-subtitle"]), subtitleMarkConfig);
  }
  if (!isEmpty(subtitle)) {
    config.title = subtitle;
  } else {
    delete config.title;
  }
}
function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
  const propConfig = compositeMarkPart ? config[prop][compositeMarkPart] : config[prop];
  if (prop === "view") {
    toProp = "cell";
  }
  const style2 = Object.assign(Object.assign({}, propConfig), config.style[toProp !== null && toProp !== void 0 ? toProp : prop]);
  if (!isEmpty(style2)) {
    config.style[toProp !== null && toProp !== void 0 ? toProp : prop] = style2;
  }
  if (!compositeMarkPart) {
    delete config[prop];
  }
}

// node_modules/vega-lite/build/src/spec/layer.js
function isLayerSpec(spec) {
  return "layer" in spec;
}

// node_modules/vega-lite/build/src/spec/repeat.js
function isRepeatSpec(spec) {
  return "repeat" in spec;
}
function isLayerRepeatSpec(spec) {
  return !isArray(spec.repeat) && spec.repeat["layer"];
}

// node_modules/vega-lite/build/src/spec/map.js
var __rest13 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var SpecMapper = class {
  map(spec, params2) {
    if (isFacetSpec(spec)) {
      return this.mapFacet(spec, params2);
    } else if (isRepeatSpec(spec)) {
      return this.mapRepeat(spec, params2);
    } else if (isHConcatSpec(spec)) {
      return this.mapHConcat(spec, params2);
    } else if (isVConcatSpec(spec)) {
      return this.mapVConcat(spec, params2);
    } else if (isConcatSpec(spec)) {
      return this.mapConcat(spec, params2);
    } else {
      return this.mapLayerOrUnit(spec, params2);
    }
  }
  mapLayerOrUnit(spec, params2) {
    if (isLayerSpec(spec)) {
      return this.mapLayer(spec, params2);
    } else if (isUnitSpec(spec)) {
      return this.mapUnit(spec, params2);
    }
    throw new Error(message_exports.invalidSpec(spec));
  }
  mapLayer(spec, params2) {
    return Object.assign(Object.assign({}, spec), { layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params2)) });
  }
  mapHConcat(spec, params2) {
    return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map((subspec) => this.map(subspec, params2)) });
  }
  mapVConcat(spec, params2) {
    return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map((subspec) => this.map(subspec, params2)) });
  }
  mapConcat(spec, params2) {
    const { concat } = spec, rest = __rest13(spec, ["concat"]);
    return Object.assign(Object.assign({}, rest), { concat: concat.map((subspec) => this.map(subspec, params2)) });
  }
  mapFacet(spec, params2) {
    return Object.assign(Object.assign({}, spec), {
      // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
      spec: this.map(spec.spec, params2)
    });
  }
  mapRepeat(spec, params2) {
    return Object.assign(Object.assign({}, spec), {
      // as any is required here since TS cannot infer that the output type satisfies the input type
      spec: this.map(spec.spec, params2)
    });
  }
};

// node_modules/vega-lite/build/src/stack.js
var STACK_OFFSET_INDEX = {
  zero: 1,
  center: 1,
  normalize: 1
};
function isStackOffset(s) {
  return s in STACK_OFFSET_INDEX;
}
var STACKABLE_MARKS = /* @__PURE__ */ new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT2, TICK]);
var STACK_BY_DEFAULT_MARKS = /* @__PURE__ */ new Set([BAR, AREA, ARC]);
function isUnbinnedQuantitative(channelDef) {
  return isFieldDef(channelDef) && channelDefType(channelDef) === "quantitative" && !channelDef.bin;
}
function potentialStackedChannel(encoding, x2) {
  var _a, _b;
  const y2 = x2 === "x" ? "y" : "radius";
  const xDef = encoding[x2];
  const yDef = encoding[y2];
  if (isFieldDef(xDef) && isFieldDef(yDef)) {
    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {
      if (xDef.stack) {
        return x2;
      } else if (yDef.stack) {
        return y2;
      }
      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
      if (xAggregate !== yAggregate) {
        return xAggregate ? x2 : y2;
      } else {
        const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;
        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;
        if (xScale && xScale !== "linear") {
          return y2;
        } else if (yScale && yScale !== "linear") {
          return x2;
        }
      }
    } else if (isUnbinnedQuantitative(xDef)) {
      return x2;
    } else if (isUnbinnedQuantitative(yDef)) {
      return y2;
    }
  } else if (isUnbinnedQuantitative(xDef)) {
    return x2;
  } else if (isUnbinnedQuantitative(yDef)) {
    return y2;
  }
  return void 0;
}
function getDimensionChannel(channel) {
  switch (channel) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function stack(m, encoding) {
  var _a, _b;
  const mark2 = isMarkDef(m) ? m.type : m;
  if (!STACKABLE_MARKS.has(mark2)) {
    return null;
  }
  const fieldChannel = potentialStackedChannel(encoding, "x") || potentialStackedChannel(encoding, "theta");
  if (!fieldChannel) {
    return null;
  }
  const stackedFieldDef = encoding[fieldChannel];
  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
  const dimensionChannel = getDimensionChannel(fieldChannel);
  const groupbyChannels = [];
  const groupbyFields = /* @__PURE__ */ new Set();
  if (encoding[dimensionChannel]) {
    const dimensionDef = encoding[dimensionChannel];
    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
    if (dimensionField && dimensionField !== stackedField) {
      groupbyChannels.push(dimensionChannel);
      groupbyFields.add(dimensionField);
    }
    const dimensionOffsetChannel = dimensionChannel === "x" ? "xOffset" : "yOffset";
    const dimensionOffsetDef = encoding[dimensionOffsetChannel];
    const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : void 0;
    if (dimensionOffsetField && dimensionOffsetField !== stackedField) {
      groupbyChannels.push(dimensionOffsetChannel);
      groupbyFields.add(dimensionOffsetField);
    }
  }
  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
    if (channel !== "tooltip" && channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      for (const cDef of array(channelDef)) {
        const fieldDef = getFieldDef(cDef);
        if (fieldDef.aggregate) {
          continue;
        }
        const f = vgField(fieldDef, {});
        if (
          // if fielddef is a repeat, just include it in the stack by
          !f || // otherwise, the field must be different from the groupBy fields.
          !groupbyFields.has(f)
        ) {
          sc.push({ channel, fieldDef });
        }
      }
    }
    return sc;
  }, []);
  let offset4;
  if (stackedFieldDef.stack !== void 0) {
    if (isBoolean(stackedFieldDef.stack)) {
      offset4 = stackedFieldDef.stack ? "zero" : null;
    } else {
      offset4 = stackedFieldDef.stack;
    }
  } else if (STACK_BY_DEFAULT_MARKS.has(mark2)) {
    offset4 = "zero";
  }
  if (!offset4 || !isStackOffset(offset4)) {
    return null;
  }
  if (isAggregate(encoding) && stackBy.length === 0) {
    return null;
  }
  if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {
    warn2(message_exports.cannotStackNonLinearScale(stackedFieldDef.scale.type));
    return null;
  }
  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
    if (stackedFieldDef.stack !== void 0) {
      warn2(message_exports.cannotStackRangedMark(fieldChannel));
    }
    return null;
  }
  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {
    warn2(message_exports.stackNonSummativeAggregate(stackedFieldDef.aggregate));
  }
  return {
    groupbyChannels,
    groupbyFields,
    fieldChannel,
    impute: stackedFieldDef.impute === null ? false : isPathMark(mark2),
    stackBy,
    offset: offset4
  };
}

// node_modules/vega-lite/build/src/normalize/pathoverlay.js
var __rest14 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function dropLineAndPoint(markDef) {
  const { point: _point, line: _line } = markDef, mark2 = __rest14(markDef, ["point", "line"]);
  return keys3(mark2).length > 1 ? mark2 : mark2.type;
}
function dropLineAndPointFromConfig(config) {
  for (const mark2 of ["line", "area", "rule", "trail"]) {
    if (config[mark2]) {
      config = Object.assign(Object.assign({}, config), {
        // TODO: remove as any
        [mark2]: omit(config[mark2], ["point", "line"])
      });
    }
  }
  return config;
}
function getPointOverlay(markDef, markConfig = {}, encoding) {
  if (markDef.point === "transparent") {
    return { opacity: 0 };
  } else if (markDef.point) {
    return isObject(markDef.point) ? markDef.point : {};
  } else if (markDef.point !== void 0) {
    return null;
  } else {
    if (markConfig.point || encoding.shape) {
      return isObject(markConfig.point) ? markConfig.point : {};
    }
    return void 0;
  }
}
function getLineOverlay(markDef, markConfig = {}) {
  if (markDef.line) {
    return markDef.line === true ? {} : markDef.line;
  } else if (markDef.line !== void 0) {
    return null;
  } else {
    if (markConfig.line) {
      return markConfig.line === true ? {} : markConfig.line;
    }
    return void 0;
  }
}
var PathOverlayNormalizer = class {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(spec, config) {
    if (isUnitSpec(spec)) {
      const { mark: mark2, encoding } = spec;
      const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
      switch (markDef.type) {
        case "line":
        case "rule":
        case "trail":
          return !!getPointOverlay(markDef, config[markDef.type], encoding);
        case "area":
          return (
            // false / null are also included as we want to remove the properties
            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])
          );
      }
    }
    return false;
  }
  run(spec, normParams, normalize2) {
    const { config } = normParams;
    const { params: params2, projection: projection3, mark: mark2, encoding: e2 } = spec, outerSpec = __rest14(spec, ["params", "projection", "mark", "encoding"]);
    const encoding = normalizeEncoding(e2, config);
    const markDef = isMarkDef(mark2) ? mark2 : { type: mark2 };
    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
    const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
    const layer = [
      Object.assign(Object.assign({}, params2 ? { params: params2 } : {}), {
        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? { opacity: 0.7 } : {}), markDef)),
        // drop shape from encoding as this might be used to trigger point overlay
        encoding: omit(encoding, ["shape"])
      })
    ];
    const stackProps = stack(markDef, encoding);
    let overlayEncoding = encoding;
    if (stackProps) {
      const { fieldChannel: stackFieldChannel, offset: offset4 } = stackProps;
      overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset4 ? { stack: offset4 } : {}) });
    }
    if (lineOverlay) {
      layer.push(Object.assign(Object.assign({}, projection3 ? { projection: projection3 } : {}), { mark: Object.assign(Object.assign({ type: "line" }, pick2(markDef, ["clip", "interpolate", "tension", "tooltip"])), lineOverlay), encoding: overlayEncoding }));
    }
    if (pointOverlay) {
      layer.push(Object.assign(Object.assign({}, projection3 ? { projection: projection3 } : {}), { mark: Object.assign(Object.assign({ type: "point", opacity: 1, filled: true }, pick2(markDef, ["clip", "tooltip"])), pointOverlay), encoding: overlayEncoding }));
    }
    return normalize2(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, normParams), { config: dropLineAndPointFromConfig(config) }));
  }
};

// node_modules/vega-lite/build/src/normalize/repeater.js
var __rest15 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function replaceRepeaterInFacet(facet, repeater) {
  if (!repeater) {
    return facet;
  }
  if (isFacetMapping(facet)) {
    return replaceRepeaterInMapping(facet, repeater);
  }
  return replaceRepeaterInFieldDef(facet, repeater);
}
function replaceRepeaterInEncoding(encoding, repeater) {
  if (!repeater) {
    return encoding;
  }
  return replaceRepeaterInMapping(encoding, repeater);
}
function replaceRepeatInProp(prop, o, repeater) {
  const val = o[prop];
  if (isRepeatRef(val)) {
    if (val.repeat in repeater) {
      return Object.assign(Object.assign({}, o), { [prop]: repeater[val.repeat] });
    } else {
      warn2(message_exports.noSuchRepeatedValue(val.repeat));
      return void 0;
    }
  }
  return o;
}
function replaceRepeaterInFieldDef(fieldDef, repeater) {
  fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
  if (fieldDef === void 0) {
    return void 0;
  } else if (fieldDef === null) {
    return null;
  }
  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
    const sort3 = replaceRepeatInProp("field", fieldDef.sort, repeater);
    fieldDef = Object.assign(Object.assign({}, fieldDef), sort3 ? { sort: sort3 } : {});
  }
  return fieldDef;
}
function replaceRepeaterInFieldOrDatumDef(def2, repeater) {
  if (isFieldDef(def2)) {
    return replaceRepeaterInFieldDef(def2, repeater);
  } else {
    const datumDef = replaceRepeatInProp("datum", def2, repeater);
    if (datumDef !== def2 && !datumDef.type) {
      datumDef.type = "nominal";
    }
    return datumDef;
  }
}
function replaceRepeaterInChannelDef(channelDef, repeater) {
  if (isFieldOrDatumDef(channelDef)) {
    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
    if (fd) {
      return fd;
    } else if (isConditionalDef(channelDef)) {
      return { condition: channelDef.condition };
    }
  } else {
    if (hasConditionalFieldOrDatumDef(channelDef)) {
      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
      if (fd) {
        return Object.assign(Object.assign({}, channelDef), { condition: fd });
      } else {
        const { condition } = channelDef, channelDefWithoutCondition = __rest15(channelDef, ["condition"]);
        return channelDefWithoutCondition;
      }
    }
    return channelDef;
  }
  return void 0;
}
function replaceRepeaterInMapping(mapping, repeater) {
  const out = {};
  for (const channel in mapping) {
    if (has(mapping, channel)) {
      const channelDef = mapping[channel];
      if (isArray(channelDef)) {
        out[channel] = channelDef.map((cd) => replaceRepeaterInChannelDef(cd, repeater)).filter((cd) => cd);
      } else {
        const cd = replaceRepeaterInChannelDef(channelDef, repeater);
        if (cd !== void 0) {
          out[channel] = cd;
        }
      }
    }
  }
  return out;
}

// node_modules/vega-lite/build/src/normalize/ruleforrangedline.js
var RuleForRangedLineNormalizer = class {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      const { encoding, mark: mark2 } = spec;
      if (mark2 === "line" || isMarkDef(mark2) && mark2.type === "line") {
        for (const channel of SECONDARY_RANGE_CHANNEL) {
          const mainChannel = getMainRangeChannel(channel);
          const mainChannelDef = encoding[mainChannel];
          if (encoding[channel]) {
            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  run(spec, params2, normalize2) {
    const { encoding, mark: mark2 } = spec;
    warn2(message_exports.lineWithRange(!!encoding.x2, !!encoding.y2));
    return normalize2(Object.assign(Object.assign({}, spec), { mark: isObject(mark2) ? Object.assign(Object.assign({}, mark2), { type: "rule" }) : "rule" }), params2);
  }
};

// node_modules/vega-lite/build/src/normalize/core.js
var __rest16 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var CoreNormalizer = class extends SpecMapper {
  constructor() {
    super(...arguments);
    this.nonFacetUnitNormalizers = [
      boxPlotNormalizer,
      errorBarNormalizer,
      errorBandNormalizer,
      new PathOverlayNormalizer(),
      new RuleForRangedLineNormalizer()
    ];
  }
  map(spec, params2) {
    if (isUnitSpec(spec)) {
      const hasRow = channelHasField(spec.encoding, ROW);
      const hasColumn = channelHasField(spec.encoding, COLUMN);
      const hasFacet = channelHasField(spec.encoding, FACET);
      if (hasRow || hasColumn || hasFacet) {
        return this.mapFacetedUnit(spec, params2);
      }
    }
    return super.map(spec, params2);
  }
  // This is for normalizing non-facet unit
  mapUnit(spec, params2) {
    const { parentEncoding, parentProjection } = params2;
    const encoding = replaceRepeaterInEncoding(spec.encoding, params2.repeater);
    const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? { encoding } : {});
    if (parentEncoding || parentProjection) {
      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params2);
    }
    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
    for (const unitNormalizer of this.nonFacetUnitNormalizers) {
      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params2.config)) {
        return unitNormalizer.run(specWithReplacedEncoding, params2, normalizeLayerOrUnit);
      }
    }
    return specWithReplacedEncoding;
  }
  mapRepeat(spec, params2) {
    if (isLayerRepeatSpec(spec)) {
      return this.mapLayerRepeat(spec, params2);
    } else {
      return this.mapNonLayerRepeat(spec, params2);
    }
  }
  mapLayerRepeat(spec, params2) {
    const { repeat: repeat2, spec: childSpec } = spec, rest = __rest16(spec, ["repeat", "spec"]);
    const { row, column, layer } = repeat2;
    const { repeater = {}, repeaterPrefix = "" } = params2;
    if (row || column) {
      return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, row ? { row } : {}), column ? { column } : {}), spec: {
        repeat: { layer },
        spec: childSpec
      } }), params2);
    } else {
      return Object.assign(Object.assign({}, rest), { layer: layer.map((layerValue) => {
        const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });
        const childName = `${(childSpec.name || "") + repeaterPrefix}child__layer_${varName(layerValue)}`;
        const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params2), { repeater: childRepeater, repeaterPrefix: childName }));
        child.name = childName;
        return child;
      }) });
    }
  }
  mapNonLayerRepeat(spec, params2) {
    var _a;
    const { repeat: repeat2, spec: childSpec, data: data3 } = spec, remainingProperties = __rest16(spec, ["repeat", "spec", "data"]);
    if (!isArray(repeat2) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn2(message_exports.columnsNotSupportByRowCol("repeat"));
    }
    const concat = [];
    const { repeater = {}, repeaterPrefix = "" } = params2;
    const row = !isArray(repeat2) && repeat2.row || [repeater ? repeater.row : null];
    const column = !isArray(repeat2) && repeat2.column || [repeater ? repeater.column : null];
    const repeatValues = isArray(repeat2) && repeat2 || [repeater ? repeater.repeat : null];
    for (const repeatValue of repeatValues) {
      for (const rowValue of row) {
        for (const columnValue of column) {
          const childRepeater = {
            repeat: repeatValue,
            row: rowValue,
            column: columnValue,
            layer: repeater.layer
          };
          const childName = (childSpec.name || "") + repeaterPrefix + "child__" + (isArray(repeat2) ? `${varName(repeatValue)}` : (repeat2.row ? `row_${varName(rowValue)}` : "") + (repeat2.column ? `column_${varName(columnValue)}` : ""));
          const child = this.map(childSpec, Object.assign(Object.assign({}, params2), { repeater: childRepeater, repeaterPrefix: childName }));
          child.name = childName;
          concat.push(omit(child, ["data"]));
        }
      }
    }
    const columns = isArray(repeat2) ? spec.columns : repeat2.column ? repeat2.column.length : 1;
    return Object.assign(Object.assign({ data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data3, align: "all" }, remainingProperties), {
      columns,
      concat
    });
  }
  mapFacet(spec, params2) {
    const { facet } = spec;
    if (isFacetMapping(facet) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn2(message_exports.columnsNotSupportByRowCol("facet"));
    }
    return super.mapFacet(spec, params2);
  }
  mapUnitWithParentEncodingOrProjection(spec, params2) {
    const { encoding, projection: projection3 } = spec;
    const { parentEncoding, parentProjection, config } = params2;
    const mergedProjection = mergeProjection({ parentProjection, projection: projection3 });
    const mergedEncoding = mergeEncoding({
      parentEncoding,
      encoding: replaceRepeaterInEncoding(encoding, params2.repeater)
    });
    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? { projection: mergedProjection } : {}), mergedEncoding ? { encoding: mergedEncoding } : {}), { config });
  }
  mapFacetedUnit(spec, normParams) {
    const _a = spec.encoding, { row, column, facet } = _a, encoding = __rest16(_a, ["row", "column", "facet"]);
    const { mark: mark2, width: width2, projection: projection3, height: height2, view, params: params2, encoding: _ } = spec, outerSpec = __rest16(spec, ["mark", "width", "projection", "height", "view", "params", "encoding"]);
    const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);
    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);
    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {
      // row / column has higher precedence than facet
      facet: facetMapping,
      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width2 ? { width: width2 } : {}), height2 ? { height: height2 } : {}), view ? { view } : {}), projection3 ? { projection: projection3 } : {}), { mark: mark2, encoding: newEncoding }), params2 ? { params: params2 } : {})
    }), normParams);
  }
  getFacetMappingAndLayout(facets, params2) {
    var _a;
    const { row, column, facet } = facets;
    if (row || column) {
      if (facet) {
        warn2(message_exports.facetChannelDropped([...row ? [ROW] : [], ...column ? [COLUMN] : []]));
      }
      const facetMapping = {};
      const layout = {};
      for (const channel of [ROW, COLUMN]) {
        const def2 = facets[channel];
        if (def2) {
          const { align: align2, center, spacing, columns } = def2, defWithoutLayout = __rest16(def2, ["align", "center", "spacing", "columns"]);
          facetMapping[channel] = defWithoutLayout;
          for (const prop of ["align", "center", "spacing"]) {
            if (def2[prop] !== void 0) {
              (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};
              layout[prop][channel] = def2[prop];
            }
          }
        }
      }
      return { facetMapping, layout };
    } else {
      const { align: align2, center, spacing, columns } = facet, facetMapping = __rest16(facet, ["align", "center", "spacing", "columns"]);
      return {
        facetMapping: replaceRepeaterInFacet(facetMapping, params2.repeater),
        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align2 ? { align: align2 } : {}), center ? { center } : {}), spacing ? { spacing } : {}), columns ? { columns } : {})
      };
    }
  }
  mapLayer(spec, _a) {
    var { parentEncoding, parentProjection } = _a, otherParams = __rest16(_a, ["parentEncoding", "parentProjection"]);
    const { encoding, projection: projection3 } = spec, rest = __rest16(spec, ["encoding", "projection"]);
    const params2 = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }), parentProjection: mergeProjection({ parentProjection, projection: projection3 }) });
    return super.mapLayer(rest, params2);
  }
};
function mergeEncoding({ parentEncoding, encoding = {}, layer }) {
  let merged = {};
  if (parentEncoding) {
    const channels = /* @__PURE__ */ new Set([...keys3(parentEncoding), ...keys3(encoding)]);
    for (const channel of channels) {
      const channelDef = encoding[channel];
      const parentChannelDef = parentEncoding[channel];
      if (isFieldOrDatumDef(channelDef)) {
        const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);
        merged[channel] = mergedChannelDef;
      } else if (hasConditionalFieldOrDatumDef(channelDef)) {
        merged[channel] = Object.assign(Object.assign({}, channelDef), { condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition) });
      } else if (channelDef || channelDef === null) {
        merged[channel] = channelDef;
      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {
        merged[channel] = parentChannelDef;
      }
    }
  } else {
    merged = encoding;
  }
  return !merged || isEmpty(merged) ? void 0 : merged;
}
function mergeProjection(opt) {
  const { parentProjection, projection: projection3 } = opt;
  if (parentProjection && projection3) {
    warn2(message_exports.projectionOverridden({ parentProjection, projection: projection3 }));
  }
  return projection3 !== null && projection3 !== void 0 ? projection3 : parentProjection;
}

// node_modules/vega-lite/build/src/transform.js
function isFilter(t2) {
  return "filter" in t2;
}
function isImputeSequence(t2) {
  return (t2 === null || t2 === void 0 ? void 0 : t2["stop"]) !== void 0;
}
function isLookup(t2) {
  return "lookup" in t2;
}
function isLookupData(from) {
  return "data" in from;
}
function isLookupSelection(from) {
  return "param" in from;
}
function isPivot(t2) {
  return "pivot" in t2;
}
function isDensity(t2) {
  return "density" in t2;
}
function isQuantile2(t2) {
  return "quantile" in t2;
}
function isRegression(t2) {
  return "regression" in t2;
}
function isLoess(t2) {
  return "loess" in t2;
}
function isSample(t2) {
  return "sample" in t2;
}
function isWindow(t2) {
  return "window" in t2;
}
function isJoinAggregate(t2) {
  return "joinaggregate" in t2;
}
function isFlatten(t2) {
  return "flatten" in t2;
}
function isCalculate(t2) {
  return "calculate" in t2;
}
function isBin(t2) {
  return "bin" in t2;
}
function isImpute(t2) {
  return "impute" in t2;
}
function isTimeUnit(t2) {
  return "timeUnit" in t2;
}
function isAggregate2(t2) {
  return "aggregate" in t2;
}
function isStack(t2) {
  return "stack" in t2;
}
function isFold(t2) {
  return "fold" in t2;
}
function normalizeTransform(transform4) {
  return transform4.map((t2) => {
    if (isFilter(t2)) {
      return {
        filter: normalizeLogicalComposition(t2.filter, normalizePredicate)
      };
    }
    return t2;
  });
}

// node_modules/vega-lite/build/src/normalize/selectioncompat.js
var __rest17 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var SelectionCompatibilityNormalizer = class extends SpecMapper {
  map(spec, normParams) {
    var _a, _b;
    (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};
    (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};
    spec = normalizeTransforms(spec, normParams);
    return super.map(spec, normParams);
  }
  mapLayerOrUnit(spec, normParams) {
    spec = normalizeTransforms(spec, normParams);
    if (spec.encoding) {
      const encoding = {};
      for (const [channel, enc] of entries(spec.encoding)) {
        encoding[channel] = normalizeChannelDef(enc, normParams);
      }
      spec = Object.assign(Object.assign({}, spec), { encoding });
    }
    return super.mapLayerOrUnit(spec, normParams);
  }
  mapUnit(spec, normParams) {
    const _a = spec, { selection } = _a, rest = __rest17(_a, ["selection"]);
    if (selection) {
      return Object.assign(Object.assign({}, rest), { params: entries(selection).map(([name4, selDef]) => {
        var _a2;
        const _b = selDef, { init: value3, bind: bind3, empty } = _b, select2 = __rest17(_b, ["init", "bind", "empty"]);
        if (select2.type === "single") {
          select2.type = "point";
          select2.toggle = false;
        } else if (select2.type === "multi") {
          select2.type = "point";
        }
        normParams.emptySelections[name4] = empty !== "none";
        for (const pred of vals((_a2 = normParams.selectionPredicates[name4]) !== null && _a2 !== void 0 ? _a2 : {})) {
          pred.empty = empty !== "none";
        }
        return { name: name4, value: value3, select: select2, bind: bind3 };
      }) });
    }
    return spec;
  }
};
function normalizeTransforms(spec, normParams) {
  const { transform: tx } = spec, rest = __rest17(spec, ["transform"]);
  if (tx) {
    const transform4 = tx.map((t2) => {
      if (isFilter(t2)) {
        return { filter: normalizePredicate2(t2, normParams) };
      } else if (isBin(t2) && isBinParams(t2.bin)) {
        return Object.assign(Object.assign({}, t2), { bin: normalizeBinExtent(t2.bin) });
      } else if (isLookup(t2)) {
        const _a = t2.from, { selection: param2 } = _a, from = __rest17(_a, ["selection"]);
        return param2 ? Object.assign(Object.assign({}, t2), { from: Object.assign({ param: param2 }, from) }) : t2;
      }
      return t2;
    });
    return Object.assign(Object.assign({}, rest), { transform: transform4 });
  }
  return spec;
}
function normalizeChannelDef(obj, normParams) {
  var _a, _b;
  const enc = duplicate(obj);
  if (isFieldDef(enc) && isBinParams(enc.bin)) {
    enc.bin = normalizeBinExtent(enc.bin);
  }
  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {
    const _c2 = enc.scale.domain, { selection: param2 } = _c2, domain4 = __rest17(_c2, ["selection"]);
    enc.scale.domain = Object.assign(Object.assign({}, domain4), param2 ? { param: param2 } : {});
  }
  if (isConditionalDef(enc)) {
    if (isArray(enc.condition)) {
      enc.condition = enc.condition.map((c) => {
        const { selection, param: param2, test: test2 } = c, cond = __rest17(c, ["selection", "param", "test"]);
        return param2 ? c : Object.assign(Object.assign({}, cond), { test: normalizePredicate2(c, normParams) });
      });
    } else {
      const _d2 = normalizeChannelDef(enc.condition, normParams), { selection, param: param2, test: test2 } = _d2, cond = __rest17(_d2, ["selection", "param", "test"]);
      enc.condition = param2 ? enc.condition : Object.assign(Object.assign({}, cond), { test: normalizePredicate2(enc.condition, normParams) });
    }
  }
  return enc;
}
function normalizeBinExtent(bin3) {
  const ext = bin3.extent;
  if (ext === null || ext === void 0 ? void 0 : ext.selection) {
    const { selection: param2 } = ext, rest = __rest17(ext, ["selection"]);
    return Object.assign(Object.assign({}, bin3), { extent: Object.assign(Object.assign({}, rest), { param: param2 }) });
  }
  return bin3;
}
function normalizePredicate2(op, normParams) {
  const normalizeSelectionComposition = (o) => {
    return normalizeLogicalComposition(o, (param2) => {
      var _a, _b;
      var _c2;
      const empty = (_a = normParams.emptySelections[param2]) !== null && _a !== void 0 ? _a : true;
      const pred = { param: param2, empty };
      (_b = (_c2 = normParams.selectionPredicates)[param2]) !== null && _b !== void 0 ? _b : _c2[param2] = [];
      normParams.selectionPredicates[param2].push(pred);
      return pred;
    });
  };
  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, (o) => o.selection ? normalizeSelectionComposition(o.selection) : o);
}

// node_modules/vega-lite/build/src/normalize/toplevelselection.js
var TopLevelSelectionsNormalizer = class extends SpecMapper {
  map(spec, normParams) {
    var _a;
    const selections = (_a = normParams.selections) !== null && _a !== void 0 ? _a : [];
    if (spec.params && !isUnitSpec(spec)) {
      const params2 = [];
      for (const param2 of spec.params) {
        if (isSelectionParameter(param2)) {
          selections.push(param2);
        } else {
          params2.push(param2);
        }
      }
      spec.params = params2;
    }
    normParams.selections = selections;
    return super.map(spec, addSpecNameToParams(spec, normParams));
  }
  mapUnit(spec, normParams) {
    var _a;
    const selections = normParams.selections;
    if (!selections || !selections.length)
      return spec;
    const path3 = ((_a = normParams.path) !== null && _a !== void 0 ? _a : []).concat(spec.name);
    const params2 = [];
    for (const selection of selections) {
      if (!selection.views || !selection.views.length) {
        params2.push(selection);
      } else {
        for (const view of selection.views) {
          if (isString(view) && (view === spec.name || path3.indexOf(view) >= 0) || isArray(view) && view.map((v) => path3.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {
            params2.push(selection);
          }
        }
      }
    }
    if (params2.length)
      spec.params = params2;
    return spec;
  }
};
for (const method2 of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const proto = TopLevelSelectionsNormalizer.prototype[method2];
  TopLevelSelectionsNormalizer.prototype[method2] = function(spec, params2) {
    return proto.call(this, spec, addSpecNameToParams(spec, params2));
  };
}
function addSpecNameToParams(spec, params2) {
  var _a;
  return spec.name ? Object.assign(Object.assign({}, params2), { path: ((_a = params2.path) !== null && _a !== void 0 ? _a : []).concat(spec.name) }) : params2;
}

// node_modules/vega-lite/build/src/normalize/index.js
function normalize(spec, config) {
  if (config === void 0) {
    config = initConfig(spec.config);
  }
  const normalizedSpec = normalizeGenericSpec(spec, config);
  const { width: width2, height: height2 } = spec;
  const autosize = normalizeAutoSize(normalizedSpec, { width: width2, height: height2, autosize: spec.autosize }, config);
  return Object.assign(Object.assign({}, normalizedSpec), autosize ? { autosize } : {});
}
var coreNormalizer = new CoreNormalizer();
var selectionCompatNormalizer = new SelectionCompatibilityNormalizer();
var topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();
function normalizeGenericSpec(spec, config = {}) {
  const normParams = { config };
  return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);
}
function _normalizeAutoSize(autosize) {
  return isString(autosize) ? { type: autosize } : autosize !== null && autosize !== void 0 ? autosize : {};
}
function normalizeAutoSize(spec, sizeInfo, config) {
  let { width: width2, height: height2 } = sizeInfo;
  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
  const autosizeDefault = {};
  if (!isFitCompatible) {
    if (width2 == "container") {
      warn2(message_exports.containerSizeNonSingle("width"));
      width2 = void 0;
    }
    if (height2 == "container") {
      warn2(message_exports.containerSizeNonSingle("height"));
      height2 = void 0;
    }
  } else {
    if (width2 == "container" && height2 == "container") {
      autosizeDefault.type = "fit";
      autosizeDefault.contains = "padding";
    } else if (width2 == "container") {
      autosizeDefault.type = "fit-x";
      autosizeDefault.contains = "padding";
    } else if (height2 == "container") {
      autosizeDefault.type = "fit-y";
      autosizeDefault.contains = "padding";
    }
  }
  const autosize = Object.assign(Object.assign(Object.assign({ type: "pad" }, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));
  if (autosize.type === "fit" && !isFitCompatible) {
    warn2(message_exports.FIT_NON_SINGLE);
    autosize.type = "pad";
  }
  if (width2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
    warn2(message_exports.containerSizeNotCompatibleWithAutosize("width"));
  }
  if (height2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
    warn2(message_exports.containerSizeNotCompatibleWithAutosize("height"));
  }
  if (deepEqual(autosize, { type: "pad" })) {
    return void 0;
  }
  return autosize;
}

// node_modules/vega-lite/build/src/spec/toplevel.js
function isFitType(autoSizeType) {
  return autoSizeType === "fit" || autoSizeType === "fit-x" || autoSizeType === "fit-y";
}
function getFitType(sizeType) {
  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
}
var TOP_LEVEL_PROPERTIES = [
  "background",
  "padding"
  // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
];
function extractTopLevelProperties(t2, includeParams) {
  const o = {};
  for (const p of TOP_LEVEL_PROPERTIES) {
    if (t2 && t2[p] !== void 0) {
      o[p] = signalRefOrValue(t2[p]);
    }
  }
  if (includeParams) {
    o.params = t2.params;
  }
  return o;
}

// node_modules/vega-lite/build/src/compile/split.js
var Split = class _Split {
  constructor(explicit = {}, implicit2 = {}) {
    this.explicit = explicit;
    this.implicit = implicit2;
  }
  clone() {
    return new _Split(duplicate(this.explicit), duplicate(this.implicit));
  }
  combine() {
    return Object.assign(Object.assign({}, this.explicit), this.implicit);
  }
  get(key2) {
    return getFirstDefined(this.explicit[key2], this.implicit[key2]);
  }
  getWithExplicit(key2) {
    if (this.explicit[key2] !== void 0) {
      return { explicit: true, value: this.explicit[key2] };
    } else if (this.implicit[key2] !== void 0) {
      return { explicit: false, value: this.implicit[key2] };
    }
    return { explicit: false, value: void 0 };
  }
  setWithExplicit(key2, { value: value3, explicit }) {
    if (value3 !== void 0) {
      this.set(key2, value3, explicit);
    }
  }
  set(key2, value3, explicit) {
    delete this[explicit ? "implicit" : "explicit"][key2];
    this[explicit ? "explicit" : "implicit"][key2] = value3;
    return this;
  }
  copyKeyFromSplit(key2, { explicit, implicit: implicit2 }) {
    if (explicit[key2] !== void 0) {
      this.set(key2, explicit[key2], true);
    } else if (implicit2[key2] !== void 0) {
      this.set(key2, implicit2[key2], false);
    }
  }
  copyKeyFromObject(key2, s) {
    if (s[key2] !== void 0) {
      this.set(key2, s[key2], true);
    }
  }
  /**
   * Merge split object into this split object. Properties from the other split
   * overwrite properties from this split.
   */
  copyAll(other) {
    for (const key2 of keys3(other.combine())) {
      const val = other.getWithExplicit(key2);
      this.setWithExplicit(key2, val);
    }
  }
};
function makeExplicit(value3) {
  return {
    explicit: true,
    value: value3
  };
}
function makeImplicit(value3) {
  return {
    explicit: false,
    value: value3
  };
}
function tieBreakByComparing(compare5) {
  return (v1, v2, property2, propertyOf) => {
    const diff = compare5(v1.value, v2.value);
    if (diff > 0) {
      return v1;
    } else if (diff < 0) {
      return v2;
    }
    return defaultTieBreaker(v1, v2, property2, propertyOf);
  };
}
function defaultTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn2(message_exports.mergeConflictingProperty(property2, propertyOf, v1.value, v2.value));
  }
  return v1;
}
function mergeValuesWithExplicit(v1, v2, property2, propertyOf, tieBreaker = defaultTieBreaker) {
  if (v1 === void 0 || v1.value === void 0) {
    return v2;
  }
  if (v1.explicit && !v2.explicit) {
    return v1;
  } else if (v2.explicit && !v1.explicit) {
    return v2;
  } else if (deepEqual(v1.value, v2.value)) {
    return v1;
  } else {
    return tieBreaker(v1, v2, property2, propertyOf);
  }
}

// node_modules/vega-lite/build/src/compile/data/index.js
var AncestorParse = class extends Split {
  constructor(explicit = {}, implicit2 = {}, parseNothing = false) {
    super(explicit, implicit2);
    this.explicit = explicit;
    this.implicit = implicit2;
    this.parseNothing = parseNothing;
  }
  clone() {
    const clone = super.clone();
    clone.parseNothing = this.parseNothing;
    return clone;
  }
};

// node_modules/vega-lite/build/src/data.js
function isUrlData(data3) {
  return "url" in data3;
}
function isInlineData(data3) {
  return "values" in data3;
}
function isNamedData(data3) {
  return "name" in data3 && !isUrlData(data3) && !isInlineData(data3) && !isGenerator(data3);
}
function isGenerator(data3) {
  return data3 && (isSequenceGenerator(data3) || isSphereGenerator(data3) || isGraticuleGenerator(data3));
}
function isSequenceGenerator(data3) {
  return "sequence" in data3;
}
function isSphereGenerator(data3) {
  return "sphere" in data3;
}
function isGraticuleGenerator(data3) {
  return "graticule" in data3;
}
var DataSourceType;
(function(DataSourceType2) {
  DataSourceType2[DataSourceType2["Raw"] = 0] = "Raw";
  DataSourceType2[DataSourceType2["Main"] = 1] = "Main";
  DataSourceType2[DataSourceType2["Row"] = 2] = "Row";
  DataSourceType2[DataSourceType2["Column"] = 3] = "Column";
  DataSourceType2[DataSourceType2["Lookup"] = 4] = "Lookup";
})(DataSourceType || (DataSourceType = {}));

// node_modules/vega-lite/build/src/compile/selection/assemble.js
var __rest18 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleInit(init2, isExpr2 = true, wrap3 = identity2) {
  if (isArray(init2)) {
    const assembled = init2.map((v) => assembleInit(v, isExpr2, wrap3));
    return isExpr2 ? `[${assembled.join(", ")}]` : assembled;
  } else if (isDateTime(init2)) {
    if (isExpr2) {
      return wrap3(dateTimeToExpr(init2));
    } else {
      return wrap3(dateTimeToTimestamp(init2));
    }
  }
  return isExpr2 ? wrap3(stringify(init2)) : init2;
}
function assembleUnitSelectionSignals(model, signals) {
  var _a;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const name4 = selCmpt.name;
    let modifyExpr = `${name4}${TUPLE}, ${selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`}`;
    for (const c of selectionCompilers) {
      if (!c.defined(selCmpt))
        continue;
      if (c.signals)
        signals = c.signals(model, selCmpt, signals);
      if (c.modifyExpr)
        modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);
    }
    signals.push({
      name: name4 + MODIFY,
      on: [
        {
          events: { signal: selCmpt.name + TUPLE },
          update: `modify(${$(selCmpt.name + STORE)}, ${modifyExpr})`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleFacetSignals(model, signals) {
  if (model.component.selection && keys3(model.component.selection).length) {
    const name4 = $(model.getName("cell"));
    signals.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: eventSelector("mousemove", "scope"),
          update: `isTuple(facet) ? facet : group(${name4}).datum`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleTopLevelSignals(model, signals) {
  var _a;
  let hasSelections = false;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const name4 = selCmpt.name;
    const store = $(name4 + STORE);
    const hasSg = signals.filter((s) => s.name === name4);
    if (hasSg.length === 0) {
      const resolve2 = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
      const isPoint2 = selCmpt.type === "point" ? ", true, true)" : ")";
      signals.push({
        name: selCmpt.name,
        update: `${VL_SELECTION_RESOLVE}(${store}, ${$(resolve2)}${isPoint2}`
      });
    }
    hasSelections = true;
    for (const c of selectionCompilers) {
      if (c.defined(selCmpt) && c.topLevelSignals) {
        signals = c.topLevelSignals(model, selCmpt, signals);
      }
    }
  }
  if (hasSelections) {
    const hasUnit = signals.filter((s) => s.name === "unit");
    if (hasUnit.length === 0) {
      signals.unshift({
        name: "unit",
        value: {},
        on: [{ events: "mousemove", update: "isTuple(group()) ? group() : unit" }]
      });
    }
  }
  return cleanupEmptyOnArray(signals);
}
function assembleUnitSelectionData(model, data3) {
  var _a;
  const dataCopy = [...data3];
  const unit = unitName(model, { escape: false });
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const store = { name: selCmpt.name + STORE };
    if (selCmpt.project.hasSelectionId) {
      store.transform = [{ type: "collect", sort: { field: SELECTION_ID } }];
    }
    if (selCmpt.init) {
      const fields = selCmpt.project.items.map((proj) => {
        const { signals } = proj, rest = __rest18(proj, ["signals"]);
        return rest;
      });
      store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map((i) => ({ unit, [SELECTION_ID]: assembleInit(i, false)[0] })) : selCmpt.init.map((i) => ({ unit, fields, values: assembleInit(i, false) }));
    }
    const contains3 = dataCopy.filter((d) => d.name === selCmpt.name + STORE);
    if (!contains3.length) {
      dataCopy.push(store);
    }
  }
  return dataCopy;
}
function assembleUnitSelectionMarks(model, marks) {
  var _a;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    for (const c of selectionCompilers) {
      if (c.defined(selCmpt) && c.marks) {
        marks = c.marks(model, selCmpt, marks);
      }
    }
  }
  return marks;
}
function assembleLayerSelectionMarks(model, marks) {
  for (const child of model.children) {
    if (isUnitModel(child)) {
      marks = assembleUnitSelectionMarks(child, marks);
    }
  }
  return marks;
}
function assembleSelectionScaleDomain(model, extent2, scaleCmpt, domain4) {
  const parsedExtent = parseSelectionExtent(model, extent2.param, extent2);
  return {
    signal: hasContinuousDomain(scaleCmpt.get("type")) && isArray(domain4) && domain4[0] > domain4[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent
  };
}
function cleanupEmptyOnArray(signals) {
  return signals.map((s) => {
    if (s.on && !s.on.length)
      delete s.on;
    return s;
  });
}

// node_modules/vega-lite/build/src/compile/data/dataflow.js
var DataFlowNode = class {
  constructor(parent, debugName) {
    this.debugName = debugName;
    this._children = [];
    this._parent = null;
    if (parent) {
      this.parent = parent;
    }
  }
  /**
   * Clone this node with a deep copy but don't clone links to children or parents.
   */
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the node and also add this node to the parent's children.
   */
  set parent(parent) {
    this._parent = parent;
    if (parent) {
      parent.addChild(this);
    }
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(child, loc) {
    if (this._children.includes(child)) {
      warn2(message_exports.ADD_SAME_CHILD_TWICE);
      return;
    }
    if (loc !== void 0) {
      this._children.splice(loc, 0, child);
    } else {
      this._children.push(child);
    }
  }
  removeChild(oldChild) {
    const loc = this._children.indexOf(oldChild);
    this._children.splice(loc, 1);
    return loc;
  }
  /**
   * Remove node from the dataflow.
   */
  remove() {
    let loc = this._parent.removeChild(this);
    for (const child of this._children) {
      child._parent = this._parent;
      this._parent.addChild(child, loc++);
    }
  }
  /**
   * Insert another node as a parent of this node.
   */
  insertAsParentOf(other) {
    const parent = other.parent;
    parent.removeChild(this);
    this.parent = parent;
    other.parent = this;
  }
  swapWithParent() {
    const parent = this._parent;
    const newParent = parent.parent;
    for (const child of this._children) {
      child.parent = parent;
    }
    this._children = [];
    parent.removeChild(this);
    const loc = parent.parent.removeChild(parent);
    this._parent = newParent;
    newParent.addChild(this, loc);
    parent.parent = this;
  }
};
var OutputNode = class extends DataFlowNode {
  /**
   * @param source The name of the source. Will change in assemble.
   * @param type The type of the output node.
   * @param refCounts A global ref counter map.
   */
  constructor(parent, source4, type3, refCounts) {
    super(parent, source4);
    this.type = type3;
    this.refCounts = refCounts;
    this._source = this._name = source4;
    if (this.refCounts && !(this._name in this.refCounts)) {
      this.refCounts[this._name] = 0;
    }
  }
  clone() {
    const cloneObj = new this.constructor();
    cloneObj.debugName = `clone_${this.debugName}`;
    cloneObj._source = this._source;
    cloneObj._name = `clone_${this._name}`;
    cloneObj.type = this.type;
    cloneObj.refCounts = this.refCounts;
    cloneObj.refCounts[cloneObj._name] = 0;
    return cloneObj;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    if (this._hash === void 0) {
      this._hash = `Output ${uniqueId()}`;
    }
    return this._hash;
  }
  /**
   * Request the datasource name and increase the ref counter.
   *
   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
   * It is crucial to request the name from an output node to mark it as a required node.
   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
   *
   * In the assemble phase, this will return the correct name.
   */
  getSource() {
    this.refCounts[this._name]++;
    return this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(source4) {
    this._source = source4;
  }
};

// node_modules/vega-lite/build/src/compile/data/timeunit.js
var __rest19 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var TimeUnitNode = class _TimeUnitNode extends DataFlowNode {
  constructor(parent, formula) {
    super(parent);
    this.formula = formula;
  }
  clone() {
    return new _TimeUnitNode(null, duplicate(this.formula));
  }
  static makeFromEncoding(parent, model) {
    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {
      const { field: field3, timeUnit } = fieldDef;
      if (timeUnit) {
        const as = vgField(fieldDef, { forAs: true });
        timeUnitComponent[hash({
          as,
          field: field3,
          timeUnit
        })] = {
          as,
          field: field3,
          timeUnit
        };
      }
      return timeUnitComponent;
    }, {});
    if (isEmpty(formula)) {
      return null;
    }
    return new _TimeUnitNode(parent, formula);
  }
  static makeFromTransform(parent, t2) {
    const _a = Object.assign({}, t2), { timeUnit } = _a, other = __rest19(_a, ["timeUnit"]);
    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
    const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });
    return new _TimeUnitNode(parent, {
      [hash(component)]: component
    });
  }
  /**
   * Merge together TimeUnitNodes assigning the children of `other` to `this`
   * and removing `other`.
   */
  merge(other) {
    this.formula = Object.assign({}, this.formula);
    for (const key2 in other.formula) {
      if (!this.formula[key2]) {
        this.formula[key2] = other.formula[key2];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  /**
   * Remove time units coming from the other node.
   */
  removeFormulas(fields) {
    const newFormula = {};
    for (const [key2, timeUnit] of entries(this.formula)) {
      if (!fields.has(timeUnit.as)) {
        newFormula[key2] = timeUnit;
      }
    }
    this.formula = newFormula;
  }
  producedFields() {
    return new Set(vals(this.formula).map((f) => f.as));
  }
  dependentFields() {
    return new Set(vals(this.formula).map((f) => f.field));
  }
  hash() {
    return `TimeUnit ${hash(this.formula)}`;
  }
  assemble() {
    const transforms2 = [];
    for (const f of vals(this.formula)) {
      const { field: field3, as, timeUnit } = f;
      const _a = normalizeTimeUnit(timeUnit), { unit, utc } = _a, params2 = __rest19(_a, ["unit", "utc"]);
      transforms2.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field3), type: "timeunit" }, unit ? { units: getTimeUnitParts(unit) } : {}), utc ? { timezone: "utc" } : {}), params2), { as: [as, `${as}_end`] }));
    }
    return transforms2;
  }
};

// node_modules/vega-lite/build/src/compile/selection/project.js
var __rest20 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var TUPLE_FIELDS = "_tuple_fields";
var SelectionProjectionComponent = class {
  constructor(...items) {
    this.items = items;
    this.hasChannel = {};
    this.hasField = {};
    this.hasSelectionId = false;
  }
};
var project2 = {
  defined: () => {
    return true;
  },
  parse: (model, selCmpt, selDef) => {
    var _a;
    const name4 = selCmpt.name;
    const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();
    const parsed = {};
    const timeUnits2 = {};
    const signals = /* @__PURE__ */ new Set();
    const signalName = (p, range6) => {
      const suffix = range6 === "visual" ? p.channel : p.field;
      let sg = varName(`${name4}_${suffix}`);
      for (let counter = 1; signals.has(sg); counter++) {
        sg = varName(`${name4}_${suffix}_${counter}`);
      }
      signals.add(sg);
      return { [range6]: sg };
    };
    const type3 = selCmpt.type;
    const cfg = model.config.selection[type3];
    const init2 = selDef.value !== void 0 ? array(selDef.value) : null;
    let { fields, encodings } = isObject(selDef.select) ? selDef.select : {};
    if (!fields && !encodings && init2) {
      for (const initVal of init2) {
        if (!isObject(initVal)) {
          continue;
        }
        for (const key2 of keys3(initVal)) {
          if (isSingleDefUnitChannel(key2)) {
            (encodings || (encodings = [])).push(key2);
          } else {
            if (type3 === "interval") {
              warn2(message_exports.INTERVAL_INITIALIZED_WITH_X_Y);
              encodings = cfg.encodings;
            } else {
              (fields || (fields = [])).push(key2);
            }
          }
        }
      }
    }
    if (!fields && !encodings) {
      encodings = cfg.encodings;
      if ("fields" in cfg) {
        fields = cfg.fields;
      }
    }
    for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {
      const fieldDef = model.fieldDef(channel);
      if (fieldDef) {
        let field3 = fieldDef.field;
        if (fieldDef.aggregate) {
          warn2(message_exports.cannotProjectAggregate(channel, fieldDef.aggregate));
          continue;
        } else if (!field3) {
          warn2(message_exports.cannotProjectOnChannelWithoutField(channel));
          continue;
        }
        if (fieldDef.timeUnit) {
          field3 = model.vgField(channel);
          const component = {
            timeUnit: fieldDef.timeUnit,
            as: field3,
            field: fieldDef.field
          };
          timeUnits2[hash(component)] = component;
        }
        if (!parsed[field3]) {
          let tplType = "E";
          if (type3 === "interval") {
            const scaleType2 = model.getScaleComponent(channel).get("type");
            if (hasContinuousDomain(scaleType2)) {
              tplType = "R";
            }
          } else if (fieldDef.bin) {
            tplType = "R-RE";
          }
          const p = { field: field3, channel, type: tplType };
          p.signals = Object.assign(Object.assign({}, signalName(p, "data")), signalName(p, "visual"));
          proj.items.push(parsed[field3] = p);
          proj.hasField[field3] = proj.hasChannel[channel] = parsed[field3];
          proj.hasSelectionId = proj.hasSelectionId || field3 === SELECTION_ID;
        }
      } else {
        warn2(message_exports.cannotProjectOnChannelWithoutField(channel));
      }
    }
    for (const field3 of fields !== null && fields !== void 0 ? fields : []) {
      if (proj.hasField[field3])
        continue;
      const p = { type: "E", field: field3 };
      p.signals = Object.assign({}, signalName(p, "data"));
      proj.items.push(p);
      proj.hasField[field3] = p;
      proj.hasSelectionId = proj.hasSelectionId || field3 === SELECTION_ID;
    }
    if (init2) {
      selCmpt.init = init2.map((v) => {
        return proj.items.map((p) => isObject(v) ? v[p.channel] !== void 0 ? v[p.channel] : v[p.field] : v);
      });
    }
    if (!isEmpty(timeUnits2)) {
      proj.timeUnit = new TimeUnitNode(null, timeUnits2);
    }
  },
  signals: (model, selCmpt, allSignals) => {
    const name4 = selCmpt.name + TUPLE_FIELDS;
    const hasSignal2 = allSignals.filter((s) => s.name === name4);
    return hasSignal2.length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({
      name: name4,
      value: selCmpt.project.items.map((proj) => {
        const { signals, hasLegend } = proj, rest = __rest20(proj, ["signals", "hasLegend"]);
        rest.field = replacePathInField(rest.field);
        return rest;
      })
    });
  }
};
var project_default2 = project2;

// node_modules/vega-lite/build/src/compile/selection/scales.js
var scaleBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
  },
  parse: (model, selCmpt) => {
    const bound2 = selCmpt.scales = [];
    for (const proj of selCmpt.project.items) {
      const channel = proj.channel;
      if (!isScaleChannel(channel)) {
        continue;
      }
      const scale6 = model.getScaleComponent(channel);
      const scaleType2 = scale6 ? scale6.get("type") : void 0;
      if (!scale6 || !hasContinuousDomain(scaleType2)) {
        warn2(message_exports.SCALE_BINDINGS_CONTINUOUS);
        continue;
      }
      scale6.set("selectionExtent", { param: selCmpt.name, field: proj.field }, true);
      bound2.push(proj);
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const bound2 = selCmpt.scales.filter((proj) => signals.filter((s) => s.name === proj.signals.data).length === 0);
    if (!model.parent || isTopLevelLayer(model) || bound2.length === 0) {
      return signals;
    }
    const namedSg = signals.filter((s) => s.name === selCmpt.name)[0];
    let update3 = namedSg.update;
    if (update3.indexOf(VL_SELECTION_RESOLVE) >= 0) {
      namedSg.update = `{${bound2.map((proj) => `${$(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;
    } else {
      for (const proj of bound2) {
        const mapping = `${$(replacePathInField(proj.field))}: ${proj.signals.data}`;
        if (!update3.includes(mapping)) {
          update3 = `${update3.substring(0, update3.length - 1)}, ${mapping}}`;
        }
      }
      namedSg.update = update3;
    }
    return signals.concat(bound2.map((proj) => ({ name: proj.signals.data })));
  },
  signals: (model, selCmpt, signals) => {
    if (model.parent && !isTopLevelLayer(model)) {
      for (const proj of selCmpt.scales) {
        const signal = signals.filter((s) => s.name === proj.signals.data)[0];
        signal.push = "outer";
        delete signal.value;
        delete signal.update;
      }
    }
    return signals;
  }
};
var scales_default = scaleBindings;
function domain3(model, channel) {
  const scale6 = $(model.scaleName(channel));
  return `domain(${scale6})`;
}
function isTopLevelLayer(model) {
  var _a;
  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));
}

// node_modules/vega-lite/build/src/compile/selection/interval.js
var __rest21 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var BRUSH = "_brush";
var SCALE_TRIGGER = "_scale_trigger";
var interval = {
  defined: (selCmpt) => selCmpt.type === "interval",
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const fieldsSg = name4 + TUPLE_FIELDS;
    const hasScales = scales_default.defined(selCmpt);
    const init2 = selCmpt.init ? selCmpt.init[0] : null;
    const dataSignals = [];
    const scaleTriggers = [];
    if (selCmpt.translate && !hasScales) {
      const filterExpr = `!event.item || event.item.mark.name !== ${$(name4 + BRUSH)}`;
      events3(selCmpt, (on2, evt) => {
        var _a;
        var _b;
        const filters2 = array((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : _b.filter = []);
        if (!filters2.includes(filterExpr)) {
          filters2.push(filterExpr);
        }
        return on2;
      });
    }
    selCmpt.project.items.forEach((proj, i) => {
      const channel = proj.channel;
      if (channel !== X2 && channel !== Y2) {
        warn2("Interval selections only support x and y encoding channels.");
        return;
      }
      const val = init2 ? init2[i] : null;
      const cs = channelSignals(model, selCmpt, proj, val);
      const dname = proj.signals.data;
      const vname = proj.signals.visual;
      const scaleName = $(model.scaleName(channel));
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
      signals.push(...cs);
      dataSignals.push(dname);
      scaleTriggers.push({
        scaleName: model.scaleName(channel),
        expr: `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`
      });
    });
    if (!hasScales && scaleTriggers.length) {
      signals.push({
        name: name4 + SCALE_TRIGGER,
        value: {},
        on: [
          {
            events: scaleTriggers.map((t2) => ({ scale: t2.scaleName })),
            update: `${scaleTriggers.map((t2) => t2.expr).join(" && ")} ? ${name4 + SCALE_TRIGGER} : {}`
          }
        ]
      });
    }
    const update3 = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
    return signals.concat(Object.assign(Object.assign({ name: name4 + TUPLE }, init2 ? { init: `{${update3}: ${assembleInit(init2)}}` } : {}), dataSignals.length ? {
      on: [
        {
          events: [{ signal: dataSignals.join(" || ") }],
          update: `${dataSignals.join(" && ")} ? {${update3}: [${dataSignals}]} : null`
        }
      ]
    } : {}));
  },
  marks: (model, selCmpt, marks) => {
    const name4 = selCmpt.name;
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    const xvname = x2 === null || x2 === void 0 ? void 0 : x2.signals.visual;
    const yvname = y2 === null || y2 === void 0 ? void 0 : y2.signals.visual;
    const store = `data(${$(selCmpt.name + STORE)})`;
    if (scales_default.defined(selCmpt) || !x2 && !y2) {
      return marks;
    }
    const update3 = {
      x: x2 !== void 0 ? { signal: `${xvname}[0]` } : { value: 0 },
      y: y2 !== void 0 ? { signal: `${yvname}[0]` } : { value: 0 },
      x2: x2 !== void 0 ? { signal: `${xvname}[1]` } : { field: { group: "width" } },
      y2: y2 !== void 0 ? { signal: `${yvname}[1]` } : { field: { group: "height" } }
    };
    if (selCmpt.resolve === "global") {
      for (const key2 of keys3(update3)) {
        update3[key2] = [
          Object.assign({ test: `${store}.length && ${store}[0].unit === ${unitName(model)}` }, update3[key2]),
          { value: 0 }
        ];
      }
    }
    const _a = selCmpt.mark, { fill: fill2, fillOpacity, cursor: cursor3 } = _a, stroke2 = __rest21(_a, ["fill", "fillOpacity", "cursor"]);
    const vgStroke = keys3(stroke2).reduce((def2, k2) => {
      def2[k2] = [
        {
          test: [x2 !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y2 !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter((t2) => t2).join(" && "),
          value: stroke2[k2]
        },
        { value: null }
      ];
      return def2;
    }, {});
    return [
      {
        name: `${name4 + BRUSH}_bg`,
        type: "rect",
        clip: true,
        encode: {
          enter: {
            fill: { value: fill2 },
            fillOpacity: { value: fillOpacity }
          },
          update: update3
        }
      },
      ...marks,
      {
        name: name4 + BRUSH,
        type: "rect",
        clip: true,
        encode: {
          enter: Object.assign(Object.assign({}, cursor3 ? { cursor: { value: cursor3 } } : {}), { fill: { value: "transparent" } }),
          update: Object.assign(Object.assign({}, update3), vgStroke)
        }
      }
    ];
  }
};
var interval_default2 = interval;
function channelSignals(model, selCmpt, proj, init2) {
  const channel = proj.channel;
  const vname = proj.signals.visual;
  const dname = proj.signals.data;
  const hasScales = scales_default.defined(selCmpt);
  const scaleName = $(model.scaleName(channel));
  const scale6 = model.getScaleComponent(channel);
  const scaleType2 = scale6 ? scale6.get("type") : void 0;
  const scaled = (str) => `scale(${scaleName}, ${str})`;
  const size = model.getSizeSignalRef(channel === X2 ? "width" : "height").signal;
  const coord = `${channel}(unit)`;
  const on2 = events3(selCmpt, (def2, evt) => {
    return [
      ...def2,
      { events: evt.between[0], update: `[${coord}, ${coord}]` },
      { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` }
      // Brush End
    ];
  });
  on2.push({
    events: { signal: selCmpt.name + SCALE_TRIGGER },
    update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
  });
  return hasScales ? [{ name: dname, on: [] }] : [
    Object.assign(Object.assign({ name: vname }, init2 ? { init: assembleInit(init2, true, scaled) } : { value: [] }), { on: on2 }),
    Object.assign(Object.assign({ name: dname }, init2 ? { init: assembleInit(init2) } : {}), { on: [
      {
        events: { signal: vname },
        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
      }
    ] })
  ];
}
function events3(selCmpt, cb) {
  return selCmpt.events.reduce((on2, evt) => {
    if (!evt.between) {
      warn2(`${evt} is not an ordered event stream for interval selections.`);
      return on2;
    }
    return cb(on2, evt);
  }, []);
}

// node_modules/vega-lite/build/src/compile/selection/point.js
var point3 = {
  defined: (selCmpt) => selCmpt.type === "point",
  signals: (model, selCmpt, signals) => {
    var _a;
    const name4 = selCmpt.name;
    const fieldsSg = name4 + TUPLE_FIELDS;
    const project3 = selCmpt.project;
    const datum2 = "(item().isVoronoi ? datum.datum : datum)";
    const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((acc, cmpt) => {
      return cmpt.type === "interval" ? acc.concat(cmpt.name + BRUSH) : acc;
    }, []).map((b2) => `indexof(item().mark.name, '${b2}') < 0`).join(" && ");
    const test2 = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ""}`;
    let update3 = `unit: ${unitName(model)}, `;
    if (selCmpt.project.hasSelectionId) {
      update3 += `${SELECTION_ID}: ${datum2}[${$(SELECTION_ID)}]`;
    } else {
      const values5 = project3.items.map((p) => {
        const fieldDef = model.fieldDef(p.channel);
        return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? `[${datum2}[${$(model.vgField(p.channel, {}))}], ${datum2}[${$(model.vgField(p.channel, { binSuffix: "end" }))}]]` : `${datum2}[${$(p.field)}]`;
      }).join(", ");
      update3 += `fields: ${fieldsSg}, values: [${values5}]`;
    }
    const events4 = selCmpt.events;
    return signals.concat([
      {
        name: name4 + TUPLE,
        on: events4 ? [
          {
            events: events4,
            update: `${test2} ? {${update3}} : null`,
            force: true
          }
        ] : []
      }
    ]);
  }
};
var point_default = point3;

// node_modules/vega-lite/build/src/compile/mark/encode/conditional.js
function wrapCondition(model, channelDef, vgChannel, refFn) {
  const condition = isConditionalDef(channelDef) && channelDef.condition;
  const valueRef = refFn(channelDef);
  if (condition) {
    const conditions = array(condition);
    const vgConditions = conditions.map((c) => {
      const conditionValueRef = refFn(c);
      if (isConditionalParameter(c)) {
        const { param: param2, empty } = c;
        const test2 = parseSelectionPredicate(model, { param: param2, empty });
        return Object.assign({ test: test2 }, conditionValueRef);
      } else {
        const test2 = expression3(model, c.test);
        return Object.assign({ test: test2 }, conditionValueRef);
      }
    });
    return {
      [vgChannel]: [...vgConditions, ...valueRef !== void 0 ? [valueRef] : []]
    };
  } else {
    return valueRef !== void 0 ? { [vgChannel]: valueRef } : {};
  }
}

// node_modules/vega-lite/build/src/compile/mark/encode/text.js
function text2(model, channel = "text") {
  const channelDef = model.encoding[channel];
  return wrapCondition(model, channelDef, channel, (cDef) => textRef(cDef, model.config));
}
function textRef(channelDef, config, expr2 = "datum") {
  if (channelDef) {
    if (isValueDef(channelDef)) {
      return signalOrValueRef(channelDef.value);
    }
    if (isFieldOrDatumDef(channelDef)) {
      const { format: format5, formatType } = getFormatMixins(channelDef);
      return formatSignalRef({ fieldOrDatumDef: channelDef, format: format5, formatType, expr: expr2, config });
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/tooltip.js
function tooltip(model, opt = {}) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.tooltip;
  if (isArray(channelDef)) {
    return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack2, config, opt) };
  } else {
    const datum2 = opt.reactiveGeom ? "datum.datum" : "datum";
    return wrapCondition(model, channelDef, "tooltip", (cDef) => {
      const tooltipRefFromChannelDef = textRef(cDef, config, datum2);
      if (tooltipRefFromChannelDef) {
        return tooltipRefFromChannelDef;
      }
      if (cDef === null) {
        return void 0;
      }
      let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
      if (markTooltip === true) {
        markTooltip = { content: "encoding" };
      }
      if (isString(markTooltip)) {
        return { value: markTooltip };
      } else if (isObject(markTooltip)) {
        if (isSignalRef(markTooltip)) {
          return markTooltip;
        } else if (markTooltip.content === "encoding") {
          return tooltipRefForEncoding(encoding, stack2, config, opt);
        } else {
          return { signal: datum2 };
        }
      }
      return void 0;
    });
  }
}
function tooltipData(encoding, stack2, config, { reactiveGeom } = {}) {
  const toSkip = {};
  const expr2 = reactiveGeom ? "datum.datum" : "datum";
  const tuples = [];
  function add5(fDef, channel) {
    const mainChannel = getMainRangeChannel(channel);
    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {
      type: encoding[mainChannel].type
      // for secondary field def, copy type from main channel
    });
    const title2 = fieldDef.title || defaultTitle(fieldDef, config);
    const key2 = array(title2).join(", ");
    let value3;
    if (isXorY(channel)) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef2 = getFieldDef(encoding[channel2]);
      if (isBinned(fieldDef.bin) && fieldDef2) {
        const startField = vgField(fieldDef, { expr: expr2 });
        const endField = vgField(fieldDef2, { expr: expr2 });
        const { format: format5, formatType } = getFormatMixins(fieldDef);
        value3 = binFormatExpression(startField, endField, format5, formatType, config);
        toSkip[channel2] = true;
      }
    }
    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack2 && stack2.fieldChannel === channel && stack2.offset === "normalize") {
      const { format: format5, formatType } = getFormatMixins(fieldDef);
      value3 = formatSignalRef({
        fieldOrDatumDef: fieldDef,
        format: format5,
        formatType,
        expr: expr2,
        config,
        normalizeStack: true
      }).signal;
    }
    value3 !== null && value3 !== void 0 ? value3 : value3 = textRef(fieldDef, config, expr2).signal;
    tuples.push({ channel, key: key2, value: value3 });
  }
  forEach(encoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      add5(channelDef, channel);
    } else if (hasConditionalFieldDef(channelDef)) {
      add5(channelDef.condition, channel);
    }
  });
  const out = {};
  for (const { channel, key: key2, value: value3 } of tuples) {
    if (!toSkip[channel] && !out[key2]) {
      out[key2] = value3;
    }
  }
  return out;
}
function tooltipRefForEncoding(encoding, stack2, config, { reactiveGeom } = {}) {
  const data3 = tooltipData(encoding, stack2, config, { reactiveGeom });
  const keyValues = entries(data3).map(([key2, value3]) => `"${key2}": ${value3}`);
  return keyValues.length > 0 ? { signal: `{${keyValues.join(", ")}}` } : void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/aria.js
function aria(model) {
  const { markDef, config } = model;
  const enableAria = getMarkPropOrConfig("aria", markDef, config);
  if (enableAria === false) {
    return {};
  }
  return Object.assign(Object.assign(Object.assign({}, enableAria ? { aria: enableAria } : {}), ariaRoleDescription(model)), description(model));
}
function ariaRoleDescription(model) {
  const { mark: mark2, markDef, config } = model;
  if (config.aria === false) {
    return {};
  }
  const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
  if (ariaRoleDesc != null) {
    return { ariaRoleDescription: { value: ariaRoleDesc } };
  }
  return mark2 in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark2 } };
}
function description(model) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.description;
  if (channelDef) {
    return wrapCondition(model, channelDef, "description", (cDef) => textRef(cDef, model.config));
  }
  const descriptionValue = getMarkPropOrConfig("description", markDef, config);
  if (descriptionValue != null) {
    return {
      description: signalOrValueRef(descriptionValue)
    };
  }
  if (config.aria === false) {
    return {};
  }
  const data3 = tooltipData(encoding, stack2, config);
  if (isEmpty(data3)) {
    return void 0;
  }
  return {
    description: {
      signal: entries(data3).map(([key2, value3], index3) => `"${index3 > 0 ? "; " : ""}${key2}: " + (${value3})`).join(" + ")
    }
  };
}

// node_modules/vega-lite/build/src/compile/mark/encode/nonposition.js
function nonPosition(channel, model, opt = {}) {
  const { markDef, encoding, config } = model;
  const { vgChannel } = opt;
  let { defaultRef, defaultValue } = opt;
  if (defaultRef === void 0) {
    defaultValue !== null && defaultValue !== void 0 ? defaultValue : defaultValue = getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true });
    if (defaultValue !== void 0) {
      defaultRef = signalOrValueRef(defaultValue);
    }
  }
  const channelDef = encoding[channel];
  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, (cDef) => {
    return midPoint({
      channel,
      channelDef: cDef,
      markDef,
      config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef
    });
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/color.js
function color3(model, opt = { filled: void 0 }) {
  var _a, _b, _c2, _d2;
  const { markDef, encoding, config } = model;
  const { type: markType2 } = markDef;
  const filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig("filled", markDef, config);
  const transparentIfNeeded = contains2(["bar", "point", "circle", "square", "geoshape"], markType2) ? "transparent" : void 0;
  const defaultFill = (_c2 = (_b = getMarkPropOrConfig(filled === true ? "color" : void 0, markDef, config, { vgChannel: "fill" })) !== null && _b !== void 0 ? _b : (
    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
    config.mark[filled === true && "color"]
  )) !== null && _c2 !== void 0 ? _c2 : (
    // If there is no fill, always fill symbols, bar, geoshape
    // with transparent fills https://github.com/vega/vega-lite/issues/1316
    transparentIfNeeded
  );
  const defaultStroke = (_d2 = getMarkPropOrConfig(filled === false ? "color" : void 0, markDef, config, { vgChannel: "stroke" })) !== null && _d2 !== void 0 ? _d2 : (
    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
    config.mark[filled === false && "color"]
  );
  const colorVgChannel = filled ? "fill" : "stroke";
  const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? { fill: signalOrValueRef(defaultFill) } : {}), defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {});
  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {
    warn2(message_exports.droppingColor("property", { fill: "fill" in markDef, stroke: "stroke" in markDef }));
  }
  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition("color", model, {
    vgChannel: colorVgChannel,
    defaultValue: filled ? defaultFill : defaultStroke
  })), nonPosition("fill", model, {
    // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
    defaultValue: encoding.fill ? defaultFill : void 0
  })), nonPosition("stroke", model, {
    // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
    defaultValue: encoding.stroke ? defaultStroke : void 0
  }));
}

// node_modules/vega-lite/build/src/compile/mark/encode/zindex.js
function zindex(model) {
  const { encoding, mark: mark2 } = model;
  const order = encoding.order;
  if (!isPathMark(mark2) && isValueDef(order)) {
    return wrapCondition(model, order, "zindex", (cd) => signalOrValueRef(cd.value));
  }
  return {};
}

// node_modules/vega-lite/build/src/compile/mark/encode/offset.js
function positionOffset({ channel: baseChannel, markDef, encoding = {}, model, bandPosition }) {
  const channel = `${baseChannel}Offset`;
  const defaultValue = markDef[channel];
  const channelDef = encoding[channel];
  if ((channel === "xOffset" || channel === "yOffset") && channelDef) {
    const ref2 = midPoint({
      channel,
      channelDef,
      markDef,
      config: model === null || model === void 0 ? void 0 : model.config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef: signalOrValueRef(defaultValue),
      bandPosition
    });
    return { offsetType: "encoding", offset: ref2 };
  }
  const markDefOffsetValue = markDef[channel];
  if (markDefOffsetValue) {
    return { offsetType: "visual", offset: markDefOffsetValue };
  }
  return {};
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-point.js
function pointPosition(channel, model, { defaultPos, vgChannel }) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding[channel];
  const channel2Def = encoding[getSecondaryRangeChannel(channel)];
  const scaleName = model.scaleName(channel);
  const scale6 = model.getScaleComponent(channel);
  const { offset: offset4, offsetType } = positionOffset({
    channel,
    markDef,
    encoding,
    model,
    bandPosition: 0.5
  });
  const defaultRef = pointPositionDefaultRef({
    model,
    defaultPos,
    channel,
    scaleName,
    scale: scale6
  });
  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? (
    // use geopoint output if there are lat/long and there is no point position overriding lat/long.
    { field: model.getName(channel) }
  ) : positionRef({
    channel,
    channelDef,
    channel2Def,
    markDef,
    config,
    scaleName,
    scale: scale6,
    stack: stack2,
    offset: offset4,
    defaultRef,
    bandPosition: offsetType === "encoding" ? 0 : void 0
  });
  return valueRef ? { [vgChannel || channel]: valueRef } : void 0;
}
function positionRef(params2) {
  const { channel, channelDef, scaleName, stack: stack2, offset: offset4, markDef } = params2;
  if (isFieldOrDatumDef(channelDef) && stack2 && channel === stack2.fieldChannel) {
    if (isFieldDef(channelDef)) {
      let bandPosition = channelDef.bandPosition;
      if (bandPosition === void 0 && markDef.type === "text" && (channel === "radius" || channel === "theta")) {
        bandPosition = 0.5;
      }
      if (bandPosition !== void 0) {
        return interpolatedSignalRef({
          scaleName,
          fieldOrDatumDef: channelDef,
          startSuffix: "start",
          bandPosition,
          offset: offset4
        });
      }
    }
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "end" }, { offset: offset4 });
  }
  return midPointRefWithPositionInvalidTest(params2);
}
function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale: scale6 }) {
  const { markDef, config } = model;
  return () => {
    const mainChannel = getMainRangeChannel(channel);
    const vgChannel = getVgPositionChannel(channel);
    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });
    if (definedValueOrConfig !== void 0) {
      return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
    }
    switch (defaultPos) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (scaleName) {
          const scaleType2 = scale6.get("type");
          if (contains2([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2)) {
          } else {
            if (scale6.domainDefinitelyIncludesZero()) {
              return {
                scale: scaleName,
                value: 0
              };
            }
          }
        }
        if (defaultPos === "zeroOrMin") {
          return mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
        } else {
          switch (mainChannel) {
            case "radius":
              return {
                signal: `min(${model.width.signal},${model.height.signal})/2`
              };
            case "theta":
              return { signal: "2*PI" };
            case "x":
              return { field: { group: "width" } };
            case "y":
              return { value: 0 };
          }
        }
        break;
      case "mid": {
        const sizeRef = model[getSizeChannel(channel)];
        return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });
      }
    }
    return void 0;
  };
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-align.js
var ALIGNED_X_CHANNEL = {
  left: "x",
  center: "xc",
  right: "x2"
};
var BASELINED_Y_CHANNEL = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
  if (channel === "radius" || channel === "theta") {
    return getVgPositionChannel(channel);
  }
  const alignChannel = channel === "x" ? "align" : "baseline";
  const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
  let alignExcludingSignal;
  if (isSignalRef(align2)) {
    warn2(message_exports.rangeMarkAlignmentCannotBeExpression(alignChannel));
    alignExcludingSignal = void 0;
  } else {
    alignExcludingSignal = align2;
  }
  if (channel === "x") {
    return ALIGNED_X_CHANNEL[alignExcludingSignal || (defaultAlign === "top" ? "left" : "center")];
  } else {
    return BASELINED_Y_CHANNEL[alignExcludingSignal || defaultAlign];
  }
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-range.js
function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range: range6 }) {
  if (range6) {
    return rangePosition(channel, model, { defaultPos, defaultPos2 });
  }
  return pointPosition(channel, model, { defaultPos });
}
function rangePosition(channel, model, { defaultPos, defaultPos2 }) {
  const { markDef, config } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
  const vgChannel = pos2Mixins[sizeChannel] ? (
    // If there is width/height, we need to position the marks based on the alignment.
    vgAlignedPositionChannel(channel, markDef, config)
  ) : (
    // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
    getVgPositionChannel(channel)
  );
  return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);
}
function pointPosition2OrSize(model, defaultPos, channel) {
  const { encoding, mark: mark2, markDef, stack: stack2, config } = model;
  const baseChannel = getMainRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const channelDef = encoding[baseChannel];
  const scaleName = model.scaleName(baseChannel);
  const scale6 = model.getScaleComponent(baseChannel);
  const { offset: offset4 } = channel in encoding || channel in markDef ? positionOffset({ channel, markDef, encoding, model }) : positionOffset({ channel: baseChannel, markDef, encoding, model });
  if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
    const vgSizeChannel = getSizeChannel(channel);
    const size = model.markDef[vgSizeChannel];
    if (size != null) {
      return {
        [vgSizeChannel]: { value: size }
      };
    } else {
      return {
        [vgChannel]: { field: model.getName(channel) }
      };
    }
  }
  const valueRef = position2Ref({
    channel,
    channelDef,
    channel2Def: encoding[channel],
    markDef,
    config,
    scaleName,
    scale: scale6,
    stack: stack2,
    offset: offset4,
    defaultRef: void 0
  });
  if (valueRef !== void 0) {
    return { [vgChannel]: valueRef };
  }
  return position2orSize(channel, markDef) || position2orSize(channel, {
    [channel]: getMarkStyleConfig(channel, markDef, config.style),
    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
  }) || position2orSize(channel, config[mark2]) || position2orSize(channel, config.mark) || {
    [vgChannel]: pointPositionDefaultRef({
      model,
      defaultPos,
      channel,
      scaleName,
      scale: scale6
    })()
  };
}
function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale6, stack: stack2, offset: offset4, defaultRef }) {
  if (isFieldOrDatumDef(channelDef) && stack2 && // If fieldChannel is X and channel is X2 (or Y and Y2)
  channel.charAt(0) === stack2.fieldChannel.charAt(0)) {
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "start" }, { offset: offset4 });
  }
  return midPointRefWithPositionInvalidTest({
    channel,
    channelDef: channel2Def,
    scaleName,
    scale: scale6,
    stack: stack2,
    markDef,
    config,
    offset: offset4,
    defaultRef
  });
}
function position2orSize(channel, markDef) {
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  if (markDef[vgChannel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };
  } else if (markDef[channel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel]) };
  } else if (markDef[sizeChannel]) {
    const dimensionSize = markDef[sizeChannel];
    if (isRelativeBandSize(dimensionSize)) {
      warn2(message_exports.relativeBandSizeNotSupported(sizeChannel));
    } else {
      return { [sizeChannel]: widthHeightValueOrSignalRef(channel, dimensionSize) };
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-rect.js
function rectPosition(model, channel) {
  var _a, _b;
  const { config, encoding, markDef } = model;
  const mark2 = markDef.type;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const channelDef = encoding[channel];
  const channelDef2 = encoding[channel2];
  const scale6 = model.getScaleComponent(channel);
  const scaleType2 = scale6 ? scale6.get("type") : void 0;
  const orient2 = markDef.orient;
  const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig("size", markDef, config, { vgChannel: sizeChannel });
  const isBarBand = mark2 === "bar" && (channel === "x" ? orient2 === "vertical" : orient2 === "horizontal");
  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType2)) {
    return rectBinPosition({
      fieldDef: channelDef,
      fieldDef2: channelDef2,
      channel,
      model
    });
  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarBand) && !channelDef2) {
    return positionAndSize(channelDef, channel, model);
  } else {
    return rangePosition(channel, model, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
  }
}
function defaultSizeRef(sizeChannel, scaleName, scale6, config, bandSize) {
  if (isRelativeBandSize(bandSize)) {
    if (scale6) {
      const scaleType2 = scale6.get("type");
      if (scaleType2 === "band") {
        let bandWidth = `bandwidth('${scaleName}')`;
        if (bandSize.band !== 1) {
          bandWidth = `${bandSize.band} * ${bandWidth}`;
        }
        return { signal: `max(0.25, ${bandWidth})` };
      } else if (bandSize.band !== 1) {
        warn2(message_exports.cannotUseRelativeBandSizeWithNonBandScale(scaleType2));
        bandSize = void 0;
      }
    } else {
      return {
        mult: bandSize.band,
        field: { group: sizeChannel }
      };
    }
  } else if (isSignalRef(bandSize)) {
    return bandSize;
  } else if (bandSize) {
    return { value: bandSize };
  }
  if (scale6) {
    const scaleRange = scale6.get("range");
    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {
      return { value: scaleRange.step - 2 };
    }
  }
  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);
  return { value: defaultStep - 2 };
}
function positionAndSize(fieldDef, channel, model) {
  const { markDef, encoding, config, stack: stack2 } = model;
  const orient2 = markDef.orient;
  const scaleName = model.scaleName(channel);
  const scale6 = model.getScaleComponent(channel);
  const vgSizeChannel = getSizeChannel(channel);
  const channel2 = getSecondaryRangeChannel(channel);
  const offsetScaleChannel = getOffsetChannel(channel);
  const offsetScaleName = model.scaleName(offsetScaleChannel);
  const useVlSizeChannel = orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x";
  let sizeMixins;
  if (encoding.size || markDef.size) {
    if (useVlSizeChannel) {
      sizeMixins = nonPosition("size", model, {
        vgChannel: vgSizeChannel,
        defaultRef: signalOrValueRef(markDef.size)
      });
    } else {
      warn2(message_exports.cannotApplySizeToNonOrientedMark(markDef.type));
    }
  }
  const hasSizeFromMarkOrEncoding = !!sizeMixins;
  const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scale6 === null || scale6 === void 0 ? void 0 : scale6.get("type"), useVlSizeChannel });
  sizeMixins = sizeMixins || {
    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, scale6, config, bandSize)
  };
  const defaultBandAlign = (scale6 === null || scale6 === void 0 ? void 0 : scale6.get("type")) === "band" && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? "top" : "middle";
  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);
  const center = vgChannel === "xc" || vgChannel === "yc";
  const { offset: offset4, offsetType } = positionOffset({ channel, markDef, encoding, model, bandPosition: center ? 0.5 : 0 });
  const posRef = midPointRefWithPositionInvalidTest({
    channel,
    channelDef: fieldDef,
    markDef,
    config,
    scaleName,
    scale: scale6,
    stack: stack2,
    offset: offset4,
    defaultRef: pointPositionDefaultRef({ model, defaultPos: "mid", channel, scaleName, scale: scale6 }),
    bandPosition: center ? offsetType === "encoding" ? 0 : 0.5 : isSignalRef(bandSize) ? { signal: `(1-${bandSize})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0
  });
  if (vgSizeChannel) {
    return Object.assign({ [vgChannel]: posRef }, sizeMixins);
  } else {
    const vgChannel2 = getVgPositionChannel(channel2);
    const sizeRef = sizeMixins[vgSizeChannel];
    const sizeOffset = offset4 ? Object.assign(Object.assign({}, sizeRef), { offset: offset4 }) : sizeRef;
    return {
      [vgChannel]: posRef,
      // posRef might be an array that wraps position invalid test
      [vgChannel2]: isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })] : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })
    };
  }
}
function getBinSpacing(channel, spacing, reverse3, translate4, offset4) {
  if (isPolarPositionChannel(channel)) {
    return 0;
  }
  const spacingOffset = channel === "x" || channel === "y2" ? -spacing / 2 : spacing / 2;
  if (isSignalRef(reverse3) || isSignalRef(offset4) || isSignalRef(translate4)) {
    const reverseExpr = signalOrStringValue(reverse3);
    const offsetExpr = signalOrStringValue(offset4);
    const translateExpr = signalOrStringValue(translate4);
    const t2 = translateExpr ? `${translateExpr} + ` : "";
    const r2 = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : "";
    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;
    return {
      signal: t2 + r2 + o
    };
  } else {
    offset4 = offset4 || 0;
    return translate4 + (reverse3 ? -offset4 - spacingOffset : +offset4 + spacingOffset);
  }
}
function rectBinPosition({ fieldDef, fieldDef2, channel, model }) {
  var _a, _b, _c2;
  const { config, markDef, encoding } = model;
  const scale6 = model.getScaleComponent(channel);
  const scaleName = model.scaleName(channel);
  const scaleType2 = scale6 ? scale6.get("type") : void 0;
  const reverse3 = scale6.get("reverse");
  const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scaleType2 });
  const axis = (_a = model.component.axes[channel]) === null || _a === void 0 ? void 0 : _a[0];
  const axisTranslate = (_b = axis === null || axis === void 0 ? void 0 : axis.get("translate")) !== null && _b !== void 0 ? _b : 0.5;
  const spacing = isXorY(channel) ? (_c2 = getMarkPropOrConfig("binSpacing", markDef, config)) !== null && _c2 !== void 0 ? _c2 : 0 : 0;
  const channel2 = getSecondaryRangeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const vgChannel2 = getVgPositionChannel(channel2);
  const { offset: offset4 } = positionOffset({ channel, markDef, encoding, model, bandPosition: 0 });
  const bandPosition = isSignalRef(bandSize) ? { signal: `(1-${bandSize.signal})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
    return {
      [vgChannel2]: rectBinRef({
        fieldDef,
        scaleName,
        bandPosition,
        offset: getBinSpacing(channel2, spacing, reverse3, axisTranslate, offset4)
      }),
      [vgChannel]: rectBinRef({
        fieldDef,
        scaleName,
        bandPosition: isSignalRef(bandPosition) ? { signal: `1-${bandPosition.signal}` } : 1 - bandPosition,
        offset: getBinSpacing(channel, spacing, reverse3, axisTranslate, offset4)
      })
    };
  } else if (isBinned(fieldDef.bin)) {
    const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse3, axisTranslate, offset4) });
    if (isFieldDef(fieldDef2)) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse3, axisTranslate, offset4) })
      };
    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: {
          signal: `scale("${scaleName}", ${vgField(fieldDef, { expr: "datum" })} + ${fieldDef.bin.step})`,
          offset: getBinSpacing(channel, spacing, reverse3, axisTranslate, offset4)
        }
      };
    }
  }
  warn2(message_exports.channelRequiredForBinned(channel2));
  return void 0;
}
function rectBinRef({ fieldDef, scaleName, bandPosition, offset: offset4 }) {
  return interpolatedSignalRef({
    scaleName,
    fieldOrDatumDef: fieldDef,
    bandPosition,
    offset: offset4
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/base.js
var ALWAYS_IGNORE = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function baseEncodeEntry(model, ignore) {
  const { fill: fill2 = void 0, stroke: stroke2 = void 0 } = ignore.color === "include" ? color3(model) : {};
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, "fill", fill2)), wrapAllFieldsInvalid(model, "stroke", stroke2)), nonPosition("opacity", model)), nonPosition("fillOpacity", model)), nonPosition("strokeOpacity", model)), nonPosition("strokeWidth", model)), nonPosition("strokeDash", model)), zindex(model)), tooltip(model)), text2(model, "href")), aria(model));
}
function wrapAllFieldsInvalid(model, channel, valueRef) {
  const { config, mark: mark2, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === "hide" && valueRef && !isPathMark(mark2)) {
    const test2 = allFieldsInvalidPredicate(model, { invalid: true, channels: SCALE_CHANNELS });
    if (test2) {
      return {
        [channel]: [
          // prepend the invalid case
          // TODO: support custom value
          { test: test2, value: null },
          ...array(valueRef)
        ]
      };
    }
  }
  return valueRef ? { [channel]: valueRef } : {};
}
function markDefProperties(mark2, ignore) {
  return VG_MARK_CONFIGS.reduce((m, prop) => {
    if (!ALWAYS_IGNORE.has(prop) && mark2[prop] !== void 0 && ignore[prop] !== "ignore") {
      m[prop] = signalOrValueRef(mark2[prop]);
    }
    return m;
  }, {});
}
function allFieldsInvalidPredicate(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field3 = model.vgField(channel, { expr: "datum" });
      if (field3 && hasContinuousDomain(scaleType2)) {
        aggregator[field3] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys3(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field3) => fieldInvalidPredicate(field3, invalid)).join(` ${op} `);
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/defined.js
function defined(model) {
  const { config, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid) {
    const signal = allFieldsInvalidPredicate2(model, { channels: POSITION_SCALE_CHANNELS });
    if (signal) {
      return { defined: { signal } };
    }
  }
  return {};
}
function allFieldsInvalidPredicate2(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    var _a;
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field3 = model.vgField(channel, { expr: "datum", binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? "mid" : void 0 });
      if (field3 && hasContinuousDomain(scaleType2)) {
        aggregator[field3] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys3(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field3) => fieldInvalidPredicate(field3, invalid)).join(` ${op} `);
  }
  return void 0;
}
function valueIfDefined(prop, value3) {
  if (value3 !== void 0) {
    return { [prop]: signalOrValueRef(value3) };
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/selection/nearest.js
var VORONOI = "voronoi";
var nearest = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.nearest;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.events) {
      for (const s of selCmpt.events) {
        s.markname = model.getName(VORONOI);
      }
    }
  },
  marks: (model, selCmpt, marks) => {
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    const markType2 = model.mark;
    if (isPathMark(markType2)) {
      warn2(message_exports.nearestNotSupportForContinuous(markType2));
      return marks;
    }
    const cellDef = {
      name: model.getName(VORONOI),
      type: "path",
      interactive: true,
      from: { data: model.getName("marks") },
      encode: {
        update: Object.assign({ fill: { value: "transparent" }, strokeWidth: { value: 0.35 }, stroke: { value: "transparent" }, isVoronoi: { value: true } }, tooltip(model, { reactiveGeom: true }))
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: x2 || !y2 ? "datum.datum.x || 0" : "0" },
          y: { expr: y2 || !x2 ? "datum.datum.y || 0" : "0" },
          size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
        }
      ]
    };
    let index3 = 0;
    let exists = false;
    marks.forEach((mark2, i) => {
      var _a;
      const name4 = (_a = mark2.name) !== null && _a !== void 0 ? _a : "";
      if (name4 === model.component.mark[0].name) {
        index3 = i;
      } else if (name4.indexOf(VORONOI) >= 0) {
        exists = true;
      }
    });
    if (!exists) {
      marks.splice(index3 + 1, 0, cellDef);
    }
    return marks;
  }
};
var nearest_default = nearest;

// node_modules/vega-lite/build/src/compile/selection/inputs.js
var inputBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
  },
  parse: (model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef),
  topLevelSignals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const proj = selCmpt.project;
    const bind3 = selCmpt.bind;
    const init2 = selCmpt.init && selCmpt.init[0];
    const datum2 = nearest_default.defined(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    proj.items.forEach((p, i) => {
      var _a, _b;
      const sgname = varName(`${name4}_${p.field}`);
      const hasSignal2 = signals.filter((s) => s.name === sgname);
      if (!hasSignal2.length) {
        signals.unshift(Object.assign(Object.assign({ name: sgname }, init2 ? { init: assembleInit(init2[i]) } : { value: null }), { on: selCmpt.events ? [
          {
            events: selCmpt.events,
            update: `datum && item().mark.marktype !== 'group' ? ${datum2}[${$(p.field)}] : null`
          }
        ] : [], bind: (_b = (_a = bind3[p.field]) !== null && _a !== void 0 ? _a : bind3[p.channel]) !== null && _b !== void 0 ? _b : bind3 }));
      }
    });
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const proj = selCmpt.project;
    const signal = signals.filter((s) => s.name === name4 + TUPLE)[0];
    const fields = name4 + TUPLE_FIELDS;
    const values5 = proj.items.map((p) => varName(`${name4}_${p.field}`));
    const valid = values5.map((v) => `${v} !== null`).join(" && ");
    if (values5.length) {
      signal.update = `${valid} ? {fields: ${fields}, values: [${values5.join(", ")}]} : null`;
    }
    delete signal.value;
    delete signal.on;
    return signals;
  }
};
var inputs_default = inputBindings;

// node_modules/vega-lite/build/src/compile/selection/toggle.js
var TOGGLE = "_toggle";
var toggle = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && !!selCmpt.toggle;
  },
  signals: (model, selCmpt, signals) => {
    return signals.concat({
      name: selCmpt.name + TOGGLE,
      value: false,
      on: [{ events: selCmpt.events, update: selCmpt.toggle }]
    });
  },
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    const signal = selCmpt.name + TOGGLE;
    return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
  }
};
var toggle_default = toggle;

// node_modules/vega-lite/build/src/compile/selection/clear.js
var clear = {
  defined: (selCmpt) => {
    return selCmpt.clear !== void 0 && selCmpt.clear !== false;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.clear) {
      selCmpt.clear = isString(selCmpt.clear) ? eventSelector(selCmpt.clear, "view") : selCmpt.clear;
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    if (inputs_default.defined(selCmpt)) {
      for (const proj of selCmpt.project.items) {
        const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
        if (idx !== -1) {
          signals[idx].on.push({ events: selCmpt.clear, update: "null" });
        }
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    function addClear(idx, update3) {
      if (idx !== -1 && signals[idx].on) {
        signals[idx].on.push({ events: selCmpt.clear, update: update3 });
      }
    }
    if (selCmpt.type === "interval") {
      for (const proj of selCmpt.project.items) {
        const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
        addClear(vIdx, "[0, 0]");
        if (vIdx === -1) {
          const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
          addClear(dIdx, "null");
        }
      }
    } else {
      let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
      addClear(tIdx, "null");
      if (toggle_default.defined(selCmpt)) {
        tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
        addClear(tIdx, "false");
      }
    }
    return signals;
  }
};
var clear_default = clear;

// node_modules/vega-lite/build/src/compile/selection/legends.js
var legendBindings = {
  defined: (selCmpt) => {
    const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
    const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;
    if (spec && !projLen) {
      warn2(message_exports.LEGEND_BINDINGS_MUST_HAVE_PROJECTION);
    }
    return spec && projLen;
  },
  parse: (model, selCmpt, selDef) => {
    var _a;
    const selDef_ = duplicate(selDef);
    selDef_.select = isString(selDef_.select) ? { type: selDef_.select, toggle: selCmpt.toggle } : Object.assign(Object.assign({}, selDef_.select), { toggle: selCmpt.toggle });
    disableDirectManipulation(selCmpt, selDef_);
    if (isObject(selDef.select) && (selDef.select.on || selDef.select.clear)) {
      const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const evt2 of selCmpt.events) {
        evt2.filter = array((_a = evt2.filter) !== null && _a !== void 0 ? _a : []);
        if (!evt2.filter.includes(legendFilter)) {
          evt2.filter.push(legendFilter);
        }
      }
    }
    const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
    const stream2 = isString(evt) ? eventSelector(evt, "view") : array(evt);
    selCmpt.bind = { legend: { merge: stream2 } };
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const selName = selCmpt.name;
    const stream2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    const markName = (name4) => (s) => {
      const ds = duplicate(s);
      ds.markname = name4;
      return ds;
    };
    for (const proj of selCmpt.project.items) {
      if (!proj.hasLegend)
        continue;
      const prefix = `${varName(proj.field)}_legend`;
      const sgName = `${selName}_${prefix}`;
      const hasSignal2 = signals.filter((s) => s.name === sgName);
      if (hasSignal2.length === 0) {
        const events4 = stream2.merge.map(markName(`${prefix}_symbols`)).concat(stream2.merge.map(markName(`${prefix}_labels`))).concat(stream2.merge.map(markName(`${prefix}_entries`)));
        signals.unshift(Object.assign(Object.assign({ name: sgName }, !selCmpt.init ? { value: null } : {}), { on: [
          // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
          { events: events4, update: "datum.value || item().items[0].items[0].datum.value", force: true },
          { events: stream2.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true }
        ] }));
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const proj = selCmpt.project;
    const tuple = signals.find((s) => s.name === name4 + TUPLE);
    const fields = name4 + TUPLE_FIELDS;
    const values5 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name4}_${varName(p.field)}_legend`));
    const valid = values5.map((v) => `${v} !== null`).join(" && ");
    const update3 = `${valid} ? {fields: ${fields}, values: [${values5.join(", ")}]} : null`;
    if (selCmpt.events && values5.length > 0) {
      tuple.on.push({
        events: values5.map((signal) => ({ signal })),
        update: update3
      });
    } else if (values5.length > 0) {
      tuple.update = update3;
      delete tuple.value;
      delete tuple.on;
    }
    const toggle2 = signals.find((s) => s.name === name4 + TOGGLE);
    const events4 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    if (toggle2) {
      if (!selCmpt.events)
        toggle2.on[0].events = events4;
      else
        toggle2.on.push(Object.assign(Object.assign({}, toggle2.on[0]), { events: events4 }));
    }
    return signals;
  }
};
var legends_default = legendBindings;
function parseInteractiveLegend(model, channel, legendCmpt) {
  var _a, _b, _c2, _d2;
  const field3 = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.field;
  for (const selCmpt of vals((_b = model.component.selection) !== null && _b !== void 0 ? _b : {})) {
    const proj = (_c2 = selCmpt.project.hasField[field3]) !== null && _c2 !== void 0 ? _c2 : selCmpt.project.hasChannel[channel];
    if (proj && legendBindings.defined(selCmpt)) {
      const legendSelections = (_d2 = legendCmpt.get("selections")) !== null && _d2 !== void 0 ? _d2 : [];
      legendSelections.push(selCmpt.name);
      legendCmpt.set("selections", legendSelections, false);
      proj.hasLegend = true;
    }
  }
}

// node_modules/vega-lite/build/src/compile/selection/translate.js
var ANCHOR = "_translate_anchor";
var DELTA = "_translate_delta";
var translate3 = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.translate;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const hasScales = scales_default.defined(selCmpt);
    const anchor = name4 + ANCHOR;
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    let events4 = eventSelector(selCmpt.translate, "scope");
    if (!hasScales) {
      events4 = events4.map((e2) => (e2.between[0].markname = name4 + BRUSH, e2));
    }
    signals.push({
      name: anchor,
      value: {},
      on: [
        {
          events: events4.map((e2) => e2.between[0]),
          update: "{x: x(unit), y: y(unit)" + (x2 !== void 0 ? `, extent_x: ${hasScales ? domain3(model, X2) : `slice(${x2.signals.visual})`}` : "") + (y2 !== void 0 ? `, extent_y: ${hasScales ? domain3(model, Y2) : `slice(${y2.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: name4 + DELTA,
      value: {},
      on: [
        {
          events: events4,
          update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`
        }
      ]
    });
    if (x2 !== void 0) {
      onDelta(model, selCmpt, x2, "width", signals);
    }
    if (y2 !== void 0) {
      onDelta(model, selCmpt, y2, "height", signals);
    }
    return signals;
  }
};
var translate_default = translate3;
function onDelta(model, selCmpt, proj, size, signals) {
  var _a, _b;
  const name4 = selCmpt.name;
  const anchor = name4 + ANCHOR;
  const delta = name4 + DELTA;
  const channel = proj.channel;
  const hasScales = scales_default.defined(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const reversed = scaleCmpt.get("reverse");
  const sign2 = !hasScales ? "" : channel === X2 ? reversed ? "" : "-" : reversed ? "-" : "";
  const extent2 = `${anchor}.extent_${channel}`;
  const offset4 = `${sign2}${delta}.${channel} / ${hasScales ? `${sizeSg}` : `span(${extent2})`}`;
  const panFn = !hasScales ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "symlog" ? "panSymlog" : scaleType2 === "pow" ? "panPow" : "panLinear";
  const arg = !hasScales ? "" : scaleType2 === "pow" ? `, ${(_a = scaleCmpt.get("exponent")) !== null && _a !== void 0 ? _a : 1}` : scaleType2 === "symlog" ? `, ${(_b = scaleCmpt.get("constant")) !== null && _b !== void 0 ? _b : 1}` : "";
  const update3 = `${panFn}(${extent2}, ${offset4}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}

// node_modules/vega-lite/build/src/compile/selection/zoom.js
var ANCHOR2 = "_zoom_anchor";
var DELTA2 = "_zoom_delta";
var zoom2 = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.zoom;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const hasScales = scales_default.defined(selCmpt);
    const delta = name4 + DELTA2;
    const { x: x2, y: y2 } = selCmpt.project.hasChannel;
    const sx = $(model.scaleName(X2));
    const sy = $(model.scaleName(Y2));
    let events4 = eventSelector(selCmpt.zoom, "scope");
    if (!hasScales) {
      events4 = events4.map((e2) => (e2.markname = name4 + BRUSH, e2));
    }
    signals.push({
      name: name4 + ANCHOR2,
      on: [
        {
          events: events4,
          update: !hasScales ? `{x: x(unit), y: y(unit)}` : "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr2) => !!expr2).join(", ") + "}"
        }
      ]
    }, {
      name: delta,
      on: [
        {
          events: events4,
          force: true,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    });
    if (x2 !== void 0) {
      onDelta2(model, selCmpt, x2, "width", signals);
    }
    if (y2 !== void 0) {
      onDelta2(model, selCmpt, y2, "height", signals);
    }
    return signals;
  }
};
var zoom_default = zoom2;
function onDelta2(model, selCmpt, proj, size, signals) {
  var _a, _b;
  const name4 = selCmpt.name;
  const channel = proj.channel;
  const hasScales = scales_default.defined(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const base = hasScales ? domain3(model, channel) : signal.name;
  const delta = name4 + DELTA2;
  const anchor = `${name4}${ANCHOR2}.${channel}`;
  const zoomFn = !hasScales ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "symlog" ? "zoomSymlog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
  const arg = !hasScales ? "" : scaleType2 === "pow" ? `, ${(_a = scaleCmpt.get("exponent")) !== null && _a !== void 0 ? _a : 1}` : scaleType2 === "symlog" ? `, ${(_b = scaleCmpt.get("constant")) !== null && _b !== void 0 ? _b : 1}` : "";
  const update3 = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}

// node_modules/vega-lite/build/src/compile/selection/index.js
var STORE = "_store";
var TUPLE = "_tuple";
var MODIFY = "_modify";
var VL_SELECTION_RESOLVE = "vlSelectionResolve";
var selectionCompilers = [
  point_default,
  interval_default2,
  project_default2,
  toggle_default,
  // Bindings may disable direct manipulation.
  inputs_default,
  scales_default,
  legends_default,
  clear_default,
  translate_default,
  zoom_default,
  nearest_default
];
function getFacetModel(model) {
  let parent = model.parent;
  while (parent) {
    if (isFacetModel(parent))
      break;
    parent = parent.parent;
  }
  return parent;
}
function unitName(model, { escape: escape2 } = { escape: true }) {
  let name4 = escape2 ? $(model.name) : model.name;
  const facetModel = getFacetModel(model);
  if (facetModel) {
    const { facet } = facetModel;
    for (const channel of FACET_CHANNELS) {
      if (facet[channel]) {
        name4 += ` + '__facet_${channel}_' + (facet[${$(facetModel.vgField(channel))}])`;
      }
    }
  }
  return name4;
}
function requiresSelectionId(model) {
  var _a;
  return vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((identifier, selCmpt) => {
    return identifier || selCmpt.project.hasSelectionId;
  }, false);
}
function disableDirectManipulation(selCmpt, selDef) {
  if (isString(selDef.select) || !selDef.select.on)
    delete selCmpt.events;
  if (isString(selDef.select) || !selDef.select.clear)
    delete selCmpt.clear;
  if (isString(selDef.select) || !selDef.select.toggle)
    delete selCmpt.toggle;
}

// node_modules/vega-lite/node_modules/vega-expression/build/vega-expression.module.js
var RawCode2 = "RawCode";
var Literal2 = "Literal";
var Property2 = "Property";
var Identifier3 = "Identifier";
var ArrayExpression2 = "ArrayExpression";
var BinaryExpression2 = "BinaryExpression";
var CallExpression2 = "CallExpression";
var ConditionalExpression2 = "ConditionalExpression";
var LogicalExpression2 = "LogicalExpression";
var MemberExpression2 = "MemberExpression";
var ObjectExpression2 = "ObjectExpression";
var UnaryExpression2 = "UnaryExpression";
function ASTNode2(type3) {
  this.type = type3;
}
ASTNode2.prototype.visit = function(visitor) {
  let c, i, n;
  if (visitor(this)) return 1;
  for (c = children3(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};
function children3(node) {
  switch (node.type) {
    case ArrayExpression2:
      return node.elements;
    case BinaryExpression2:
    case LogicalExpression2:
      return [node.left, node.right];
    case CallExpression2:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression2:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression2:
      return [node.object, node.property];
    case ObjectExpression2:
      return node.properties;
    case Property2:
      return [node.key, node.value];
    case UnaryExpression2:
      return [node.argument];
    case Identifier3:
    case Literal2:
    case RawCode2:
    default:
      return [];
  }
}
var TokenName2;
var source3;
var index2;
var length2;
var lookahead2;
var TokenBooleanLiteral2 = 1;
var TokenEOF2 = 2;
var TokenIdentifier2 = 3;
var TokenKeyword2 = 4;
var TokenNullLiteral2 = 5;
var TokenNumericLiteral2 = 6;
var TokenPunctuator2 = 7;
var TokenStringLiteral2 = 8;
var TokenRegularExpression2 = 9;
TokenName2 = {};
TokenName2[TokenBooleanLiteral2] = "Boolean";
TokenName2[TokenEOF2] = "<end>";
TokenName2[TokenIdentifier2] = "Identifier";
TokenName2[TokenKeyword2] = "Keyword";
TokenName2[TokenNullLiteral2] = "Null";
TokenName2[TokenNumericLiteral2] = "Numeric";
TokenName2[TokenPunctuator2] = "Punctuator";
TokenName2[TokenStringLiteral2] = "String";
TokenName2[TokenRegularExpression2] = "RegularExpression";
var SyntaxArrayExpression2 = "ArrayExpression";
var SyntaxBinaryExpression2 = "BinaryExpression";
var SyntaxCallExpression2 = "CallExpression";
var SyntaxConditionalExpression2 = "ConditionalExpression";
var SyntaxIdentifier2 = "Identifier";
var SyntaxLiteral2 = "Literal";
var SyntaxLogicalExpression2 = "LogicalExpression";
var SyntaxMemberExpression2 = "MemberExpression";
var SyntaxObjectExpression2 = "ObjectExpression";
var SyntaxProperty2 = "Property";
var SyntaxUnaryExpression2 = "UnaryExpression";
var MessageUnexpectedToken2 = "Unexpected token %0";
var MessageUnexpectedNumber2 = "Unexpected number";
var MessageUnexpectedString2 = "Unexpected string";
var MessageUnexpectedIdentifier2 = "Unexpected identifier";
var MessageUnexpectedReserved2 = "Unexpected reserved word";
var MessageUnexpectedEOS2 = "Unexpected end of input";
var MessageInvalidRegExp2 = "Invalid regular expression";
var MessageUnterminatedRegExp2 = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral2 = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty2 = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL3 = "ILLEGAL";
var DISABLED2 = "Disabled.";
var RegexNonAsciiIdentifierStart2 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart2 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert2(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit2(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit2(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit2(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace2(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator2(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart2(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierStart2.test(String.fromCharCode(ch2));
}
function isIdentifierPart2(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 >= 48 && ch2 <= 57 || // 0..9
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierPart2.test(String.fromCharCode(ch2));
}
var keywords2 = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment2() {
  while (index2 < length2) {
    const ch2 = source3.charCodeAt(index2);
    if (isWhiteSpace2(ch2) || isLineTerminator2(ch2)) {
      ++index2;
    } else {
      break;
    }
  }
}
function scanHexEscape2(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index2 < length2 && isHexDigit2(source3[index2])) {
      ch2 = source3[index2++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape2() {
  var ch2, code, cu1, cu2;
  ch2 = source3[index2];
  code = 0;
  if (ch2 === "}") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  while (index2 < length2) {
    ch2 = source3[index2++];
    if (!isHexDigit2(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier2() {
  var ch2, id2;
  ch2 = source3.charCodeAt(index2++);
  id2 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source3.charCodeAt(index2) !== 117) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
    ++index2;
    ch2 = scanHexEscape2("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart2(ch2.charCodeAt(0))) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
    id2 = ch2;
  }
  while (index2 < length2) {
    ch2 = source3.charCodeAt(index2);
    if (!isIdentifierPart2(ch2)) {
      break;
    }
    ++index2;
    id2 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id2 = id2.substr(0, id2.length - 1);
      if (source3.charCodeAt(index2) !== 117) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
      ++index2;
      ch2 = scanHexEscape2("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
      id2 += ch2;
    }
  }
  return id2;
}
function getIdentifier2() {
  var start, ch2;
  start = index2++;
  while (index2 < length2) {
    ch2 = source3.charCodeAt(index2);
    if (ch2 === 92) {
      index2 = start;
      return getEscapedIdentifier2();
    }
    if (isIdentifierPart2(ch2)) {
      ++index2;
    } else {
      break;
    }
  }
  return source3.slice(start, index2);
}
function scanIdentifier2() {
  var start, id2, type3;
  start = index2;
  id2 = source3.charCodeAt(index2) === 92 ? getEscapedIdentifier2() : getIdentifier2();
  if (id2.length === 1) {
    type3 = TokenIdentifier2;
  } else if (keywords2.hasOwnProperty(id2)) {
    type3 = TokenKeyword2;
  } else if (id2 === "null") {
    type3 = TokenNullLiteral2;
  } else if (id2 === "true" || id2 === "false") {
    type3 = TokenBooleanLiteral2;
  } else {
    type3 = TokenIdentifier2;
  }
  return {
    type: type3,
    value: id2,
    start,
    end: index2
  };
}
function scanPunctuator2() {
  var start = index2, code = source3.charCodeAt(index2), code2, ch1 = source3[index2], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index2;
      return {
        type: TokenPunctuator2,
        value: String.fromCharCode(code),
        start,
        end: index2
      };
    default:
      code2 = source3.charCodeAt(index2 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index2 += 2;
            return {
              type: TokenPunctuator2,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index2
            };
          case 33:
          case 61:
            index2 += 2;
            if (source3.charCodeAt(index2) === 61) {
              ++index2;
            }
            return {
              type: TokenPunctuator2,
              value: source3.slice(start, index2),
              start,
              end: index2
            };
        }
      }
  }
  ch4 = source3.substr(index2, 4);
  if (ch4 === ">>>=") {
    index2 += 4;
    return {
      type: TokenPunctuator2,
      value: ch4,
      start,
      end: index2
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index2 += 3;
    return {
      type: TokenPunctuator2,
      value: ch3,
      start,
      end: index2
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index2 += 2;
    return {
      type: TokenPunctuator2,
      value: ch2,
      start,
      end: index2
    };
  }
  if (ch2 === "//") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index2;
    return {
      type: TokenPunctuator2,
      value: ch1,
      start,
      end: index2
    };
  }
  throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
}
function scanHexLiteral2(start) {
  let number5 = "";
  while (index2 < length2) {
    if (!isHexDigit2(source3[index2])) {
      break;
    }
    number5 += source3[index2++];
  }
  if (number5.length === 0) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if (isIdentifierStart2(source3.charCodeAt(index2))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseInt("0x" + number5, 16),
    start,
    end: index2
  };
}
function scanOctalLiteral2(start) {
  let number5 = "0" + source3[index2++];
  while (index2 < length2) {
    if (!isOctalDigit2(source3[index2])) {
      break;
    }
    number5 += source3[index2++];
  }
  if (isIdentifierStart2(source3.charCodeAt(index2)) || isDecimalDigit2(source3.charCodeAt(index2))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseInt(number5, 8),
    octal: true,
    start,
    end: index2
  };
}
function scanNumericLiteral2() {
  var number5, start, ch2;
  ch2 = source3[index2];
  assert2(isDecimalDigit2(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index2;
  number5 = "";
  if (ch2 !== ".") {
    number5 = source3[index2++];
    ch2 = source3[index2];
    if (number5 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index2;
        return scanHexLiteral2(start);
      }
      if (isOctalDigit2(ch2)) {
        return scanOctalLiteral2(start);
      }
      if (ch2 && isDecimalDigit2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
    }
    while (isDecimalDigit2(source3.charCodeAt(index2))) {
      number5 += source3[index2++];
    }
    ch2 = source3[index2];
  }
  if (ch2 === ".") {
    number5 += source3[index2++];
    while (isDecimalDigit2(source3.charCodeAt(index2))) {
      number5 += source3[index2++];
    }
    ch2 = source3[index2];
  }
  if (ch2 === "e" || ch2 === "E") {
    number5 += source3[index2++];
    ch2 = source3[index2];
    if (ch2 === "+" || ch2 === "-") {
      number5 += source3[index2++];
    }
    if (isDecimalDigit2(source3.charCodeAt(index2))) {
      while (isDecimalDigit2(source3.charCodeAt(index2))) {
        number5 += source3[index2++];
      }
    } else {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
  }
  if (isIdentifierStart2(source3.charCodeAt(index2))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseFloat(number5),
    start,
    end: index2
  };
}
function scanStringLiteral2() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source3[index2];
  assert2(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index2;
  ++index2;
  while (index2 < length2) {
    ch2 = source3[index2++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source3[index2++];
      if (!ch2 || !isLineTerminator2(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source3[index2] === "{") {
              ++index2;
              str += scanUnicodeCodePointEscape2();
            } else {
              str += scanHexEscape2(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit2(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index2 < length2 && isOctalDigit2(source3[index2])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source3[index2++]);
                if ("0123".indexOf(ch2) >= 0 && index2 < length2 && isOctalDigit2(source3[index2])) {
                  code = code * 8 + "01234567".indexOf(source3[index2++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source3[index2] === "\n") {
          ++index2;
        }
      }
    } else if (isLineTerminator2(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenStringLiteral2,
    value: str,
    octal,
    start,
    end: index2
  };
}
function testRegExp2(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError2({}, MessageInvalidRegExp2);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e2) {
    throwError2({}, MessageInvalidRegExp2);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody2() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source3[index2];
  assert2(ch2 === "/", "Regular expression literal must start with a slash");
  str = source3[index2++];
  classMarker = false;
  terminated = false;
  while (index2 < length2) {
    ch2 = source3[index2++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source3[index2++];
      if (isLineTerminator2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnterminatedRegExp2);
      }
      str += ch2;
    } else if (isLineTerminator2(ch2.charCodeAt(0))) {
      throwError2({}, MessageUnterminatedRegExp2);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError2({}, MessageUnterminatedRegExp2);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags2() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index2 < length2) {
    ch2 = source3[index2];
    if (!isIdentifierPart2(ch2.charCodeAt(0))) {
      break;
    }
    ++index2;
    if (ch2 === "\\" && index2 < length2) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError2({}, MessageInvalidRegExp2, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp2() {
  var start, body, flags, value3;
  lookahead2 = null;
  skipComment2();
  start = index2;
  body = scanRegExpBody2();
  flags = scanRegExpFlags2();
  value3 = testRegExp2(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value3,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index2
  };
}
function isIdentifierName2(token) {
  return token.type === TokenIdentifier2 || token.type === TokenKeyword2 || token.type === TokenBooleanLiteral2 || token.type === TokenNullLiteral2;
}
function advance2() {
  skipComment2();
  if (index2 >= length2) {
    return {
      type: TokenEOF2,
      start: index2,
      end: index2
    };
  }
  const ch2 = source3.charCodeAt(index2);
  if (isIdentifierStart2(ch2)) {
    return scanIdentifier2();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator2();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral2();
  }
  if (ch2 === 46) {
    if (isDecimalDigit2(source3.charCodeAt(index2 + 1))) {
      return scanNumericLiteral2();
    }
    return scanPunctuator2();
  }
  if (isDecimalDigit2(ch2)) {
    return scanNumericLiteral2();
  }
  return scanPunctuator2();
}
function lex2() {
  const token = lookahead2;
  index2 = token.end;
  lookahead2 = advance2();
  index2 = token.end;
  return token;
}
function peek3() {
  const pos = index2;
  lookahead2 = advance2();
  index2 = pos;
}
function finishArrayExpression2(elements) {
  const node = new ASTNode2(SyntaxArrayExpression2);
  node.elements = elements;
  return node;
}
function finishBinaryExpression2(operator2, left, right) {
  const node = new ASTNode2(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression2 : SyntaxBinaryExpression2);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression2(callee, args) {
  const node = new ASTNode2(SyntaxCallExpression2);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression2(test2, consequent, alternate) {
  const node = new ASTNode2(SyntaxConditionalExpression2);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier2(name4) {
  const node = new ASTNode2(SyntaxIdentifier2);
  node.name = name4;
  return node;
}
function finishLiteral2(token) {
  const node = new ASTNode2(SyntaxLiteral2);
  node.value = token.value;
  node.raw = source3.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression2(accessor2, object2, property2) {
  const node = new ASTNode2(SyntaxMemberExpression2);
  node.computed = accessor2 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed) property2.member = true;
  return node;
}
function finishObjectExpression2(properties) {
  const node = new ASTNode2(SyntaxObjectExpression2);
  node.properties = properties;
  return node;
}
function finishProperty2(kind, key2, value3) {
  const node = new ASTNode2(SyntaxProperty2);
  node.key = key2;
  node.value = value3;
  node.kind = kind;
  return node;
}
function finishUnaryExpression2(operator2, argument) {
  const node = new ASTNode2(SyntaxUnaryExpression2);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError2(token, messageFormat) {
  var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index3) => {
    assert2(index3 < args.length, "Message reference must be in range");
    return args[index3];
  });
  error2 = new Error(msg);
  error2.index = index2;
  error2.description = msg;
  throw error2;
}
function throwUnexpected2(token) {
  if (token.type === TokenEOF2) {
    throwError2(token, MessageUnexpectedEOS2);
  }
  if (token.type === TokenNumericLiteral2) {
    throwError2(token, MessageUnexpectedNumber2);
  }
  if (token.type === TokenStringLiteral2) {
    throwError2(token, MessageUnexpectedString2);
  }
  if (token.type === TokenIdentifier2) {
    throwError2(token, MessageUnexpectedIdentifier2);
  }
  if (token.type === TokenKeyword2) {
    throwError2(token, MessageUnexpectedReserved2);
  }
  throwError2(token, MessageUnexpectedToken2, token.value);
}
function expect2(value3) {
  const token = lex2();
  if (token.type !== TokenPunctuator2 || token.value !== value3) {
    throwUnexpected2(token);
  }
}
function match2(value3) {
  return lookahead2.type === TokenPunctuator2 && lookahead2.value === value3;
}
function matchKeyword2(keyword) {
  return lookahead2.type === TokenKeyword2 && lookahead2.value === keyword;
}
function parseArrayInitialiser2() {
  const elements = [];
  index2 = lookahead2.start;
  expect2("[");
  while (!match2("]")) {
    if (match2(",")) {
      lex2();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression2());
      if (!match2("]")) {
        expect2(",");
      }
    }
  }
  lex2();
  return finishArrayExpression2(elements);
}
function parseObjectPropertyKey2() {
  index2 = lookahead2.start;
  const token = lex2();
  if (token.type === TokenStringLiteral2 || token.type === TokenNumericLiteral2) {
    if (token.octal) {
      throwError2(token, MessageStrictOctalLiteral2);
    }
    return finishLiteral2(token);
  }
  return finishIdentifier2(token.value);
}
function parseObjectProperty2() {
  var token, key2, id2, value3;
  index2 = lookahead2.start;
  token = lookahead2;
  if (token.type === TokenIdentifier2) {
    id2 = parseObjectPropertyKey2();
    expect2(":");
    value3 = parseConditionalExpression2();
    return finishProperty2("init", id2, value3);
  }
  if (token.type === TokenEOF2 || token.type === TokenPunctuator2) {
    throwUnexpected2(token);
  } else {
    key2 = parseObjectPropertyKey2();
    expect2(":");
    value3 = parseConditionalExpression2();
    return finishProperty2("init", key2, value3);
  }
}
function parseObjectInitialiser2() {
  var properties = [], property2, name4, key2, map2 = {}, toString2 = String;
  index2 = lookahead2.start;
  expect2("{");
  while (!match2("}")) {
    property2 = parseObjectProperty2();
    if (property2.key.type === SyntaxIdentifier2) {
      name4 = property2.key.name;
    } else {
      name4 = toString2(property2.key.value);
    }
    key2 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map2, key2)) {
      throwError2({}, MessageStrictDuplicateProperty2);
    } else {
      map2[key2] = true;
    }
    properties.push(property2);
    if (!match2("}")) {
      expect2(",");
    }
  }
  expect2("}");
  return finishObjectExpression2(properties);
}
function parseGroupExpression2() {
  expect2("(");
  const expr2 = parseExpression2();
  expect2(")");
  return expr2;
}
var legalKeywords2 = {
  "if": 1
};
function parsePrimaryExpression2() {
  var type3, token, expr2;
  if (match2("(")) {
    return parseGroupExpression2();
  }
  if (match2("[")) {
    return parseArrayInitialiser2();
  }
  if (match2("{")) {
    return parseObjectInitialiser2();
  }
  type3 = lookahead2.type;
  index2 = lookahead2.start;
  if (type3 === TokenIdentifier2 || legalKeywords2[lookahead2.value]) {
    expr2 = finishIdentifier2(lex2().value);
  } else if (type3 === TokenStringLiteral2 || type3 === TokenNumericLiteral2) {
    if (lookahead2.octal) {
      throwError2(lookahead2, MessageStrictOctalLiteral2);
    }
    expr2 = finishLiteral2(lex2());
  } else if (type3 === TokenKeyword2) {
    throw new Error(DISABLED2);
  } else if (type3 === TokenBooleanLiteral2) {
    token = lex2();
    token.value = token.value === "true";
    expr2 = finishLiteral2(token);
  } else if (type3 === TokenNullLiteral2) {
    token = lex2();
    token.value = null;
    expr2 = finishLiteral2(token);
  } else if (match2("/") || match2("/=")) {
    expr2 = finishLiteral2(scanRegExp2());
    peek3();
  } else {
    throwUnexpected2(lex2());
  }
  return expr2;
}
function parseArguments2() {
  const args = [];
  expect2("(");
  if (!match2(")")) {
    while (index2 < length2) {
      args.push(parseConditionalExpression2());
      if (match2(")")) {
        break;
      }
      expect2(",");
    }
  }
  expect2(")");
  return args;
}
function parseNonComputedProperty2() {
  index2 = lookahead2.start;
  const token = lex2();
  if (!isIdentifierName2(token)) {
    throwUnexpected2(token);
  }
  return finishIdentifier2(token.value);
}
function parseNonComputedMember2() {
  expect2(".");
  return parseNonComputedProperty2();
}
function parseComputedMember2() {
  expect2("[");
  const expr2 = parseExpression2();
  expect2("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall2() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression2();
  for (; ; ) {
    if (match2(".")) {
      property2 = parseNonComputedMember2();
      expr2 = finishMemberExpression2(".", expr2, property2);
    } else if (match2("(")) {
      args = parseArguments2();
      expr2 = finishCallExpression2(expr2, args);
    } else if (match2("[")) {
      property2 = parseComputedMember2();
      expr2 = finishMemberExpression2("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression2() {
  const expr2 = parseLeftHandSideExpressionAllowCall2();
  if (lookahead2.type === TokenPunctuator2) {
    if (match2("++") || match2("--")) {
      throw new Error(DISABLED2);
    }
  }
  return expr2;
}
function parseUnaryExpression2() {
  var token, expr2;
  if (lookahead2.type !== TokenPunctuator2 && lookahead2.type !== TokenKeyword2) {
    expr2 = parsePostfixExpression2();
  } else if (match2("++") || match2("--")) {
    throw new Error(DISABLED2);
  } else if (match2("+") || match2("-") || match2("~") || match2("!")) {
    token = lex2();
    expr2 = parseUnaryExpression2();
    expr2 = finishUnaryExpression2(token.value, expr2);
  } else if (matchKeyword2("delete") || matchKeyword2("void") || matchKeyword2("typeof")) {
    throw new Error(DISABLED2);
  } else {
    expr2 = parsePostfixExpression2();
  }
  return expr2;
}
function binaryPrecedence2(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator2 && token.type !== TokenKeyword2) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression2() {
  var marker, markers, expr2, token, prec, stack2, right, operator2, left, i;
  marker = lookahead2;
  left = parseUnaryExpression2();
  token = lookahead2;
  prec = binaryPrecedence2(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex2();
  markers = [marker, lookahead2];
  right = parseUnaryExpression2();
  stack2 = [left, token, right];
  while ((prec = binaryPrecedence2(lookahead2)) > 0) {
    while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
      right = stack2.pop();
      operator2 = stack2.pop().value;
      left = stack2.pop();
      markers.pop();
      expr2 = finishBinaryExpression2(operator2, left, right);
      stack2.push(expr2);
    }
    token = lex2();
    token.prec = prec;
    stack2.push(token);
    markers.push(lookahead2);
    expr2 = parseUnaryExpression2();
    stack2.push(expr2);
  }
  i = stack2.length - 1;
  expr2 = stack2[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression2(stack2[i - 1].value, stack2[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression2() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression2();
  if (match2("?")) {
    lex2();
    consequent = parseConditionalExpression2();
    expect2(":");
    alternate = parseConditionalExpression2();
    expr2 = finishConditionalExpression2(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression2() {
  const expr2 = parseConditionalExpression2();
  if (match2(",")) {
    throw new Error(DISABLED2);
  }
  return expr2;
}
function parser3(code) {
  source3 = code;
  index2 = 0;
  length2 = source3.length;
  lookahead2 = null;
  peek3();
  const expr2 = parseExpression2();
  if (lookahead2.type !== TokenEOF2) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}

// node_modules/vega-lite/build/src/compile/data/expressions.js
function getName(node) {
  const name4 = [];
  if (node.type === "Identifier") {
    return [node.name];
  }
  if (node.type === "Literal") {
    return [node.value];
  }
  if (node.type === "MemberExpression") {
    name4.push(...getName(node.object));
    name4.push(...getName(node.property));
  }
  return name4;
}
function startsWithDatum(node) {
  if (node.object.type === "MemberExpression") {
    return startsWithDatum(node.object);
  }
  return node.object.name === "datum";
}
function getDependentFields(expression4) {
  const ast = parser3(expression4);
  const dependents = /* @__PURE__ */ new Set();
  ast.visit((node) => {
    if (node.type === "MemberExpression" && startsWithDatum(node)) {
      dependents.add(getName(node).slice(1).join("."));
    }
  });
  return dependents;
}

// node_modules/vega-lite/build/src/compile/data/filter.js
var FilterNode = class _FilterNode extends DataFlowNode {
  constructor(parent, model, filter3) {
    super(parent);
    this.model = model;
    this.filter = filter3;
    this.expr = expression3(this.model, this.filter, this);
    this._dependentFields = getDependentFields(this.expr);
  }
  clone() {
    return new _FilterNode(null, this.model, duplicate(this.filter));
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
};

// node_modules/vega-lite/build/src/compile/selection/parse.js
function parseUnitSelection(model, selDefs) {
  var _a;
  const selCmpts = {};
  const selectionConfig = model.config.selection;
  if (!selDefs || !selDefs.length)
    return selCmpts;
  for (const def2 of selDefs) {
    const name4 = varName(def2.name);
    const selDef = def2.select;
    const type3 = isString(selDef) ? selDef : selDef.type;
    const defaults2 = isObject(selDef) ? duplicate(selDef) : { type: type3 };
    const cfg = selectionConfig[type3];
    for (const key2 in cfg) {
      if (key2 === "fields" || key2 === "encodings") {
        continue;
      }
      if (key2 === "mark") {
        defaults2[key2] = Object.assign(Object.assign({}, cfg[key2]), defaults2[key2]);
      }
      if (defaults2[key2] === void 0 || defaults2[key2] === true) {
        defaults2[key2] = (_a = cfg[key2]) !== null && _a !== void 0 ? _a : defaults2[key2];
      }
    }
    const selCmpt = selCmpts[name4] = Object.assign(Object.assign({}, defaults2), {
      name: name4,
      type: type3,
      init: def2.value,
      bind: def2.bind,
      events: isString(defaults2.on) ? eventSelector(defaults2.on, "scope") : array(duplicate(defaults2.on))
    });
    for (const c of selectionCompilers) {
      if (c.defined(selCmpt) && c.parse) {
        c.parse(model, selCmpt, def2);
      }
    }
  }
  return selCmpts;
}
function parseSelectionPredicate(model, pred, dfnode, datum2 = "datum") {
  const name4 = isString(pred) ? pred : pred.param;
  const vname = varName(name4);
  const store = $(vname + STORE);
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name4);
  } catch (e2) {
    return `!!${vname}`;
  }
  if (selCmpt.project.timeUnit) {
    const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;
    const tunode = selCmpt.project.timeUnit.clone();
    if (child.parent) {
      tunode.insertAsParentOf(child);
    } else {
      child.parent = tunode;
    }
  }
  const fn = selCmpt.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(";
  const resolve2 = selCmpt.resolve === "global" ? ")" : `, ${$(selCmpt.resolve)})`;
  const test2 = `${fn}${store}, ${datum2}${resolve2}`;
  const length3 = `length(data(${store}))`;
  return pred.empty === false ? `${length3} && ${test2}` : `!${length3} || ${test2}`;
}
function parseSelectionExtent(model, name4, extent2) {
  const vname = varName(name4);
  const encoding = extent2["encoding"];
  let field3 = extent2["field"];
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name4);
  } catch (e2) {
    return vname;
  }
  if (!encoding && !field3) {
    field3 = selCmpt.project.items[0].field;
    if (selCmpt.project.items.length > 1) {
      warn2(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$(field3)}.`);
    }
  } else if (encoding && !field3) {
    const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
    if (!encodings.length || encodings.length > 1) {
      field3 = selCmpt.project.items[0].field;
      warn2((!encodings.length ? "No " : "Multiple ") + `matching ${$(encoding)} encoding found for selection ${$(extent2.param)}. Using "field": ${$(field3)}.`);
    } else {
      field3 = encodings[0].field;
    }
  }
  return `${selCmpt.name}[${$(replacePathInField(field3))}]`;
}
function materializeSelections(model, main5) {
  var _a;
  for (const [selection, selCmpt] of entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const lookupName = model.getName(`lookup_${selection}`);
    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main5, model, { param: selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
  }
}

// node_modules/vega-lite/build/src/compile/predicate.js
function expression3(model, filterOp, node) {
  return logicalExpr(filterOp, (predicate) => {
    if (isString(predicate)) {
      return predicate;
    } else if (isSelectionPredicate(predicate)) {
      return parseSelectionPredicate(model, predicate, node);
    } else {
      return fieldFilterExpression(predicate);
    }
  });
}

// node_modules/vega-lite/build/src/compile/axis/assemble.js
var __rest22 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleTitle(title2, config) {
  if (!title2) {
    return void 0;
  }
  if (isArray(title2) && !isText(title2)) {
    return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
  }
  return title2;
}
function setAxisEncode(axis, part, vgProp, vgRef) {
  var _a, _b, _c2;
  var _d2, _e;
  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};
  (_b = (_d2 = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d2[part] = {};
  (_c2 = (_e = axis.encode[part]).update) !== null && _c2 !== void 0 ? _c2 : _e.update = {};
  axis.encode[part].update[vgProp] = vgRef;
}
function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {
  var _a, _b;
  const _c2 = axisCmpt.combine(), { disable, orient: orient2, scale: scale6, labelExpr, title: title2, zindex: zindex2 } = _c2, axis = __rest22(_c2, ["disable", "orient", "scale", "labelExpr", "title", "zindex"]);
  if (disable) {
    return void 0;
  }
  for (const prop in axis) {
    const propType = AXIS_PROPERTY_TYPE[prop];
    const propValue = axis[prop];
    if (propType && propType !== kind && propType !== "both") {
      delete axis[prop];
    } else if (isConditionalAxisValue(propValue)) {
      const { condition } = propValue, valueOrSignalRef = __rest22(propValue, ["condition"]);
      const conditions = array(condition);
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        const vgRef = [
          ...conditions.map((c) => {
            const { test: test2 } = c, valueOrSignalCRef = __rest22(c, ["test"]);
            return Object.assign({ test: expression3(null, test2) }, valueOrSignalCRef);
          }),
          valueOrSignalRef
        ];
        setAxisEncode(axis, part, vgProp, vgRef);
        delete axis[prop];
      } else if (propIndex === null) {
        const signalRef = {
          signal: conditions.map((c) => {
            const { test: test2 } = c, valueOrSignalCRef = __rest22(c, ["test"]);
            return `${expression3(null, test2)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;
          }).join("") + exprFromValueRefOrSignalRef(valueOrSignalRef)
        };
        axis[prop] = signalRef;
      }
    } else if (isSignalRef(propValue)) {
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        setAxisEncode(axis, part, vgProp, propValue);
        delete axis[prop];
      }
    }
    if (contains2(["labelAlign", "labelBaseline"], prop) && axis[prop] === null) {
      delete axis[prop];
    }
  }
  if (kind === "grid") {
    if (!axis.grid) {
      return void 0;
    }
    if (axis.encode) {
      const { grid } = axis.encode;
      axis.encode = Object.assign({}, grid ? { grid } : {});
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    return Object.assign(Object.assign({
      scale: scale6,
      orient: orient2
    }, axis), {
      domain: false,
      labels: false,
      aria: false,
      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
      // would not affect gridAxis
      maxExtent: 0,
      minExtent: 0,
      ticks: false,
      zindex: getFirstDefined(zindex2, 0)
      // put grid behind marks by default
    });
  } else {
    if (!opt.header && axisCmpt.mainExtracted) {
      return void 0;
    }
    if (labelExpr !== void 0) {
      let expr2 = labelExpr;
      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {
        expr2 = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal);
      }
      setAxisEncode(axis, "labels", "text", { signal: expr2 });
    }
    if (axis.labelAlign === null) {
      delete axis.labelAlign;
    }
    if (axis.encode) {
      for (const part of AXIS_PARTS) {
        if (!axisCmpt.hasAxisPart(part)) {
          delete axis.encode[part];
        }
      }
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    const titleString = assembleTitle(title2, config);
    return Object.assign(Object.assign(Object.assign(Object.assign({
      scale: scale6,
      orient: orient2,
      grid: false
    }, titleString ? { title: titleString } : {}), axis), config.aria === false ? { aria: false } : {}), {
      zindex: getFirstDefined(zindex2, 0)
      // put axis line above marks by default
    });
  }
}
function assembleAxisSignals(model) {
  const { axes } = model.component;
  const signals = [];
  for (const channel of POSITION_SCALE_CHANNELS) {
    if (axes[channel]) {
      for (const axis of axes[channel]) {
        if (!axis.get("disable") && !axis.get("gridScale")) {
          const sizeType = channel === "x" ? "height" : "width";
          const update3 = model.getSizeSignalRef(sizeType).signal;
          if (sizeType !== update3) {
            signals.push({
              name: sizeType,
              update: update3
            });
          }
        }
      }
    }
  }
  return signals;
}
function assembleAxes(axisComponents, config) {
  const { x: x2 = [], y: y2 = [] } = axisComponents;
  return [
    ...x2.map((a) => assembleAxis(a, "grid", config)),
    ...y2.map((a) => assembleAxis(a, "grid", config)),
    ...x2.map((a) => assembleAxis(a, "main", config)),
    ...y2.map((a) => assembleAxis(a, "main", config))
  ].filter((a) => a);
}

// node_modules/vega-lite/build/src/compile/axis/config.js
function getAxisConfigFromConfigTypes(configTypes, config, channel, orient2) {
  return Object.assign.apply(null, [
    {},
    ...configTypes.map((configType) => {
      if (configType === "axisOrient") {
        const orient1 = channel === "x" ? "bottom" : "left";
        const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
        const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
        const props = /* @__PURE__ */ new Set([...keys3(orientConfig1), ...keys3(orientConfig2)]);
        const conditionalOrientAxisConfig = {};
        for (const prop of props.values()) {
          conditionalOrientAxisConfig[prop] = {
            // orient is surely signal in this case
            signal: `${orient2["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
          };
        }
        return conditionalOrientAxisConfig;
      }
      return config[configType];
    })
  ]);
}
function getAxisConfigs(channel, scaleType2, orient2, config) {
  const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
  const axisChannel = channel === "x" ? "axisX" : "axisY";
  const axisOrient = isSignalRef(orient2) ? "axisOrient" : `axis${titleCase(orient2)}`;
  const vlOnlyConfigTypes = [
    // technically Vega does have axisBand, but if we make another separation here,
    // it will further introduce complexity in the code
    ...typeBasedConfigTypes,
    ...typeBasedConfigTypes.map((c) => axisChannel + c.substr(4))
  ];
  const vgConfigTypes = ["axis", axisOrient, axisChannel];
  return {
    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient2),
    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient2),
    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
  };
}
function getAxisConfigStyle(axisConfigTypes, config) {
  var _a;
  const toMerge = [{}];
  for (const configType of axisConfigTypes) {
    let style2 = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;
    if (style2) {
      style2 = array(style2);
      for (const s of style2) {
        toMerge.push(config.style[s]);
      }
    }
  }
  return Object.assign.apply(null, toMerge);
}
function getAxisConfig(property2, styleConfigIndex, style2, axisConfigs = {}) {
  var _a;
  const styleConfig = getStyleConfig(property2, style2, styleConfigIndex);
  if (styleConfig !== void 0) {
    return {
      configFrom: "style",
      configValue: styleConfig
    };
  }
  for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property2]) !== void 0) {
      return { configFrom, configValue: axisConfigs[configFrom][property2] };
    }
  }
  return {};
}

// node_modules/vega-lite/build/src/compile/axis/properties.js
var axisRules = {
  scale: ({ model, channel }) => model.scaleName(channel),
  format: ({ fieldOrDatumDef, config, axis }) => {
    const { format: format5, formatType } = axis;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format5, formatType, config, true);
  },
  formatType: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = axis;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  grid: ({ fieldOrDatumDef, axis, scaleType: scaleType2 }) => {
    var _a;
    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType2, fieldOrDatumDef);
  },
  gridScale: ({ model, channel }) => gridScale(model, channel),
  labelAlign: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient2, channel),
  labelAngle: ({ labelAngle }) => labelAngle,
  labelBaseline: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient2, channel),
  labelFlush: ({ axis, fieldOrDatumDef, channel }) => {
    var _a;
    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);
  },
  labelOverlap: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    var _a;
    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType2, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0);
  },
  // we already calculate orient in parse
  orient: ({ orient: orient2 }) => orient2,
  tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    var _a;
    const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
    const size = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: axis.values });
  },
  title: ({ axis, model, channel }) => {
    if (axis.title !== void 0) {
      return axis.title;
    }
    const fieldDefTitle = getFieldDefTitle(model, channel);
    if (fieldDefTitle !== void 0) {
      return fieldDefTitle;
    }
    const fieldDef = model.typedFieldDef(channel);
    const channel2 = channel === "x" ? "x2" : "y2";
    const fieldDef2 = model.fieldDef(channel2);
    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
  },
  values: ({ axis, fieldOrDatumDef }) => values2(axis, fieldOrDatumDef),
  zindex: ({ axis, fieldOrDatumDef, mark: mark2 }) => {
    var _a;
    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark2, fieldOrDatumDef);
  }
};
function defaultGrid(scaleType2, fieldDef) {
  return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);
}
function gridScale(model, channel) {
  const gridChannel = channel === "x" ? "y" : "x";
  if (model.getScaleComponent(gridChannel)) {
    return model.scaleName(gridChannel);
  }
  return void 0;
}
function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {
  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;
  if (labelAngle !== void 0) {
    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
  } else {
    const { configValue: angle } = getAxisConfig("labelAngle", styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);
    if (angle !== void 0) {
      return normalizeAngle(angle);
    } else {
      if (channel === X2 && contains2([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {
        return 270;
      }
      return void 0;
    }
  }
}
function normalizeAngleExpr(angle) {
  return `(((${angle.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(angle, orient2, channel, alwaysIncludeMiddle) {
  if (angle !== void 0) {
    if (channel === "x") {
      if (isSignalRef(angle)) {
        const a = normalizeAngleExpr(angle);
        const orientIsTop = isSignalRef(orient2) ? `(${orient2.signal} === "top")` : orient2 === "top";
        return {
          signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? "middle" :(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? "bottom" : "top"`
        };
      }
      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {
        return "middle";
      }
      if (isSignalRef(orient2)) {
        const op = angle <= 45 || 315 <= angle ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "top" ? "bottom" : "top"` };
      }
      return (angle <= 45 || 315 <= angle) === (orient2 === "top") ? "bottom" : "top";
    } else {
      if (isSignalRef(angle)) {
        const a = normalizeAngleExpr(angle);
        const orientIsLeft = isSignalRef(orient2) ? `(${orient2.signal} === "left")` : orient2 === "left";
        const middle = alwaysIncludeMiddle ? '"middle"' : "null";
        return {
          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
        };
      }
      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {
        return alwaysIncludeMiddle ? "middle" : null;
      }
      if (isSignalRef(orient2)) {
        const op = 45 <= angle && angle <= 135 ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "left" ? "top" : "bottom"` };
      }
      return (45 <= angle && angle <= 135) === (orient2 === "left") ? "top" : "bottom";
    }
  }
  return void 0;
}
function defaultLabelAlign(angle, orient2, channel) {
  if (angle === void 0) {
    return void 0;
  }
  const isX2 = channel === "x";
  const startAngle = isX2 ? 0 : 90;
  const mainOrient = isX2 ? "bottom" : "left";
  if (isSignalRef(angle)) {
    const a = normalizeAngleExpr(angle);
    const orientIsMain = isSignalRef(orient2) ? `(${orient2.signal} === "${mainOrient}")` : orient2 === mainOrient;
    return {
      signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
    };
  }
  if ((angle + startAngle) % 180 === 0) {
    return isX2 ? null : "center";
  }
  if (isSignalRef(orient2)) {
    const op = startAngle < angle && angle < 180 + startAngle ? "===" : "!==";
    const orientIsMain = `${orient2.signal} ${op} "${mainOrient}"`;
    return {
      signal: `${orientIsMain} ? "left" : "right"`
    };
  }
  if ((startAngle < angle && angle < 180 + startAngle) === (orient2 === mainOrient)) {
    return "left";
  }
  return "right";
}
function defaultLabelFlush(type3, channel) {
  if (channel === "x" && contains2(["quantitative", "temporal"], type3)) {
    return true;
  }
  return void 0;
}
function defaultLabelOverlap(type3, scaleType2, hasTimeUnit, sort3) {
  if (hasTimeUnit && !isObject(sort3) || type3 !== "nominal" && type3 !== "ordinal") {
    if (scaleType2 === "log" || scaleType2 === "symlog") {
      return "greedy";
    }
    return true;
  }
  return void 0;
}
function defaultOrient(channel) {
  return channel === "x" ? "bottom" : "left";
}
function defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: vals2 }) {
  var _a;
  if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
    if (isFieldDef(fieldOrDatumDef)) {
      if (isBinning(fieldOrDatumDef.bin)) {
        return { signal: `ceil(${size.signal}/10)` };
      }
      if (fieldOrDatumDef.timeUnit && contains2(["month", "hours", "day", "quarter"], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {
        return void 0;
      }
    }
    return { signal: `ceil(${size.signal}/40)` };
  }
  return void 0;
}
function getFieldDefTitle(model, channel) {
  const channel2 = channel === "x" ? "x2" : "y2";
  const fieldDef = model.fieldDef(channel);
  const fieldDef2 = model.fieldDef(channel2);
  const title1 = fieldDef ? fieldDef.title : void 0;
  const title2 = fieldDef2 ? fieldDef2.title : void 0;
  if (title1 && title2) {
    return mergeTitle(title1, title2);
  } else if (title1) {
    return title1;
  } else if (title2) {
    return title2;
  } else if (title1 !== void 0) {
    return title1;
  } else if (title2 !== void 0) {
    return title2;
  }
  return void 0;
}
function values2(axis, fieldOrDatumDef) {
  const vals2 = axis.values;
  if (isArray(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultZindex(mark2, fieldDef) {
  if (mark2 === "rect" && isDiscrete3(fieldDef)) {
    return 1;
  }
  return 0;
}

// node_modules/vega-lite/build/src/compile/data/calculate.js
var CalculateNode = class _CalculateNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
    this._dependentFields = getDependentFields(this.transform.calculate);
  }
  clone() {
    return new _CalculateNode(null, duplicate(this.transform));
  }
  static parseAllForSortIndex(parent, model) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (!isScaleFieldDef(fieldDef)) {
        return;
      }
      if (isSortArray(fieldDef.sort)) {
        const { field: field3, timeUnit } = fieldDef;
        const sort3 = fieldDef.sort;
        const calculate = sort3.map((sortValue, i) => {
          return `${fieldFilterExpression({ field: field3, timeUnit, equal: sortValue })} ? ${i} : `;
        }).join("") + sort3.length;
        parent = new _CalculateNode(parent, {
          calculate,
          as: sortArrayIndexField(fieldDef, channel, { forAs: true })
        });
      }
    });
    return parent;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${hash(this.transform)}`;
  }
};
function sortArrayIndexField(fieldDef, channel, opt) {
  return vgField(fieldDef, Object.assign({ prefix: channel, suffix: "sort_index" }, opt !== null && opt !== void 0 ? opt : {}));
}

// node_modules/vega-lite/build/src/compile/header/common.js
function getHeaderChannel(channel, orient2) {
  if (contains2(["top", "bottom"], orient2)) {
    return "column";
  } else if (contains2(["left", "right"], orient2)) {
    return "row";
  }
  return channel === "row" ? "row" : "column";
}
function getHeaderProperty(prop, header, config, channel) {
  const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
  return getFirstDefined((header || {})[prop], headerSpecificConfig[prop], config.header[prop]);
}
function getHeaderProperties(properties, header, config, channel) {
  const props = {};
  for (const prop of properties) {
    const value3 = getHeaderProperty(prop, header || {}, config, channel);
    if (value3 !== void 0) {
      props[prop] = value3;
    }
  }
  return props;
}

// node_modules/vega-lite/build/src/compile/header/component.js
var HEADER_CHANNELS = ["row", "column"];
var HEADER_TYPES = ["header", "footer"];

// node_modules/vega-lite/build/src/compile/header/assemble.js
function assembleTitleGroup(model, channel) {
  const title2 = model.component.layoutHeaders[channel].title;
  const config = model.config ? model.config : void 0;
  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
  const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef.header, config, channel);
  const headerChannel = getHeaderChannel(channel, titleOrient);
  const titleAngle = normalizeAngle(ta);
  return {
    name: `${channel}-title`,
    type: "group",
    role: `${headerChannel}-title`,
    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: title2 }, channel === "row" ? { orient: "left" } : {}), { style: "guide-title" }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))
  };
}
function defaultHeaderGuideAlign(headerChannel, angle, anchor = "middle") {
  switch (anchor) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const align2 = defaultLabelAlign(angle, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
  return align2 ? { align: align2 } : {};
}
function defaultHeaderGuideBaseline(angle, channel) {
  const baseline3 = defaultLabelBaseline(angle, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
  return baseline3 ? { baseline: baseline3 } : {};
}
function assembleHeaderGroups(model, channel) {
  const layoutHeader = model.component.layoutHeaders[channel];
  const groups = [];
  for (const headerType of HEADER_TYPES) {
    if (layoutHeader[headerType]) {
      for (const headerComponent of layoutHeader[headerType]) {
        const group2 = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
        if (group2 != null) {
          groups.push(group2);
        }
      }
    }
  }
  return groups;
}
function getSort(facetFieldDef, channel) {
  var _a;
  const { sort: sort3 } = facetFieldDef;
  if (isSortField(sort3)) {
    return {
      field: vgField(sort3, { expr: "datum" }),
      order: (_a = sort3.order) !== null && _a !== void 0 ? _a : "ascending"
    };
  } else if (isArray(sort3)) {
    return {
      field: sortArrayIndexField(facetFieldDef, channel, { expr: "datum" }),
      order: "ascending"
    };
  } else {
    return {
      field: vgField(facetFieldDef, { expr: "datum" }),
      order: sort3 !== null && sort3 !== void 0 ? sort3 : "ascending"
    };
  }
}
function assembleLabelTitle(facetFieldDef, channel, config) {
  const { format: format5, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef.header, config, channel);
  const titleTextExpr = formatSignalRef({
    fieldOrDatumDef: facetFieldDef,
    format: format5,
    formatType,
    expr: "parent",
    config
  }).signal;
  const headerChannel = getHeaderChannel(channel, labelOrient);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: {
    signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, { expr: "parent" })) : titleTextExpr
  } }, channel === "row" ? { orient: "left" } : {}), { style: "guide-label", frame: "group" }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));
}
function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
  if (headerComponent) {
    let title2 = null;
    const { facetFieldDef } = layoutHeader;
    const config = model.config ? model.config : void 0;
    if (facetFieldDef && headerComponent.labels) {
      const { labelOrient } = getHeaderProperties(["labelOrient"], facetFieldDef.header, config, channel);
      if (channel === "row" && !contains2(["top", "bottom"], labelOrient) || channel === "column" && !contains2(["left", "right"], labelOrient)) {
        title2 = assembleLabelTitle(facetFieldDef, channel, config);
      }
    }
    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
    const axes = headerComponent.axes;
    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;
    if (title2 || hasAxes) {
      const sizeChannel = channel === "row" ? "height" : "width";
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName(`${channel}_${headerType}`), type: "group", role: `${channel}-${headerType}` }, layoutHeader.facetFieldDef ? {
        from: { data: model.getName(`${channel}_domain`) },
        sort: getSort(facetFieldDef, channel)
      } : {}), hasAxes && isFacetWithoutRowCol ? {
        from: { data: model.getName(`facet_domain_${channel}`) }
      } : {}), title2 ? { title: title2 } : {}), headerComponent.sizeSignal ? {
        encode: {
          update: {
            [sizeChannel]: headerComponent.sizeSignal
          }
        }
      } : {}), hasAxes ? { axes } : {});
    }
  }
  return null;
}
var LAYOUT_TITLE_BAND = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function getLayoutTitleBand(titleAnchor, headerChannel) {
  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
}
function assembleLayoutTitleBand(headerComponentIndex, config) {
  const titleBand = {};
  for (const channel of FACET_CHANNELS) {
    const headerComponent = headerComponentIndex[channel];
    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {
      const { titleAnchor, titleOrient } = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef.header, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const band2 = getLayoutTitleBand(titleAnchor, headerChannel);
      if (band2 !== void 0) {
        titleBand[headerChannel] = band2;
      }
    }
  }
  return isEmpty(titleBand) ? void 0 : titleBand;
}
function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
  const props = {};
  for (const prop of properties) {
    if (!propertiesMap[prop]) {
      continue;
    }
    const value3 = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);
    if (value3 !== void 0) {
      props[propertiesMap[prop]] = value3;
    }
  }
  return props;
}

// node_modules/vega-lite/build/src/compile/layoutsize/assemble.js
function assembleLayoutSignals(model) {
  return [
    ...sizeSignals(model, "width"),
    ...sizeSignals(model, "height"),
    ...sizeSignals(model, "childWidth"),
    ...sizeSignals(model, "childHeight")
  ];
}
function sizeSignals(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const size = model.component.layoutSize.get(sizeType);
  if (!size || size === "merged") {
    return [];
  }
  const name4 = model.getSizeSignalRef(sizeType).signal;
  if (size === "step") {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const type3 = scaleComponent.get("type");
      const range6 = scaleComponent.get("range");
      if (hasDiscreteDomain(type3) && isVgRangeStep(range6)) {
        const scaleName = model.scaleName(channel);
        if (isFacetModel(model.parent)) {
          const parentResolve = model.parent.component.resolve;
          if (parentResolve.scale[channel] === "independent") {
            return [stepSignal(scaleName, range6)];
          }
        }
        return [
          stepSignal(scaleName, range6),
          {
            name: name4,
            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (size == "container") {
    const isWidth = name4.endsWith("width");
    const expr2 = isWidth ? "containerSize()[0]" : "containerSize()[1]";
    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
    const safeExpr = `isFinite(${expr2}) ? ${expr2} : ${defaultValue}`;
    return [{ name: name4, init: safeExpr, on: [{ update: safeExpr, events: "window:resize" }] }];
  } else {
    return [
      {
        name: name4,
        value: size
      }
    ];
  }
}
function stepSignal(scaleName, range6) {
  const name4 = `${scaleName}_step`;
  if (isSignalRef(range6.step)) {
    return { name: name4, update: range6.step.signal };
  } else {
    return { name: name4, value: range6.step };
  }
}
function sizeExpr(scaleName, scaleComponent, cardinality) {
  const type3 = scaleComponent.get("type");
  const padding3 = scaleComponent.get("padding");
  const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding3);
  let paddingInner2 = scaleComponent.get("paddingInner");
  paddingInner2 = type3 === "band" ? (
    // only band has real paddingInner
    paddingInner2 !== void 0 ? paddingInner2 : padding3
  ) : (
    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
    1
  );
  return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner2)}, ${signalOrStringValue(paddingOuter2)}) * ${scaleName}_step`;
}

// node_modules/vega-lite/build/src/compile/layoutsize/component.js
function getSizeTypeFromLayoutSizeType(layoutSizeType) {
  return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
}

// node_modules/vega-lite/build/src/compile/guide.js
function guideEncodeEntry(encoding, model) {
  return keys3(encoding).reduce((encode2, channel) => {
    const valueDef = encoding[channel];
    return Object.assign(Object.assign({}, encode2), wrapCondition(model, valueDef, channel, (def2) => signalOrValueRef(def2.value)));
  }, {});
}

// node_modules/vega-lite/build/src/compile/resolve.js
function defaultScaleResolve(channel, model) {
  if (isFacetModel(model)) {
    return channel === "theta" ? "independent" : "shared";
  } else if (isLayerModel(model)) {
    return "shared";
  } else if (isConcatModel(model)) {
    return isXorY(channel) || channel === "theta" || channel === "radius" ? "independent" : "shared";
  }
  throw new Error("invalid model type for resolve");
}
function parseGuideResolve(resolve2, channel) {
  const channelScaleResolve = resolve2.scale[channel];
  const guide = isXorY(channel) ? "axis" : "legend";
  if (channelScaleResolve === "independent") {
    if (resolve2[guide][channel] === "shared") {
      warn2(message_exports.independentScaleMeansIndependentGuide(channel));
    }
    return "independent";
  }
  return resolve2[guide][channel] || "shared";
}

// node_modules/vega-lite/build/src/compile/legend/component.js
var LEGEND_COMPONENT_PROPERTY_INDEX = Object.assign(Object.assign({}, COMMON_LEGEND_PROPERTY_INDEX), {
  disable: 1,
  labelExpr: 1,
  selections: 1,
  // channel scales
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  // encode
  encode: 1
});
var LEGEND_COMPONENT_PROPERTIES = keys3(LEGEND_COMPONENT_PROPERTY_INDEX);
var LegendComponent = class extends Split {
};

// node_modules/vega-lite/build/src/compile/legend/encode.js
var legendEncodeRules = {
  symbols: symbols3,
  gradient: gradient3,
  labels,
  entries: entries2
};
function symbols3(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 }) {
  var _a, _b, _c2, _d2, _e, _f2, _g2, _h;
  if (legendType2 !== "symbol") {
    return void 0;
  }
  const { markDef, encoding, config, mark: mark2 } = model;
  const filled = markDef.filled && mark2 !== "trail";
  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), color3(model, { filled }));
  const symbolOpacity = (_a = legendCmpt.get("symbolOpacity")) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;
  const symbolFillColor = (_b = legendCmpt.get("symbolFillColor")) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;
  const symbolStrokeColor = (_c2 = legendCmpt.get("symbolStrokeColor")) !== null && _c2 !== void 0 ? _c2 : config.legend.symbolStrokeColor;
  const opacity2 = symbolOpacity === void 0 ? (_d2 = getMaxValue(encoding.opacity)) !== null && _d2 !== void 0 ? _d2 : markDef.opacity : void 0;
  if (out.fill) {
    if (channel === "fill" || filled && channel === COLOR) {
      delete out.fill;
    } else {
      if (out.fill["field"]) {
        if (symbolFillColor) {
          delete out.fill;
        } else {
          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : "black");
          out.fillOpacity = signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1);
        }
      } else if (isArray(out.fill)) {
        const fill2 = (_h = (_g2 = getFirstConditionValue((_f2 = encoding.fill) !== null && _f2 !== void 0 ? _f2 : encoding.color)) !== null && _g2 !== void 0 ? _g2 : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;
        if (fill2) {
          out.fill = signalOrValueRef(fill2);
        }
      }
    }
  }
  if (out.stroke) {
    if (channel === "stroke" || !filled && channel === COLOR) {
      delete out.stroke;
    } else {
      if (out.stroke["field"] || symbolStrokeColor) {
        delete out.stroke;
      } else if (isArray(out.stroke)) {
        const stroke2 = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : void 0);
        if (stroke2) {
          out.stroke = { value: stroke2 };
        }
      }
    }
  }
  if (channel !== OPACITY) {
    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
    if (condition) {
      out.opacity = [
        Object.assign({ test: condition }, signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1)),
        signalOrValueRef(config.legend.unselectedOpacity)
      ];
    } else if (opacity2) {
      out.opacity = signalOrValueRef(opacity2);
    }
  }
  out = Object.assign(Object.assign({}, out), symbolsSpec);
  return isEmpty(out) ? void 0 : out;
}
function gradient3(gradientSpec, { model, legendType: legendType2, legendCmpt }) {
  var _a;
  if (legendType2 !== "gradient") {
    return void 0;
  }
  const { config, markDef, encoding } = model;
  let out = {};
  const gradientOpacity = (_a = legendCmpt.get("gradientOpacity")) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;
  const opacity2 = gradientOpacity === void 0 ? getMaxValue(encoding.opacity) || markDef.opacity : void 0;
  if (opacity2) {
    out.opacity = signalOrValueRef(opacity2);
  }
  out = Object.assign(Object.assign({}, out), gradientSpec);
  return isEmpty(out) ? void 0 : out;
}
function labels(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {
  const legend = model.legend(channel) || {};
  const config = model.config;
  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
  const opacity2 = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : void 0;
  const { format: format5, formatType } = legend;
  let text4 = void 0;
  if (isCustomFormatType(formatType)) {
    text4 = formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format5,
      formatType,
      config
    });
  } else if (format5 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (fieldOrDatumDef.type === "quantitative" && config.numberFormatType) {
      text4 = formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.numberFormat,
        formatType: config.numberFormatType,
        config
      });
    } else if (fieldOrDatumDef.type === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
      text4 = formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.timeFormat,
        formatType: config.timeFormatType,
        config
      });
    }
  }
  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity2 ? { opacity: opacity2 } : {}), text4 ? { text: text4 } : {}), specifiedlabelsSpec);
  return isEmpty(labelsSpec) ? void 0 : labelsSpec;
}
function entries2(entriesSpec, { legendCmpt }) {
  const selections = legendCmpt.get("selections");
  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: "transparent" } }) : entriesSpec;
}
function getMaxValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
}
function getFirstConditionValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => {
    return getFirstDefined(v, conditionalDef.value);
  });
}
function getConditionValue(channelDef, reducer) {
  if (hasConditionalValueDef(channelDef)) {
    return array(channelDef.condition).reduce(reducer, channelDef.value);
  } else if (isValueDef(channelDef)) {
    return channelDef.value;
  }
  return void 0;
}
function selectedCondition(model, legendCmpt, fieldDef) {
  const selections = legendCmpt.get("selections");
  if (!(selections === null || selections === void 0 ? void 0 : selections.length))
    return void 0;
  const field3 = $(fieldDef.field);
  return selections.map((name4) => {
    const store = $(varName(name4) + STORE);
    return `(!length(data(${store})) || (${name4}[${field3}] && indexof(${name4}[${field3}], datum.value) >= 0))`;
  }).join(" || ");
}

// node_modules/vega-lite/build/src/compile/legend/properties.js
var legendRules = {
  direction: ({ direction }) => direction,
  format: ({ fieldOrDatumDef, legend, config }) => {
    const { format: format5, formatType } = legend;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format5, formatType, config, false);
  },
  formatType: ({ legend, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = legend;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  gradientLength: (params2) => {
    var _a, _b;
    const { legend, legendConfig } = params2;
    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params2);
  },
  labelOverlap: ({ legend, legendConfig, scaleType: scaleType2 }) => {
    var _a, _b;
    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap2(scaleType2);
  },
  symbolType: ({ legend, markDef, channel, encoding }) => {
    var _a;
    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);
  },
  title: ({ fieldOrDatumDef, config }) => title(fieldOrDatumDef, config, { allowDisabling: true }),
  type: ({ legendType: legendType2, scaleType: scaleType2, channel }) => {
    if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
      if (legendType2 === "gradient") {
        return void 0;
      }
    } else if (legendType2 === "symbol") {
      return void 0;
    }
    return legendType2;
  },
  values: ({ fieldOrDatumDef, legend }) => values3(legend, fieldOrDatumDef)
};
function values3(legend, fieldOrDatumDef) {
  const vals2 = legend.values;
  if (isArray(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultSymbolType(mark2, channel, shapeChannelDef, markShape) {
  var _a;
  if (channel !== "shape") {
    const shape2 = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;
    if (shape2) {
      return shape2;
    }
  }
  switch (mark2) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function getLegendType(params2) {
  const { legend } = params2;
  return getFirstDefined(legend.type, defaultType2(params2));
}
function defaultType2({ channel, timeUnit, scaleType: scaleType2 }) {
  if (isColorChannel(channel)) {
    if (contains2(["quarter", "month", "day"], timeUnit)) {
      return "symbol";
    }
    if (isContinuousToContinuous(scaleType2)) {
      return "gradient";
    }
  }
  return "symbol";
}
function getDirection({ legendConfig, legendType: legendType2, orient: orient2, legend }) {
  var _a, _b;
  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType2 ? "gradientDirection" : "symbolDirection"]) !== null && _b !== void 0 ? _b : defaultDirection(orient2, legendType2);
}
function defaultDirection(orient2, legendType2) {
  switch (orient2) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return void 0;
    default:
      return legendType2 === "gradient" ? "horizontal" : void 0;
  }
}
function defaultGradientLength({ legendConfig, model, direction, orient: orient2, scaleType: scaleType2 }) {
  const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;
  if (isContinuousToContinuous(scaleType2)) {
    if (direction === "horizontal") {
      if (orient2 === "top" || orient2 === "bottom") {
        return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
      } else {
        return gradientHorizontalMinLength;
      }
    } else {
      return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
    }
  }
  return void 0;
}
function gradientLengthSignal(model, sizeType, min4, max4) {
  const sizeSignal = model.getSizeSignalRef(sizeType).signal;
  return { signal: `clamp(${sizeSignal}, ${min4}, ${max4})` };
}
function defaultLabelOverlap2(scaleType2) {
  if (contains2(["quantile", "threshold", "log", "symlog"], scaleType2)) {
    return "greedy";
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/legend/parse.js
function parseLegend2(model) {
  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
  model.component.legends = legendComponent;
  return legendComponent;
}
function parseUnitLegend(model) {
  const { encoding } = model;
  const legendComponent = {};
  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
    const def2 = getFieldOrDatumDef(encoding[channel]);
    if (!def2 || !model.getScaleComponent(channel)) {
      continue;
    }
    if (channel === SHAPE && isFieldDef(def2) && def2.type === GEOJSON) {
      continue;
    }
    legendComponent[channel] = parseLegendForChannel(model, channel);
  }
  return legendComponent;
}
function getLegendDefWithScale(model, channel) {
  const scale6 = model.scaleName(channel);
  if (model.mark === "trail") {
    if (channel === "color") {
      return { stroke: scale6 };
    } else if (channel === "size") {
      return { strokeWidth: scale6 };
    }
  }
  if (channel === "color") {
    return model.markDef.filled ? { fill: scale6 } : { stroke: scale6 };
  }
  return { [channel]: scale6 };
}
function isExplicit(value3, property2, legend, fieldDef) {
  switch (property2) {
    case "disable":
      return legend !== void 0;
    case "values":
      return !!(legend === null || legend === void 0 ? void 0 : legend.values);
    case "title":
      if (property2 === "title" && value3 === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {
        return true;
      }
  }
  return value3 === (legend || {})[property2];
}
function parseLegendForChannel(model, channel) {
  var _a, _b, _c2;
  let legend = model.legend(channel);
  const { markDef, encoding, config } = model;
  const legendConfig = config.legend;
  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
  parseInteractiveLegend(model, channel, legendCmpt);
  const disable = legend !== void 0 ? !legend : legendConfig.disable;
  legendCmpt.set("disable", disable, legend !== void 0);
  if (disable) {
    return legendCmpt;
  }
  legend = legend || {};
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0;
  const orient2 = legend.orient || config.legend.orient || "right";
  const legendType2 = getLegendType({ legend, channel, timeUnit, scaleType: scaleType2 });
  const direction = getDirection({ legend, legendType: legendType2, orient: orient2, legendConfig });
  const ruleParams = {
    legend,
    channel,
    model,
    markDef,
    encoding,
    fieldOrDatumDef,
    legendConfig,
    config,
    scaleType: scaleType2,
    orient: orient2,
    legendType: legendType2,
    direction
  };
  for (const property2 of LEGEND_COMPONENT_PROPERTIES) {
    if (legendType2 === "gradient" && property2.startsWith("symbol") || legendType2 === "symbol" && property2.startsWith("gradient")) {
      continue;
    }
    const value3 = property2 in legendRules ? legendRules[property2](ruleParams) : legend[property2];
    if (value3 !== void 0) {
      const explicit = isExplicit(value3, property2, legend, model.fieldDef(channel));
      if (explicit || config.legend[property2] === void 0) {
        legendCmpt.set(property2, value3, explicit);
      }
    }
  }
  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};
  const selections = legendCmpt.get("selections");
  const legendEncode = {};
  const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 };
  for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const legendEncodingPart = guideEncodeEntry((_c2 = legendEncoding[part]) !== null && _c2 !== void 0 ? _c2 : {}, model);
    const value3 = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
    if (value3 !== void 0 && !isEmpty(value3)) {
      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {}), { update: value3 });
    }
  }
  if (!isEmpty(legendEncode)) {
    legendCmpt.set("encode", legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));
  }
  return legendCmpt;
}
function parseNonUnitLegend(model) {
  const { legends, resolve: resolve2 } = model.component;
  for (const child of model.children) {
    parseLegend2(child);
    for (const channel of keys3(child.component.legends)) {
      resolve2.legend[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.legend[channel] === "shared") {
        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
        if (!legends[channel]) {
          resolve2.legend[channel] = "independent";
          delete legends[channel];
        }
      }
    }
  }
  for (const channel of keys3(legends)) {
    for (const child of model.children) {
      if (!child.component.legends[channel]) {
        continue;
      }
      if (resolve2.legend[channel] === "shared") {
        delete child.component.legends[channel];
      }
    }
  }
  return legends;
}
function mergeLegendComponent(mergedLegend, childLegend) {
  var _a, _b, _c2, _d2;
  if (!mergedLegend) {
    return childLegend.clone();
  }
  const mergedOrient = mergedLegend.getWithExplicit("orient");
  const childOrient = childLegend.getWithExplicit("orient");
  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
    return void 0;
  }
  let typeMerged = false;
  for (const prop of LEGEND_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      mergedLegend.getWithExplicit(prop),
      childLegend.getWithExplicit(prop),
      prop,
      "legend",
      // Tie breaker function
      (v1, v2) => {
        switch (prop) {
          case "symbolType":
            return mergeSymbolType(v1, v2);
          case "title":
            return mergeTitleComponent(v1, v2);
          case "type":
            typeMerged = true;
            return makeImplicit("symbol");
        }
        return defaultTieBreaker(v1, v2, prop, "legend");
      }
    );
    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
  }
  if (typeMerged) {
    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {
      deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
    }
    if ((_d2 = (_c2 = mergedLegend.explicit) === null || _c2 === void 0 ? void 0 : _c2.encode) === null || _d2 === void 0 ? void 0 : _d2.gradient) {
      deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
    }
  }
  return mergedLegend;
}
function mergeSymbolType(st1, st2) {
  if (st2.value === "circle") {
    return st2;
  }
  return st1;
}

// node_modules/vega-lite/build/src/compile/legend/assemble.js
var __rest23 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function setLegendEncode(legend, part, vgProp, vgRef) {
  var _a, _b, _c2;
  var _d2, _e;
  (_a = legend.encode) !== null && _a !== void 0 ? _a : legend.encode = {};
  (_b = (_d2 = legend.encode)[part]) !== null && _b !== void 0 ? _b : _d2[part] = {};
  (_c2 = (_e = legend.encode[part]).update) !== null && _c2 !== void 0 ? _c2 : _e.update = {};
  legend.encode[part].update[vgProp] = vgRef;
}
function assembleLegends(model) {
  const legendComponentIndex = model.component.legends;
  const legendByDomain = {};
  for (const channel of keys3(legendComponentIndex)) {
    const scaleComponent = model.getScaleComponent(channel);
    const domainHash = stringify(scaleComponent.get("domains"));
    if (legendByDomain[domainHash]) {
      for (const mergedLegendComponent of legendByDomain[domainHash]) {
        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
        if (!merged) {
          legendByDomain[domainHash].push(legendComponentIndex[channel]);
        }
      }
    } else {
      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
    }
  }
  const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
  return legends;
}
function assembleLegend(legendCmpt, config) {
  var _a, _b, _c2;
  const _d2 = legendCmpt.combine(), { disable, labelExpr, selections } = _d2, legend = __rest23(_d2, ["disable", "labelExpr", "selections"]);
  if (disable) {
    return void 0;
  }
  if (config.aria === false && legend.aria == void 0) {
    legend.aria = false;
  }
  if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {
    const out = legend.encode.symbols.update;
    if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
      out.stroke = { value: "transparent" };
    }
    for (const property2 of LEGEND_SCALE_CHANNELS) {
      if (legend[property2]) {
        delete out[property2];
      }
    }
  }
  if (!legend.title) {
    delete legend.title;
  }
  if (labelExpr !== void 0) {
    let expr2 = labelExpr;
    if (((_c2 = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c2 === void 0 ? void 0 : _c2.update) && isSignalRef(legend.encode.labels.update.text)) {
      expr2 = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
    }
    setLegendEncode(legend, "labels", "text", { signal: expr2 });
  }
  return legend;
}

// node_modules/vega-lite/build/src/compile/projection/assemble.js
function assembleProjections(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return assembleProjectionsForModelAndChildren(model);
  } else {
    return assembleProjectionForModel(model);
  }
}
function assembleProjectionsForModelAndChildren(model) {
  return model.children.reduce((projections2, child) => {
    return projections2.concat(child.assembleProjections());
  }, assembleProjectionForModel(model));
}
function assembleProjectionForModel(model) {
  const component = model.component.projection;
  if (!component || component.merged) {
    return [];
  }
  const projection3 = component.combine();
  const { name: name4 } = projection3;
  if (!component.data) {
    return [
      Object.assign(Object.assign({ name: name4 }, { translate: { signal: "[width / 2, height / 2]" } }), projection3)
    ];
  } else {
    const size = {
      signal: `[${component.size.map((ref2) => ref2.signal).join(", ")}]`
    };
    const fits = component.data.reduce((sources, data3) => {
      const source4 = isSignalRef(data3) ? data3.signal : `data('${model.lookupDataSource(data3)}')`;
      if (!contains2(sources, source4)) {
        sources.push(source4);
      }
      return sources;
    }, []);
    if (fits.length <= 0) {
      throw new Error("Projection's fit didn't find any data sources");
    }
    return [
      Object.assign({
        name: name4,
        size,
        fit: {
          signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
        }
      }, projection3)
    ];
  }
}

// node_modules/vega-lite/build/src/projection.js
var PROJECTION_PROPERTIES = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];

// node_modules/vega-lite/build/src/compile/projection/component.js
var ProjectionComponent = class extends Split {
  constructor(name4, specifiedProjection, size, data3) {
    super(
      Object.assign({}, specifiedProjection),
      // all explicit properties of projection
      { name: name4 }
      // name as initial implicit property
    );
    this.specifiedProjection = specifiedProjection;
    this.size = size;
    this.data = data3;
    this.merged = false;
  }
  /**
   * Whether the projection parameters should fit provided data.
   */
  get isFit() {
    return !!this.data;
  }
};

// node_modules/vega-lite/build/src/compile/projection/parse.js
function parseProjection2(model) {
  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
}
function parseUnitProjection(model) {
  var _a;
  if (model.hasProjection) {
    const proj = replaceExprRef(model.specifiedProjection);
    const fit2 = !(proj && (proj.scale != null || proj.translate != null));
    const size = fit2 ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
    const data3 = fit2 ? gatherFitData(model) : void 0;
    const projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {}), proj !== null && proj !== void 0 ? proj : {}), size, data3);
    if (!projComp.get("type")) {
      projComp.set("type", "equalEarth", false);
    }
    return projComp;
  }
  return void 0;
}
function gatherFitData(model) {
  const data3 = [];
  const { encoding } = model;
  for (const posssiblePair of [
    [LONGITUDE, LATITUDE],
    [LONGITUDE2, LATITUDE2]
  ]) {
    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
      data3.push({
        signal: model.getName(`geojson_${data3.length}`)
      });
    }
  }
  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
    data3.push({
      signal: model.getName(`geojson_${data3.length}`)
    });
  }
  if (data3.length === 0) {
    data3.push(model.requestDataName(DataSourceType.Main));
  }
  return data3;
}
function mergeIfNoConflict(first, second2) {
  const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {
    if (!has(first.explicit, prop) && !has(second2.explicit, prop)) {
      return true;
    }
    if (has(first.explicit, prop) && has(second2.explicit, prop) && // some properties might be signals or objects and require hashing for comparison
    deepEqual(first.get(prop), second2.get(prop))) {
      return true;
    }
    return false;
  });
  const size = deepEqual(first.size, second2.size);
  if (size) {
    if (allPropertiesShared) {
      return first;
    } else if (deepEqual(first.explicit, {})) {
      return second2;
    } else if (deepEqual(second2.explicit, {})) {
      return first;
    }
  }
  return null;
}
function parseNonUnitProjections(model) {
  if (model.children.length === 0) {
    return void 0;
  }
  let nonUnitProjection;
  for (const child of model.children) {
    parseProjection2(child);
  }
  const mergable = every(model.children, (child) => {
    const projection3 = child.component.projection;
    if (!projection3) {
      return true;
    } else if (!nonUnitProjection) {
      nonUnitProjection = projection3;
      return true;
    } else {
      const merge5 = mergeIfNoConflict(nonUnitProjection, projection3);
      if (merge5) {
        nonUnitProjection = merge5;
      }
      return !!merge5;
    }
  });
  if (nonUnitProjection && mergable) {
    const name4 = model.projectionName(true);
    const modelProjection = new ProjectionComponent(name4, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
    for (const child of model.children) {
      const projection3 = child.component.projection;
      if (projection3) {
        if (projection3.isFit) {
          modelProjection.data.push(...child.component.projection.data);
        }
        child.renameProjection(projection3.get("name"), name4);
        projection3.merged = true;
      }
    }
    return modelProjection;
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/data/bin.js
var __rest24 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function rangeFormula(model, fieldDef, channel, config) {
  var _a, _b;
  if (binRequiresRange(fieldDef, channel)) {
    const guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};
    const startField = vgField(fieldDef, { expr: "datum" });
    const endField = vgField(fieldDef, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: vgField(fieldDef, { binSuffix: "range", forAs: true }),
      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
    };
  }
  return {};
}
function binKey(bin3, field3) {
  return `${binToString(bin3)}_${field3}`;
}
function getSignalsFromModel(model, key2) {
  return {
    signal: model.getName(`${key2}_bins`),
    extentSignal: model.getName(`${key2}_extent`)
  };
}
function getBinSignalName(model, field3, bin3) {
  var _a;
  const normalizedBin = (_a = normalizeBin(bin3, void 0)) !== null && _a !== void 0 ? _a : {};
  const key2 = binKey(normalizedBin, field3);
  return model.getName(`${key2}_bins`);
}
function isBinTransform(t2) {
  return "as" in t2;
}
function createBinComponent(t2, bin3, model) {
  let as;
  let span2;
  if (isBinTransform(t2)) {
    as = isString(t2.as) ? [t2.as, `${t2.as}_end`] : [t2.as[0], t2.as[1]];
  } else {
    as = [vgField(t2, { forAs: true }), vgField(t2, { binSuffix: "end", forAs: true })];
  }
  const normalizedBin = Object.assign({}, normalizeBin(bin3, void 0));
  const key2 = binKey(normalizedBin, t2.field);
  const { signal, extentSignal } = getSignalsFromModel(model, key2);
  if (isParameterExtent(normalizedBin.extent)) {
    const ext = normalizedBin.extent;
    span2 = parseSelectionExtent(model, ext.param, ext);
    delete normalizedBin.extent;
  }
  const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t2.field, as: [as] }, signal ? { signal } : {}), extentSignal ? { extentSignal } : {}), span2 ? { span: span2 } : {});
  return { key: key2, binComponent };
}
var BinNode = class _BinNode extends DataFlowNode {
  constructor(parent, bins2) {
    super(parent);
    this.bins = bins2;
  }
  clone() {
    return new _BinNode(null, duplicate(this.bins));
  }
  static makeFromEncoding(parent, model) {
    const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
        const { key: key2, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);
        binComponentIndex[key2] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key2]), rangeFormula(model, fieldDef, channel, model.config));
      }
      return binComponentIndex;
    }, {});
    if (isEmpty(bins2)) {
      return null;
    }
    return new _BinNode(parent, bins2);
  }
  /**
   * Creates a bin node from BinTransform.
   * The optional parameter should provide
   */
  static makeFromTransform(parent, t2, model) {
    const { key: key2, binComponent } = createBinComponent(t2, t2.bin, model);
    return new _BinNode(parent, {
      [key2]: binComponent
    });
  }
  /**
   * Merge bin nodes. This method either integrates the bin config from the other node
   * or if this node already has a bin config, renames the corresponding signal in the model.
   */
  merge(other, renameSignal) {
    for (const key2 of keys3(other.bins)) {
      if (key2 in this.bins) {
        renameSignal(other.bins[key2].signal, this.bins[key2].signal);
        this.bins[key2].as = unique([...this.bins[key2].as, ...other.bins[key2].as], hash);
      } else {
        this.bins[key2] = other.bins[key2];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  producedFields() {
    return new Set(vals(this.bins).map((c) => c.as).flat(2));
  }
  dependentFields() {
    return new Set(vals(this.bins).map((c) => c.field));
  }
  hash() {
    return `Bin ${hash(this.bins)}`;
  }
  assemble() {
    return vals(this.bins).flatMap((bin3) => {
      const transform4 = [];
      const [binAs, ...remainingAs] = bin3.as;
      const _a = bin3.bin, { extent: extent2 } = _a, params2 = __rest24(_a, ["extent"]);
      const binTrans = Object.assign(Object.assign(Object.assign({ type: "bin", field: replacePathInField(bin3.field), as: binAs, signal: bin3.signal }, !isParameterExtent(extent2) ? { extent: extent2 } : { extent: null }), bin3.span ? { span: { signal: `span(${bin3.span})` } } : {}), params2);
      if (!extent2 && bin3.extentSignal) {
        transform4.push({
          type: "extent",
          field: replacePathInField(bin3.field),
          signal: bin3.extentSignal
        });
        binTrans.extent = { signal: bin3.extentSignal };
      }
      transform4.push(binTrans);
      for (const as of remainingAs) {
        for (let i = 0; i < 2; i++) {
          transform4.push({
            type: "formula",
            expr: vgField({ field: binAs[i] }, { expr: "datum" }),
            as: as[i]
          });
        }
      }
      if (bin3.formula) {
        transform4.push({
          type: "formula",
          expr: bin3.formula,
          as: bin3.formulaAs
        });
      }
      return transform4;
    });
  }
};

// node_modules/vega-lite/build/src/compile/data/aggregate.js
function addDimension(dims, channel, fieldDef, model) {
  var _a;
  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {
    dims.add(vgField(fieldDef, {}));
    dims.add(vgField(fieldDef, { suffix: "end" }));
    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
      dims.add(vgField(fieldDef, { binSuffix: "range" }));
    }
  } else if (isGeoPositionChannel(channel)) {
    const posChannel = getPositionChannelFromLatLong(channel);
    dims.add(model.getName(posChannel));
  } else {
    dims.add(vgField(fieldDef));
  }
  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {
    dims.add(fieldDef.scale.range.field);
  }
  return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
  var _a;
  for (const field3 of keys3(childMeasures)) {
    const ops2 = childMeasures[field3];
    for (const op of keys3(ops2)) {
      if (field3 in parentMeasures) {
        parentMeasures[field3][op] = /* @__PURE__ */ new Set([...(_a = parentMeasures[field3][op]) !== null && _a !== void 0 ? _a : [], ...ops2[op]]);
      } else {
        parentMeasures[field3] = { [op]: ops2[op] };
      }
    }
  }
}
var AggregateNode = class _AggregateNode extends DataFlowNode {
  /**
   * @param dimensions string set for dimensions
   * @param measures dictionary mapping field name => dict of aggregation functions and names to use
   */
  constructor(parent, dimensions, measures) {
    super(parent);
    this.dimensions = dimensions;
    this.measures = measures;
  }
  clone() {
    return new _AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(parent, model) {
    let isAggregate3 = false;
    model.forEachFieldDef((fd) => {
      if (fd.aggregate) {
        isAggregate3 = true;
      }
    });
    const meas = {};
    const dims = /* @__PURE__ */ new Set();
    if (!isAggregate3) {
      return null;
    }
    model.forEachFieldDef((fieldDef, channel) => {
      var _a, _b, _c2, _d2;
      const { aggregate, field: field3 } = fieldDef;
      if (aggregate) {
        if (aggregate === "count") {
          (_a = meas["*"]) !== null && _a !== void 0 ? _a : meas["*"] = {};
          meas["*"]["count"] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
        } else {
          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
            const op = isArgminDef(aggregate) ? "argmin" : "argmax";
            const argField = aggregate[op];
            (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};
            meas[argField][op] = /* @__PURE__ */ new Set([vgField({ op, field: argField }, { forAs: true })]);
          } else {
            (_c2 = meas[field3]) !== null && _c2 !== void 0 ? _c2 : meas[field3] = {};
            meas[field3][aggregate] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
          }
          if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
            (_d2 = meas[field3]) !== null && _d2 !== void 0 ? _d2 : meas[field3] = {};
            meas[field3]["min"] = /* @__PURE__ */ new Set([vgField({ field: field3, aggregate: "min" }, { forAs: true })]);
            meas[field3]["max"] = /* @__PURE__ */ new Set([vgField({ field: field3, aggregate: "max" }, { forAs: true })]);
          }
        }
      } else {
        addDimension(dims, channel, fieldDef, model);
      }
    });
    if (dims.size + keys3(meas).length === 0) {
      return null;
    }
    return new _AggregateNode(parent, dims, meas);
  }
  static makeFromTransform(parent, t2) {
    var _a, _b, _c2;
    const dims = /* @__PURE__ */ new Set();
    const meas = {};
    for (const s of t2.aggregate) {
      const { op, field: field3, as } = s;
      if (op) {
        if (op === "count") {
          (_a = meas["*"]) !== null && _a !== void 0 ? _a : meas["*"] = {};
          meas["*"]["count"] = /* @__PURE__ */ new Set([as ? as : vgField(s, { forAs: true })]);
        } else {
          (_b = meas[field3]) !== null && _b !== void 0 ? _b : meas[field3] = {};
          meas[field3][op] = /* @__PURE__ */ new Set([as ? as : vgField(s, { forAs: true })]);
        }
      }
    }
    for (const s of (_c2 = t2.groupby) !== null && _c2 !== void 0 ? _c2 : []) {
      dims.add(s);
    }
    if (dims.size + keys3(meas).length === 0) {
      return null;
    }
    return new _AggregateNode(parent, dims, meas);
  }
  merge(other) {
    if (setEqual(this.dimensions, other.dimensions)) {
      mergeMeasures(this.measures, other.measures);
      return true;
    }
    debug2("different dimensions, cannot merge");
    return false;
  }
  addDimensions(fields) {
    fields.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...keys3(this.measures)]);
  }
  producedFields() {
    const out = /* @__PURE__ */ new Set();
    for (const field3 of keys3(this.measures)) {
      for (const op of keys3(this.measures[field3])) {
        const m = this.measures[field3][op];
        if (m.size === 0) {
          out.add(`${op}_${field3}`);
        } else {
          m.forEach(out.add, out);
        }
      }
    }
    return out;
  }
  hash() {
    return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const ops2 = [];
    const fields = [];
    const as = [];
    for (const field3 of keys3(this.measures)) {
      for (const op of keys3(this.measures[field3])) {
        for (const alias of this.measures[field3][op]) {
          as.push(alias);
          ops2.push(op);
          fields.push(field3 === "*" ? null : replacePathInField(field3));
        }
      }
    }
    const result = {
      type: "aggregate",
      groupby: [...this.dimensions].map(replacePathInField),
      ops: ops2,
      fields,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/facet.js
var FacetNode = class extends DataFlowNode {
  /**
   * @param model The facet model.
   * @param name The name that this facet source will have.
   * @param data The source data for this facet data.
   */
  constructor(parent, model, name4, data3) {
    super(parent);
    this.model = model;
    this.name = name4;
    this.data = data3;
    for (const channel of FACET_CHANNELS) {
      const fieldDef = model.facet[channel];
      if (fieldDef) {
        const { bin: bin3, sort: sort3 } = fieldDef;
        this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...isBinning(bin3) ? [vgField(fieldDef, { binSuffix: "end" })] : []] }, isSortField(sort3) ? { sortField: sort3 } : isArray(sort3) ? { sortIndexField: sortArrayIndexField(fieldDef, channel) } : {});
      }
    }
    this.childModel = model.child;
  }
  hash() {
    let out = `Facet`;
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
      }
    }
    return out;
  }
  get fields() {
    var _a;
    const f = [];
    for (const channel of FACET_CHANNELS) {
      if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {
        f.push(...this[channel].fields);
      }
    }
    return f;
  }
  dependentFields() {
    const depFields = new Set(this.fields);
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        if (this[channel].sortField) {
          depFields.add(this[channel].sortField.field);
        }
        if (this[channel].sortIndexField) {
          depFields.add(this[channel].sortIndexField);
        }
      }
    }
    return depFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  /**
   * The name to reference this source is its name.
   */
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const childIndependentFieldsWithStep = {};
    for (const channel of POSITION_SCALE_CHANNELS) {
      const childScaleComponent = this.childModel.component.scales[channel];
      if (childScaleComponent && !childScaleComponent.merged) {
        const type3 = childScaleComponent.get("type");
        const range6 = childScaleComponent.get("range");
        if (hasDiscreteDomain(type3) && isVgRangeStep(range6)) {
          const domain4 = assembleDomain(this.childModel, channel);
          const field3 = getFieldFromDomain(domain4);
          if (field3) {
            childIndependentFieldsWithStep[channel] = field3;
          } else {
            warn2(message_exports.unknownField(channel));
          }
        }
      }
    }
    return childIndependentFieldsWithStep;
  }
  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
    const childChannel = { row: "y", column: "x", facet: void 0 }[channel];
    const fields = [];
    const ops2 = [];
    const as = [];
    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
      if (crossedDataName) {
        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        ops2.push("max");
      } else {
        fields.push(childIndependentFieldsWithStep[childChannel]);
        ops2.push("distinct");
      }
      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
    }
    const { sortField, sortIndexField } = this[channel];
    if (sortField) {
      const { op = DEFAULT_SORT_OP, field: field3 } = sortField;
      fields.push(field3);
      ops2.push(op);
      as.push(vgField(sortField, { forAs: true }));
    } else if (sortIndexField) {
      fields.push(sortIndexField);
      ops2.push("max");
      as.push(sortIndexField);
    }
    return {
      name: this[channel].name,
      // Use data from the crossed one if it exist
      source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,
      transform: [
        Object.assign({ type: "aggregate", groupby: this[channel].fields }, fields.length ? {
          fields,
          ops: ops2,
          as
        } : {})
      ]
    };
  }
  assembleFacetHeaderData(childIndependentFieldsWithStep) {
    var _a, _b;
    const { columns } = this.model.layout;
    const { layoutHeaders: layoutHeaders2 } = this.model.component;
    const data3 = [];
    const hasSharedAxis = {};
    for (const headerChannel of HEADER_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const headers = (_a = layoutHeaders2[headerChannel] && layoutHeaders2[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];
        for (const header of headers) {
          if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            hasSharedAxis[headerChannel] = true;
            break;
          }
        }
      }
      if (hasSharedAxis[headerChannel]) {
        const cardinality = `length(data("${this.facet.name}"))`;
        const stop3 = headerChannel === "row" ? columns ? { signal: `ceil(${cardinality} / ${columns})` } : 1 : columns ? { signal: `min(${cardinality}, ${columns})` } : { signal: cardinality };
        data3.push({
          name: `${this.facet.name}_${headerChannel}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: stop3
            }
          ]
        });
      }
    }
    const { row, column } = hasSharedAxis;
    if (row || column) {
      data3.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
    }
    return data3;
  }
  assemble() {
    var _a, _b;
    const data3 = [];
    let crossedDataName = null;
    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
    const { column, row, facet } = this;
    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
      crossedDataName = `cross_${this.column.name}_${this.row.name}`;
      const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);
      const ops2 = fields.map(() => "distinct");
      data3.push({
        name: crossedDataName,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields,
            ops: ops2
          }
        ]
      });
    }
    for (const channel of [COLUMN, ROW]) {
      if (this[channel]) {
        data3.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
      }
    }
    if (facet) {
      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
      if (facetData) {
        data3.push(...facetData);
      }
    }
    return data3;
  }
};

// node_modules/vega-lite/build/src/compile/data/formatparse.js
function unquote(pattern) {
  if (pattern.startsWith("'") && pattern.endsWith("'") || pattern.startsWith('"') && pattern.endsWith('"')) {
    return pattern.slice(1, -1);
  }
  return pattern;
}
function parseExpression3(field3, parse7) {
  const f = accessPathWithDatum(field3);
  if (parse7 === "number") {
    return `toNumber(${f})`;
  } else if (parse7 === "boolean") {
    return `toBoolean(${f})`;
  } else if (parse7 === "string") {
    return `toString(${f})`;
  } else if (parse7 === "date") {
    return `toDate(${f})`;
  } else if (parse7 === "flatten") {
    return f;
  } else if (parse7.startsWith("date:")) {
    const specifier = unquote(parse7.slice(5, parse7.length));
    return `timeParse(${f},'${specifier}')`;
  } else if (parse7.startsWith("utc:")) {
    const specifier = unquote(parse7.slice(4, parse7.length));
    return `utcParse(${f},'${specifier}')`;
  } else {
    warn2(message_exports.unrecognizedParse(parse7));
    return null;
  }
}
function getImplicitFromFilterTransform(transform4) {
  const implicit2 = {};
  forEachLeaf(transform4.filter, (filter3) => {
    var _a;
    if (isFieldPredicate(filter3)) {
      let val = null;
      if (isFieldEqualPredicate(filter3)) {
        val = signalRefOrValue(filter3.equal);
      } else if (isFieldLTEPredicate(filter3)) {
        val = signalRefOrValue(filter3.lte);
      } else if (isFieldLTPredicate(filter3)) {
        val = signalRefOrValue(filter3.lt);
      } else if (isFieldGTPredicate(filter3)) {
        val = signalRefOrValue(filter3.gt);
      } else if (isFieldGTEPredicate(filter3)) {
        val = signalRefOrValue(filter3.gte);
      } else if (isFieldRangePredicate(filter3)) {
        val = filter3.range[0];
      } else if (isFieldOneOfPredicate(filter3)) {
        val = ((_a = filter3.oneOf) !== null && _a !== void 0 ? _a : filter3["in"])[0];
      }
      if (val) {
        if (isDateTime(val)) {
          implicit2[filter3.field] = "date";
        } else if (isNumber(val)) {
          implicit2[filter3.field] = "number";
        } else if (isString(val)) {
          implicit2[filter3.field] = "string";
        }
      }
      if (filter3.timeUnit) {
        implicit2[filter3.field] = "date";
      }
    }
  });
  return implicit2;
}
function getImplicitFromEncoding(model) {
  const implicit2 = {};
  function add5(fieldDef) {
    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
      implicit2[fieldDef.field] = "date";
    } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
      implicit2[fieldDef.field] = "number";
    } else if (accessPathDepth(fieldDef.field) > 1) {
      if (!(fieldDef.field in implicit2)) {
        implicit2[fieldDef.field] = "flatten";
      }
    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
      if (!(fieldDef.sort.field in implicit2)) {
        implicit2[fieldDef.sort.field] = "flatten";
      }
    }
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef)) {
        add5(fieldDef);
      } else {
        const mainChannel = getMainRangeChannel(channel);
        const mainFieldDef = model.fieldDef(mainChannel);
        add5(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));
      }
    });
  }
  if (isUnitModel(model)) {
    const { mark: mark2, markDef, encoding } = model;
    if (isPathMark(mark2) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
    !model.encoding.order) {
      const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
      const dimensionChannelDef = encoding[dimensionChannel];
      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit2)) {
        implicit2[dimensionChannelDef.field] = "number";
      }
    }
  }
  return implicit2;
}
function getImplicitFromSelection(model) {
  const implicit2 = {};
  if (isUnitModel(model) && model.component.selection) {
    for (const name4 of keys3(model.component.selection)) {
      const selCmpt = model.component.selection[name4];
      for (const proj of selCmpt.project.items) {
        if (!proj.channel && accessPathDepth(proj.field) > 1) {
          implicit2[proj.field] = "flatten";
        }
      }
    }
  }
  return implicit2;
}
var ParseNode = class _ParseNode extends DataFlowNode {
  constructor(parent, parse7) {
    super(parent);
    this._parse = parse7;
  }
  clone() {
    return new _ParseNode(null, duplicate(this._parse));
  }
  hash() {
    return `Parse ${hash(this._parse)}`;
  }
  /**
   * Creates a parse node from a data.format.parse and updates ancestorParse.
   */
  static makeExplicit(parent, model, ancestorParse) {
    var _a;
    let explicit = {};
    const data3 = model.data;
    if (!isGenerator(data3) && ((_a = data3 === null || data3 === void 0 ? void 0 : data3.format) === null || _a === void 0 ? void 0 : _a.parse)) {
      explicit = data3.format.parse;
    }
    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
  }
  /**
   * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
   */
  static makeWithAncestors(parent, explicit, implicit2, ancestorParse) {
    for (const field3 of keys3(implicit2)) {
      const parsedAs = ancestorParse.getWithExplicit(field3);
      if (parsedAs.value !== void 0) {
        if (parsedAs.explicit || parsedAs.value === implicit2[field3] || parsedAs.value === "derived" || implicit2[field3] === "flatten") {
          delete implicit2[field3];
        } else {
          warn2(message_exports.differentParse(field3, implicit2[field3], parsedAs.value));
        }
      }
    }
    for (const field3 of keys3(explicit)) {
      const parsedAs = ancestorParse.get(field3);
      if (parsedAs !== void 0) {
        if (parsedAs === explicit[field3]) {
          delete explicit[field3];
        } else {
          warn2(message_exports.differentParse(field3, explicit[field3], parsedAs));
        }
      }
    }
    const parse7 = new Split(explicit, implicit2);
    ancestorParse.copyAll(parse7);
    const p = {};
    for (const key2 of keys3(parse7.combine())) {
      const val = parse7.get(key2);
      if (val !== null) {
        p[key2] = val;
      }
    }
    if (keys3(p).length === 0 || ancestorParse.parseNothing) {
      return null;
    }
    return new _ParseNode(parent, p);
  }
  get parse() {
    return this._parse;
  }
  merge(other) {
    this._parse = Object.assign(Object.assign({}, this._parse), other.parse);
    other.remove();
  }
  /**
   * Assemble an object for Vega's format.parse property.
   */
  assembleFormatParse() {
    const formatParse = {};
    for (const field3 of keys3(this._parse)) {
      const p = this._parse[field3];
      if (accessPathDepth(field3) === 1) {
        formatParse[field3] = p;
      }
    }
    return formatParse;
  }
  // format parse depends and produces all fields in its parse
  producedFields() {
    return new Set(keys3(this._parse));
  }
  dependentFields() {
    return new Set(keys3(this._parse));
  }
  assembleTransforms(onlyNested = false) {
    return keys3(this._parse).filter((field3) => onlyNested ? accessPathDepth(field3) > 1 : true).map((field3) => {
      const expr2 = parseExpression3(field3, this._parse[field3]);
      if (!expr2) {
        return null;
      }
      const formula = {
        type: "formula",
        expr: expr2,
        as: removePathFromField(field3)
        // Vega output is always flattened
      };
      return formula;
    }).filter((t2) => t2 !== null);
  }
};

// node_modules/vega-lite/build/src/compile/data/identifier.js
var IdentifierNode = class _IdentifierNode extends DataFlowNode {
  clone() {
    return new _IdentifierNode(null);
  }
  constructor(parent) {
    super(parent);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([SELECTION_ID]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: SELECTION_ID };
  }
};

// node_modules/vega-lite/build/src/compile/data/graticule.js
var GraticuleNode = class _GraticuleNode extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    this.params = params2;
  }
  clone() {
    return new _GraticuleNode(null, this.params);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return void 0;
  }
  hash() {
    return `Graticule ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: "graticule" }, this.params === true ? {} : this.params);
  }
};

// node_modules/vega-lite/build/src/compile/data/sequence.js
var SequenceNode = class _SequenceNode extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    this.params = params2;
  }
  clone() {
    return new _SequenceNode(null, this.params);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    var _a;
    return /* @__PURE__ */ new Set([(_a = this.params.as) !== null && _a !== void 0 ? _a : "data"]);
  }
  hash() {
    return `Hash ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: "sequence" }, this.params);
  }
};

// node_modules/vega-lite/build/src/compile/data/source.js
var SourceNode = class extends DataFlowNode {
  constructor(data3) {
    super(null);
    data3 !== null && data3 !== void 0 ? data3 : data3 = { name: "source" };
    let format5;
    if (!isGenerator(data3)) {
      format5 = data3.format ? Object.assign({}, omit(data3.format, ["parse"])) : {};
    }
    if (isInlineData(data3)) {
      this._data = { values: data3.values };
    } else if (isUrlData(data3)) {
      this._data = { url: data3.url };
      if (!format5.type) {
        let defaultExtension = /(?:\.([^.]+))?$/.exec(data3.url)[1];
        if (!contains2(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
          defaultExtension = "json";
        }
        format5.type = defaultExtension;
      }
    } else if (isSphereGenerator(data3)) {
      this._data = { values: [{ type: "Sphere" }] };
    } else if (isNamedData(data3) || isGenerator(data3)) {
      this._data = {};
    }
    this._generator = isGenerator(data3);
    if (data3.name) {
      this._name = data3.name;
    }
    if (format5 && !isEmpty(format5)) {
      this._data.format = format5;
    }
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return void 0;
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(name4) {
    this._name = name4;
  }
  set parent(parent) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });
  }
};

// node_modules/vega-lite/build/src/compile/data/optimizer.js
var __classPrivateFieldSet = function(receiver, state, value3, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value3) : f ? f.value = value3 : state.set(receiver, value3), value3;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Optimizer_modified;
function isDataSourceNode(node) {
  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
}
var Optimizer = class {
  constructor() {
    _Optimizer_modified.set(this, void 0);
    __classPrivateFieldSet(this, _Optimizer_modified, false, "f");
  }
  // Once true, #modified is never set to false
  setModified() {
    __classPrivateFieldSet(this, _Optimizer_modified, true, "f");
  }
  get modifiedFlag() {
    return __classPrivateFieldGet(this, _Optimizer_modified, "f");
  }
};
_Optimizer_modified = /* @__PURE__ */ new WeakMap();
var BottomUpOptimizer = class extends Optimizer {
  /**
   * Compute a map of node depths that we can use to determine a topological sort order.
   */
  getNodeDepths(node, depth, depths) {
    depths.set(node, depth);
    for (const child of node.children) {
      this.getNodeDepths(child, depth + 1, depths);
    }
    return depths;
  }
  /**
   * Run the optimizer on all nodes starting from the leaves.
   */
  optimize(node) {
    const depths = this.getNodeDepths(node, 0, /* @__PURE__ */ new Map());
    const topologicalSort = [...depths.entries()].sort((a, b2) => b2[1] - a[1]);
    for (const tuple of topologicalSort) {
      this.run(tuple[0]);
    }
    return this.modifiedFlag;
  }
};
var TopDownOptimizer = class extends Optimizer {
  /**
   * Run the optimizer depth first on all nodes starting from the roots.
   */
  optimize(node) {
    this.run(node);
    for (const child of node.children) {
      this.optimize(child);
    }
    return this.modifiedFlag;
  }
};

// node_modules/vega-lite/build/src/compile/data/optimizers.js
var MergeIdenticalNodes = class extends TopDownOptimizer {
  mergeNodes(parent, nodes) {
    const mergedNode = nodes.shift();
    for (const node of nodes) {
      parent.removeChild(node);
      node.parent = mergedNode;
      node.remove();
    }
  }
  run(node) {
    const hashes = node.children.map((x2) => x2.hash());
    const buckets = {};
    for (let i = 0; i < hashes.length; i++) {
      if (buckets[hashes[i]] === void 0) {
        buckets[hashes[i]] = [node.children[i]];
      } else {
        buckets[hashes[i]].push(node.children[i]);
      }
    }
    for (const k2 of keys3(buckets)) {
      if (buckets[k2].length > 1) {
        this.setModified();
        this.mergeNodes(node, buckets[k2]);
      }
    }
  }
};
var RemoveUnnecessaryIdentifierNodes = class extends TopDownOptimizer {
  constructor(model) {
    super();
    this.requiresSelectionId = model && requiresSelectionId(model);
  }
  run(node) {
    if (node instanceof IdentifierNode) {
      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {
        this.setModified();
        node.remove();
      }
    }
  }
};
var RemoveDuplicateTimeUnits = class extends Optimizer {
  optimize(node) {
    this.run(node, /* @__PURE__ */ new Set());
    return this.modifiedFlag;
  }
  run(node, timeUnitFields) {
    let producedFields = /* @__PURE__ */ new Set();
    if (node instanceof TimeUnitNode) {
      producedFields = node.producedFields();
      if (hasIntersection(producedFields, timeUnitFields)) {
        this.setModified();
        node.removeFormulas(timeUnitFields);
        if (node.producedFields.length === 0) {
          node.remove();
        }
      }
    }
    for (const child of node.children) {
      this.run(child, /* @__PURE__ */ new Set([...timeUnitFields, ...producedFields]));
    }
  }
};
var RemoveUnnecessaryOutputNodes = class extends TopDownOptimizer {
  constructor() {
    super();
  }
  run(node) {
    if (node instanceof OutputNode && !node.isRequired()) {
      this.setModified();
      node.remove();
    }
  }
};
var MoveParseUp = class extends BottomUpOptimizer {
  run(node) {
    if (isDataSourceNode(node)) {
      return;
    }
    if (node.numChildren() > 1) {
      return;
    }
    for (const child of node.children) {
      if (child instanceof ParseNode) {
        if (node instanceof ParseNode) {
          this.setModified();
          node.merge(child);
        } else {
          if (fieldIntersection(node.producedFields(), child.dependentFields())) {
            continue;
          }
          this.setModified();
          child.swapWithParent();
        }
      }
    }
    return;
  }
};
var MergeParse = class extends BottomUpOptimizer {
  run(node) {
    const originalChildren = [...node.children];
    const parseChildren = node.children.filter((child) => child instanceof ParseNode);
    if (node.numChildren() > 1 && parseChildren.length >= 1) {
      const commonParse = {};
      const conflictingParse = /* @__PURE__ */ new Set();
      for (const parseNode of parseChildren) {
        const parse7 = parseNode.parse;
        for (const k2 of keys3(parse7)) {
          if (!(k2 in commonParse)) {
            commonParse[k2] = parse7[k2];
          } else if (commonParse[k2] !== parse7[k2]) {
            conflictingParse.add(k2);
          }
        }
      }
      for (const field3 of conflictingParse) {
        delete commonParse[field3];
      }
      if (!isEmpty(commonParse)) {
        this.setModified();
        const mergedParseNode = new ParseNode(node, commonParse);
        for (const childNode of originalChildren) {
          if (childNode instanceof ParseNode) {
            for (const key2 of keys3(commonParse)) {
              delete childNode.parse[key2];
            }
          }
          node.removeChild(childNode);
          childNode.parent = mergedParseNode;
          if (childNode instanceof ParseNode && keys3(childNode.parse).length === 0) {
            childNode.remove();
          }
        }
      }
    }
  }
};
var RemoveUnusedSubtrees = class extends BottomUpOptimizer {
  run(node) {
    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {
    } else if (node instanceof SourceNode) {
    } else {
      this.setModified();
      node.remove();
    }
  }
};
var MergeTimeUnits = class extends BottomUpOptimizer {
  run(node) {
    const timeUnitChildren = node.children.filter((x2) => x2 instanceof TimeUnitNode);
    const combination = timeUnitChildren.pop();
    for (const timeUnit of timeUnitChildren) {
      this.setModified();
      combination.merge(timeUnit);
    }
  }
};
var MergeAggregates = class extends BottomUpOptimizer {
  run(node) {
    const aggChildren = node.children.filter((child) => child instanceof AggregateNode);
    const groupedAggregates = {};
    for (const agg of aggChildren) {
      const groupBys = hash(agg.groupBy);
      if (!(groupBys in groupedAggregates)) {
        groupedAggregates[groupBys] = [];
      }
      groupedAggregates[groupBys].push(agg);
    }
    for (const group2 of keys3(groupedAggregates)) {
      const mergeableAggs = groupedAggregates[group2];
      if (mergeableAggs.length > 1) {
        const mergedAggs = mergeableAggs.pop();
        for (const agg of mergeableAggs) {
          if (mergedAggs.merge(agg)) {
            node.removeChild(agg);
            agg.parent = mergedAggs;
            agg.remove();
            this.setModified();
          }
        }
      }
    }
  }
};
var MergeBins = class extends BottomUpOptimizer {
  constructor(model) {
    super();
    this.model = model;
  }
  run(node) {
    const moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);
    const promotableBins = [];
    const remainingBins = [];
    for (const child of node.children) {
      if (child instanceof BinNode) {
        if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {
          promotableBins.push(child);
        } else {
          remainingBins.push(child);
        }
      }
    }
    if (promotableBins.length > 0) {
      const promotedBin = promotableBins.pop();
      for (const bin3 of promotableBins) {
        promotedBin.merge(bin3, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
      if (node instanceof BinNode) {
        node.merge(promotedBin, this.model.renameSignal.bind(this.model));
      } else {
        promotedBin.swapWithParent();
      }
    }
    if (remainingBins.length > 1) {
      const remainingBin = remainingBins.pop();
      for (const bin3 of remainingBins) {
        remainingBin.merge(bin3, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
    }
  }
};
var MergeOutputs = class extends BottomUpOptimizer {
  run(node) {
    const children4 = [...node.children];
    const hasOutputChild = some(children4, (child) => child instanceof OutputNode);
    if (!hasOutputChild || node.numChildren() <= 1) {
      return;
    }
    const otherChildren = [];
    let mainOutput;
    for (const child of children4) {
      if (child instanceof OutputNode) {
        let lastOutput = child;
        while (lastOutput.numChildren() === 1) {
          const [theChild] = lastOutput.children;
          if (theChild instanceof OutputNode) {
            lastOutput = theChild;
          } else {
            break;
          }
        }
        otherChildren.push(...lastOutput.children);
        if (mainOutput) {
          node.removeChild(child);
          child.parent = mainOutput.parent;
          mainOutput.parent.removeChild(mainOutput);
          mainOutput.parent = lastOutput;
          this.setModified();
        } else {
          mainOutput = lastOutput;
        }
      } else {
        otherChildren.push(child);
      }
    }
    if (otherChildren.length) {
      this.setModified();
      for (const child of otherChildren) {
        child.parent.removeChild(child);
        child.parent = mainOutput;
      }
    }
  }
};

// node_modules/vega-lite/build/src/compile/data/joinaggregate.js
var JoinAggregateTransformNode = class _JoinAggregateTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new _JoinAggregateTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    if (this.transform.groupby) {
      this.transform.groupby.forEach(out.add, out);
    }
    this.transform.joinaggregate.map((w4) => w4.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(joinAggregateFieldDef) {
    var _a;
    return (_a = joinAggregateFieldDef.as) !== null && _a !== void 0 ? _a : vgField(joinAggregateFieldDef);
  }
  hash() {
    return `JoinAggregateTransform ${hash(this.transform)}`;
  }
  assemble() {
    const fields = [];
    const ops2 = [];
    const as = [];
    for (const joinaggregate of this.transform.joinaggregate) {
      ops2.push(joinaggregate.op);
      as.push(this.getDefaultName(joinaggregate));
      fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
    }
    const groupby = this.transform.groupby;
    return Object.assign({
      type: "joinaggregate",
      as,
      ops: ops2,
      fields
    }, groupby !== void 0 ? { groupby } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/stack.js
function getStackByFields(model) {
  return model.stack.stackBy.reduce((fields, by) => {
    const fieldDef = by.fieldDef;
    const _field = vgField(fieldDef);
    if (_field) {
      fields.push(_field);
    }
    return fields;
  }, []);
}
function isValidAsArray(as) {
  return isArray(as) && as.every((s) => isString(s)) && as.length > 1;
}
var StackNode = class _StackNode extends DataFlowNode {
  constructor(parent, stack2) {
    super(parent);
    this._stack = stack2;
  }
  clone() {
    return new _StackNode(null, duplicate(this._stack));
  }
  static makeFromTransform(parent, stackTransform) {
    const { stack: stack2, groupby, as, offset: offset4 = "zero" } = stackTransform;
    const sortFields = [];
    const sortOrder = [];
    if (stackTransform.sort !== void 0) {
      for (const sortField of stackTransform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push(getFirstDefined(sortField.order, "ascending"));
      }
    }
    const sort3 = {
      field: sortFields,
      order: sortOrder
    };
    let normalizedAs;
    if (isValidAsArray(as)) {
      normalizedAs = as;
    } else if (isString(as)) {
      normalizedAs = [as, `${as}_end`];
    } else {
      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];
    }
    return new _StackNode(parent, {
      dimensionFieldDefs: [],
      stackField: stack2,
      groupby,
      offset: offset4,
      sort: sort3,
      facetby: [],
      as: normalizedAs
    });
  }
  static makeFromEncoding(parent, model) {
    const stackProperties = model.stack;
    const { encoding } = model;
    if (!stackProperties) {
      return null;
    }
    const { groupbyChannels, fieldChannel, offset: offset4, impute } = stackProperties;
    const dimensionFieldDefs = groupbyChannels.map((groupbyChannel) => {
      const cDef = encoding[groupbyChannel];
      return getFieldDef(cDef);
    }).filter((def2) => !!def2);
    const stackby = getStackByFields(model);
    const orderDef = model.encoding.order;
    let sort3;
    if (isArray(orderDef) || isFieldDef(orderDef)) {
      sort3 = sortParams(orderDef);
    } else {
      sort3 = stackby.reduce((s, field3) => {
        s.field.push(field3);
        s.order.push(fieldChannel === "y" ? "descending" : "ascending");
        return s;
      }, { field: [], order: [] });
    }
    return new _StackNode(parent, {
      dimensionFieldDefs,
      stackField: model.vgField(fieldChannel),
      facetby: [],
      stackby,
      sort: sort3,
      offset: offset4,
      impute,
      as: [
        model.vgField(fieldChannel, { suffix: "start", forAs: true }),
        model.vgField(fieldChannel, { suffix: "end", forAs: true })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(fields) {
    this._stack.facetby.push(...fields);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    out.add(this._stack.stackField);
    this.getGroupbyFields().forEach(out.add, out);
    this._stack.facetby.forEach(out.add, out);
    this._stack.sort.field.forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${hash(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs, impute, groupby } = this._stack;
    if (dimensionFieldDefs.length > 0) {
      return dimensionFieldDefs.map((dimensionFieldDef) => {
        if (dimensionFieldDef.bin) {
          if (impute) {
            return [vgField(dimensionFieldDef, { binSuffix: "mid" })];
          }
          return [
            // For binned group by field without impute, we need both bin (start) and bin_end
            vgField(dimensionFieldDef, {}),
            vgField(dimensionFieldDef, { binSuffix: "end" })
          ];
        }
        return [vgField(dimensionFieldDef)];
      }).flat();
    }
    return groupby !== null && groupby !== void 0 ? groupby : [];
  }
  assemble() {
    const transform4 = [];
    const { facetby, dimensionFieldDefs, stackField: field3, stackby, sort: sort3, offset: offset4, impute, as } = this._stack;
    if (impute) {
      for (const dimensionFieldDef of dimensionFieldDefs) {
        const { bandPosition = 0.5, bin: bin3 } = dimensionFieldDef;
        if (bin3) {
          const binStart = vgField(dimensionFieldDef, { expr: "datum" });
          const binEnd = vgField(dimensionFieldDef, { expr: "datum", binSuffix: "end" });
          transform4.push({
            type: "formula",
            expr: `${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd}`,
            as: vgField(dimensionFieldDef, { binSuffix: "mid", forAs: true })
          });
        }
        transform4.push({
          type: "impute",
          field: field3,
          groupby: [...stackby, ...facetby],
          key: vgField(dimensionFieldDef, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    }
    transform4.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...facetby],
      field: field3,
      sort: sort3,
      as,
      offset: offset4
    });
    return transform4;
  }
};

// node_modules/vega-lite/build/src/compile/data/window.js
var WindowTransformNode = class _WindowTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new _WindowTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    var _a, _b;
    const out = /* @__PURE__ */ new Set();
    ((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).forEach(out.add, out);
    ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach((m) => out.add(m.field));
    this.transform.window.map((w4) => w4.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(windowFieldDef) {
    var _a;
    return (_a = windowFieldDef.as) !== null && _a !== void 0 ? _a : vgField(windowFieldDef);
  }
  hash() {
    return `WindowTransform ${hash(this.transform)}`;
  }
  assemble() {
    var _a;
    const fields = [];
    const ops2 = [];
    const as = [];
    const params2 = [];
    for (const window2 of this.transform.window) {
      ops2.push(window2.op);
      as.push(this.getDefaultName(window2));
      params2.push(window2.param === void 0 ? null : window2.param);
      fields.push(window2.field === void 0 ? null : window2.field);
    }
    const frame = this.transform.frame;
    const groupby = this.transform.groupby;
    if (frame && frame[0] === null && frame[1] === null && ops2.every((o) => isAggregateOp(o))) {
      return Object.assign({ type: "joinaggregate", as, ops: ops2, fields }, groupby !== void 0 ? { groupby } : {});
    }
    const sortFields = [];
    const sortOrder = [];
    if (this.transform.sort !== void 0) {
      for (const sortField of this.transform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push((_a = sortField.order) !== null && _a !== void 0 ? _a : "ascending");
      }
    }
    const sort3 = {
      field: sortFields,
      order: sortOrder
    };
    const ignorePeers = this.transform.ignorePeers;
    return Object.assign(Object.assign(Object.assign({
      type: "window",
      params: params2,
      as,
      ops: ops2,
      fields,
      sort: sort3
    }, ignorePeers !== void 0 ? { ignorePeers } : {}), groupby !== void 0 ? { groupby } : {}), frame !== void 0 ? { frame } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/subtree.js
function cloneSubtree(facet) {
  function clone(node) {
    if (!(node instanceof FacetNode)) {
      const copy2 = node.clone();
      if (copy2 instanceof OutputNode) {
        const newName = FACET_SCALE_PREFIX + copy2.getSource();
        copy2.setSource(newName);
        facet.model.component.data.outputNodes[newName] = copy2;
      } else if (copy2 instanceof AggregateNode || copy2 instanceof StackNode || copy2 instanceof WindowTransformNode || copy2 instanceof JoinAggregateTransformNode) {
        copy2.addDimensions(facet.fields);
      }
      for (const n of node.children.flatMap(clone)) {
        n.parent = copy2;
      }
      return [copy2];
    }
    return node.children.flatMap(clone);
  }
  return clone;
}
function moveFacetDown(node) {
  if (node instanceof FacetNode) {
    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {
      const child = node.children[0];
      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
        child.addDimensions(node.fields);
      }
      child.swapWithParent();
      moveFacetDown(node);
    } else {
      const facetMain = node.model.component.data.main;
      moveMainDownToFacet(facetMain);
      const cloner = cloneSubtree(node);
      const copy2 = node.children.map(cloner).flat();
      for (const c of copy2) {
        c.parent = facetMain;
      }
    }
  } else {
    node.children.map(moveFacetDown);
  }
}
function moveMainDownToFacet(node) {
  if (node instanceof OutputNode && node.type === DataSourceType.Main) {
    if (node.numChildren() === 1) {
      const child = node.children[0];
      if (!(child instanceof FacetNode)) {
        child.swapWithParent();
        moveMainDownToFacet(node);
      }
    }
  }
}

// node_modules/vega-lite/build/src/compile/data/optimize.js
var FACET_SCALE_PREFIX = "scale_";
var MAX_OPTIMIZATION_RUNS = 5;
function checkLinks(nodes) {
  for (const node of nodes) {
    for (const child of node.children) {
      if (child.parent !== node) {
        return false;
      }
    }
    if (!checkLinks(node.children)) {
      return false;
    }
  }
  return true;
}
function runOptimizer(optimizer, nodes) {
  let modified2 = false;
  for (const node of nodes) {
    modified2 = optimizer.optimize(node) || modified2;
  }
  return modified2;
}
function optimizationDataflowHelper(dataComponent, model, firstPass) {
  let roots = dataComponent.sources;
  let modified2 = false;
  modified2 = runOptimizer(new RemoveUnnecessaryOutputNodes(), roots) || modified2;
  modified2 = runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots) || modified2;
  roots = roots.filter((r2) => r2.numChildren() > 0);
  modified2 = runOptimizer(new RemoveUnusedSubtrees(), roots) || modified2;
  roots = roots.filter((r2) => r2.numChildren() > 0);
  if (!firstPass) {
    modified2 = runOptimizer(new MoveParseUp(), roots) || modified2;
    modified2 = runOptimizer(new MergeBins(model), roots) || modified2;
    modified2 = runOptimizer(new RemoveDuplicateTimeUnits(), roots) || modified2;
    modified2 = runOptimizer(new MergeParse(), roots) || modified2;
    modified2 = runOptimizer(new MergeAggregates(), roots) || modified2;
    modified2 = runOptimizer(new MergeTimeUnits(), roots) || modified2;
    modified2 = runOptimizer(new MergeIdenticalNodes(), roots) || modified2;
    modified2 = runOptimizer(new MergeOutputs(), roots) || modified2;
  }
  dataComponent.sources = roots;
  return modified2;
}
function optimizeDataflow(data3, model) {
  checkLinks(data3.sources);
  let firstPassCounter = 0;
  let secondPassCounter = 0;
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data3, model, true)) {
      break;
    }
    firstPassCounter++;
  }
  data3.sources.map(moveFacetDown);
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data3, model, false)) {
      break;
    }
    secondPassCounter++;
  }
  checkLinks(data3.sources);
  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
    warn2(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
  }
}

// node_modules/vega-lite/build/src/compile/signal.js
var SignalRefWrapper = class _SignalRefWrapper {
  constructor(exprGenerator) {
    Object.defineProperty(this, "signal", {
      enumerable: true,
      get: exprGenerator
    });
  }
  static fromName(rename, signalName) {
    return new _SignalRefWrapper(() => rename(signalName));
  }
};

// node_modules/vega-lite/build/src/compile/scale/domain.js
var __rest25 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function parseScaleDomain2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleDomain(model);
  } else {
    parseNonUnitScaleDomain(model);
  }
}
function parseUnitScaleDomain(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of keys3(localScaleComponents)) {
    const domains = parseDomainForChannel(model, channel);
    const localScaleCmpt = localScaleComponents[channel];
    localScaleCmpt.setWithExplicit("domains", domains);
    parseSelectionDomain(model, channel);
    if (model.component.data.isFaceted) {
      let facetParent = model;
      while (!isFacetModel(facetParent) && facetParent.parent) {
        facetParent = facetParent.parent;
      }
      const resolve2 = facetParent.component.resolve.scale[channel];
      if (resolve2 === "shared") {
        for (const domain4 of domains.value) {
          if (isDataRefDomain(domain4)) {
            domain4.data = FACET_SCALE_PREFIX + domain4.data.replace(FACET_SCALE_PREFIX, "");
          }
        }
      }
    }
  }
}
function parseNonUnitScaleDomain(model) {
  for (const child of model.children) {
    parseScaleDomain2(child);
  }
  const localScaleComponents = model.component.scales;
  for (const channel of keys3(localScaleComponents)) {
    let domains;
    let selectionExtent = null;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        if (domains === void 0) {
          domains = childComponent.getWithExplicit("domains");
        } else {
          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
        }
        const se = childComponent.get("selectionExtent");
        if (selectionExtent && se && selectionExtent.param !== se.param) {
          warn2(message_exports.NEEDS_SAME_SELECTION);
        }
        selectionExtent = se;
      }
    }
    localScaleComponents[channel].setWithExplicit("domains", domains);
    if (selectionExtent) {
      localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
    }
  }
}
function normalizeUnaggregatedDomain(domain4, fieldDef, scaleType2, scaleConfig) {
  if (domain4 === "unaggregated") {
    const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (!valid) {
      warn2(reason);
      return void 0;
    }
  } else if (domain4 === void 0 && scaleConfig.useUnaggregatedDomain) {
    const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (valid) {
      return "unaggregated";
    }
  }
  return domain4;
}
function parseDomainForChannel(model, channel) {
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const { encoding } = model;
  const domain4 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
  if (domain4 !== model.scaleDomain(channel)) {
    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), { domain: domain4 });
  }
  if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
    if (getFieldOrDatumDef(encoding.x)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain4, model, "x"), parseSingleChannelDomain(scaleType2, domain4, model, "x2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain4, model, "x2");
    }
  } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
    if (getFieldOrDatumDef(encoding.y)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain4, model, "y"), parseSingleChannelDomain(scaleType2, domain4, model, "y2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain4, model, "y2");
    }
  }
  return parseSingleChannelDomain(scaleType2, domain4, model, channel);
}
function mapDomainToDataSignal(domain4, type3, timeUnit) {
  return domain4.map((v) => {
    const data3 = valueExpr(v, { timeUnit, type: type3 });
    return { signal: `{data: ${data3}}` };
  });
}
function convertDomainIfItIsDateTime(domain4, type3, timeUnit) {
  var _a;
  const normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
  if (type3 === "temporal" || normalizedTimeUnit) {
    return mapDomainToDataSignal(domain4, type3, normalizedTimeUnit);
  }
  return [domain4];
}
function parseSingleChannelDomain(scaleType2, domain4, model, channel) {
  const { encoding } = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const { type: type3 } = fieldOrDatumDef;
  const timeUnit = fieldOrDatumDef["timeUnit"];
  if (isDomainUnionWith(domain4)) {
    const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
    const unionWith = convertDomainIfItIsDateTime(domain4.unionWith, type3, timeUnit);
    return makeExplicit([...defaultDomain.value, ...unionWith]);
  } else if (isSignalRef(domain4)) {
    return makeExplicit([domain4]);
  } else if (domain4 && domain4 !== "unaggregated" && !isParameterDomain(domain4)) {
    return makeExplicit(convertDomainIfItIsDateTime(domain4, type3, timeUnit));
  }
  const stack2 = model.stack;
  if (stack2 && channel === stack2.fieldChannel) {
    if (stack2.offset === "normalize") {
      return makeImplicit([[0, 1]]);
    }
    const data3 = model.requestDataName(DataSourceType.Main);
    return makeImplicit([
      {
        data: data3,
        field: model.vgField(channel, { suffix: "start" })
      },
      {
        data: data3,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  }
  const sort3 = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
  if (isDatumDef(fieldOrDatumDef)) {
    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type3, timeUnit);
    return makeImplicit(d);
  }
  const fieldDef = fieldOrDatumDef;
  if (domain4 === "unaggregated") {
    const data3 = model.requestDataName(DataSourceType.Main);
    const { field: field3 } = fieldOrDatumDef;
    return makeImplicit([
      {
        data: data3,
        field: vgField({ field: field3, aggregate: "min" })
      },
      {
        data: data3,
        field: vgField({ field: field3, aggregate: "max" })
      }
    ]);
  } else if (isBinning(fieldDef.bin)) {
    if (hasDiscreteDomain(scaleType2)) {
      if (scaleType2 === "bin-ordinal") {
        return makeImplicit([]);
      }
      return makeImplicit([
        {
          // If sort by aggregation of a specified sort field, we need to use RAW table,
          // so we can aggregate values for the scale independently from the main aggregation.
          data: isBoolean3(sort3) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
          // Use range if we added it and the scale does not support computing a range as a signal.
          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: "range" } : {}),
          // we have to use a sort object if sort = true to make the sort correct by bin start
          sort: sort3 === true || !isObject(sort3) ? {
            field: model.vgField(channel, {}),
            op: "min"
            // min or max doesn't matter since we sort by the start of the bin range
          } : sort3
        }
      ]);
    } else {
      const { bin: bin3 } = fieldDef;
      if (isBinning(bin3)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin3);
        return makeImplicit([
          new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(DataSourceType.Main),
            field: model.vgField(channel, {})
          }
        ]);
      }
    }
  } else if (fieldDef.timeUnit && contains2(["time", "utc"], scaleType2) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0, model.markDef, model.config)) {
    const data3 = model.requestDataName(DataSourceType.Main);
    return makeImplicit([
      {
        data: data3,
        field: model.vgField(channel)
      },
      {
        data: data3,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  } else if (sort3) {
    return makeImplicit([
      {
        // If sort by aggregation of a specified sort field, we need to use RAW table,
        // so we can aggregate values for the scale independently from the main aggregation.
        data: isBoolean3(sort3) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
        field: model.vgField(channel),
        sort: sort3
      }
    ]);
  } else {
    return makeImplicit([
      {
        data: model.requestDataName(DataSourceType.Main),
        field: model.vgField(channel)
      }
    ]);
  }
}
function normalizeSortField(sort3, isStackedMeasure) {
  const { op, field: field3, order } = sort3;
  return Object.assign(Object.assign({
    // Apply default op
    op: op !== null && op !== void 0 ? op : isStackedMeasure ? "sum" : DEFAULT_SORT_OP
  }, field3 ? { field: replacePathInField(field3) } : {}), order ? { order } : {});
}
function parseSelectionDomain(model, channel) {
  var _a;
  const scale6 = model.component.scales[channel];
  const spec = model.specifiedScales[channel].domain;
  const bin3 = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;
  const domain4 = isParameterDomain(spec) && spec;
  const extent2 = isBinParams(bin3) && isParameterExtent(bin3.extent) && bin3.extent;
  if (domain4 || extent2) {
    scale6.set("selectionExtent", domain4 !== null && domain4 !== void 0 ? domain4 : extent2, true);
  }
}
function domainSort(model, channel, scaleType2) {
  if (!hasDiscreteDomain(scaleType2)) {
    return void 0;
  }
  const fieldDef = model.fieldDef(channel);
  const sort3 = fieldDef.sort;
  if (isSortArray(sort3)) {
    return {
      op: "min",
      field: sortArrayIndexField(fieldDef, channel),
      order: "ascending"
    };
  }
  const { stack: stack2 } = model;
  const stackDimensions = stack2 ? /* @__PURE__ */ new Set([...stack2.groupbyFields, ...stack2.stackBy.map((s) => s.fieldDef.field)]) : void 0;
  if (isSortField(sort3)) {
    const isStackedMeasure = stack2 && !stackDimensions.has(sort3.field);
    return normalizeSortField(sort3, isStackedMeasure);
  } else if (isSortByEncoding(sort3)) {
    const { encoding, order } = sort3;
    const fieldDefToSortBy = model.fieldDef(encoding);
    const { aggregate, field: field3 } = fieldDefToSortBy;
    const isStackedMeasure = stack2 && !stackDimensions.has(field3);
    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
      return normalizeSortField({
        field: vgField(fieldDefToSortBy),
        order
      }, isStackedMeasure);
    } else if (isAggregateOp(aggregate) || !aggregate) {
      return normalizeSortField({
        op: aggregate,
        field: field3,
        order
      }, isStackedMeasure);
    }
  } else if (sort3 === "descending") {
    return {
      op: "min",
      field: model.vgField(channel),
      order: "descending"
    };
  } else if (contains2([
    "ascending",
    void 0
    /* default =ascending*/
  ], sort3)) {
    return true;
  }
  return void 0;
}
function canUseUnaggregatedDomain(fieldDef, scaleType2) {
  const { aggregate, type: type3 } = fieldDef;
  if (!aggregate) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainHasNoEffectForRawField(fieldDef)
    };
  }
  if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainWithNonSharedDomainOp(aggregate)
    };
  }
  if (type3 === "quantitative") {
    if (scaleType2 === "log") {
      return {
        valid: false,
        reason: message_exports.unaggregatedDomainWithLogScale(fieldDef)
      };
    }
  }
  return { valid: true };
}
function domainsTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn2(message_exports.mergeConflictingDomainProperty(property2, propertyOf, v1.value, v2.value));
  }
  return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };
}
function mergeDomains(domains) {
  const uniqueDomains = unique(domains.map((domain4) => {
    if (isDataRefDomain(domain4)) {
      const { sort: _s } = domain4, domainWithoutSort = __rest25(domain4, ["sort"]);
      return domainWithoutSort;
    }
    return domain4;
  }), hash);
  const sorts = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      const s = d.sort;
      if (s !== void 0 && !isBoolean3(s)) {
        if ("op" in s && s.op === "count") {
          delete s.field;
        }
        if (s.order === "ascending") {
          delete s.order;
        }
      }
      return s;
    }
    return void 0;
  }).filter((s) => s !== void 0), hash);
  if (uniqueDomains.length === 0) {
    return void 0;
  } else if (uniqueDomains.length === 1) {
    const domain4 = domains[0];
    if (isDataRefDomain(domain4) && sorts.length > 0) {
      let sort4 = sorts[0];
      if (sorts.length > 1) {
        warn2(message_exports.MORE_THAN_ONE_SORT);
        sort4 = true;
      } else {
        if (isObject(sort4) && "field" in sort4) {
          const sortField = sort4.field;
          if (domain4.field === sortField) {
            sort4 = sort4.order ? { order: sort4.order } : true;
          }
        }
      }
      return Object.assign(Object.assign({}, domain4), { sort: sort4 });
    }
    return domain4;
  }
  const unionDomainSorts = unique(sorts.map((s) => {
    if (isBoolean3(s) || !("op" in s) || isString(s.op) && s.op in MULTIDOMAIN_SORT_OP_INDEX) {
      return s;
    }
    warn2(message_exports.domainSortDropped(s));
    return true;
  }), hash);
  let sort3;
  if (unionDomainSorts.length === 1) {
    sort3 = unionDomainSorts[0];
  } else if (unionDomainSorts.length > 1) {
    warn2(message_exports.MORE_THAN_ONE_SORT);
    sort3 = true;
  }
  const allData = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      return d.data;
    }
    return null;
  }), (x2) => x2);
  if (allData.length === 1 && allData[0] !== null) {
    const domain4 = Object.assign({ data: allData[0], fields: uniqueDomains.map((d) => d.field) }, sort3 ? { sort: sort3 } : {});
    return domain4;
  }
  return Object.assign({ fields: uniqueDomains }, sort3 ? { sort: sort3 } : {});
}
function getFieldFromDomain(domain4) {
  if (isDataRefDomain(domain4) && isString(domain4.field)) {
    return domain4.field;
  } else if (isDataRefUnionedDomain(domain4)) {
    let field3;
    for (const nonUnionDomain of domain4.fields) {
      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {
        if (!field3) {
          field3 = nonUnionDomain.field;
        } else if (field3 !== nonUnionDomain.field) {
          warn2(message_exports.FACETED_INDEPENDENT_DIFFERENT_SOURCES);
          return field3;
        }
      }
    }
    warn2(message_exports.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
    return field3;
  } else if (isFieldRefUnionDomain(domain4)) {
    warn2(message_exports.FACETED_INDEPENDENT_SAME_SOURCE);
    const field3 = domain4.fields[0];
    return isString(field3) ? field3 : void 0;
  }
  return void 0;
}
function assembleDomain(model, channel) {
  const scaleComponent = model.component.scales[channel];
  const domains = scaleComponent.get("domains").map((domain4) => {
    if (isDataRefDomain(domain4)) {
      domain4.data = model.lookupDataSource(domain4.data);
    }
    return domain4;
  });
  return mergeDomains(domains);
}

// node_modules/vega-lite/build/src/compile/scale/assemble.js
var __rest26 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleScales(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return model.children.reduce((scales2, child) => {
      return scales2.concat(assembleScales(child));
    }, assembleScalesForModel(model));
  } else {
    return assembleScalesForModel(model);
  }
}
function assembleScalesForModel(model) {
  return keys3(model.component.scales).reduce((scales2, channel) => {
    const scaleComponent = model.component.scales[channel];
    if (scaleComponent.merged) {
      return scales2;
    }
    const scale6 = scaleComponent.combine();
    const { name: name4, type: type3, selectionExtent, domains: _d2, range: _r2, reverse: reverse3 } = scale6, otherScaleProps = __rest26(scale6, ["name", "type", "selectionExtent", "domains", "range", "reverse"]);
    const range6 = assembleScaleRange(scale6.range, name4, channel, model);
    const domain4 = assembleDomain(model, channel);
    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain4) : null;
    scales2.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      name: name4,
      type: type3
    }, domain4 ? { domain: domain4 } : {}), domainRaw ? { domainRaw } : {}), { range: range6 }), reverse3 !== void 0 ? { reverse: reverse3 } : {}), otherScaleProps));
    return scales2;
  }, []);
}
function assembleScaleRange(scaleRange, scaleName, channel, model) {
  if (isXorY(channel)) {
    if (isVgRangeStep(scaleRange)) {
      return {
        step: { signal: `${scaleName}_step` }
      };
    }
  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {
    return Object.assign(Object.assign({}, scaleRange), { data: model.lookupDataSource(scaleRange.data) });
  }
  return scaleRange;
}

// node_modules/vega-lite/build/src/compile/scale/component.js
var ScaleComponent = class extends Split {
  constructor(name4, typeWithExplicit) {
    super(
      {},
      // no initial explicit property
      { name: name4 }
      // name as initial implicit property
    );
    this.merged = false;
    this.setWithExplicit("type", typeWithExplicit);
  }
  /**
   * Whether the scale definitely includes zero in the domain
   */
  domainDefinitelyIncludesZero() {
    if (this.get("zero") !== false) {
      return true;
    }
    return some(this.get("domains"), (d) => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);
  }
};

// node_modules/vega-lite/build/src/compile/scale/range.js
var RANGE_PROPERTIES = ["range", "scheme"];
function parseUnitScaleRange(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of SCALE_CHANNELS) {
    const localScaleCmpt = localScaleComponents[channel];
    if (!localScaleCmpt) {
      continue;
    }
    const rangeWithExplicit = parseRangeForChannel(channel, model);
    localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
  }
}
function getBinStepSignal(model, channel) {
  const fieldDef = model.fieldDef(channel);
  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {
    const { bin: bin3, field: field3 } = fieldDef;
    const sizeType = getSizeChannel(channel);
    const sizeSignal = model.getName(sizeType);
    if (isObject(bin3) && bin3.binned && bin3.step !== void 0) {
      return new SignalRefWrapper(() => {
        const scaleName = model.scaleName(channel);
        const binCount = `(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin3.step}`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    } else if (isBinning(bin3)) {
      const binSignal = getBinSignalName(model, field3, bin3);
      return new SignalRefWrapper(() => {
        const updatedName = model.getSignalName(binSignal);
        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    }
  }
  return void 0;
}
function parseRangeForChannel(channel, model) {
  const specifiedScale = model.specifiedScales[channel];
  const { size } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  for (const property2 of RANGE_PROPERTIES) {
    if (specifiedScale[property2] !== void 0) {
      const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
      const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
      if (!supportedByScaleType) {
        warn2(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn2(channelIncompatability);
      } else {
        switch (property2) {
          case "range": {
            const range6 = specifiedScale.range;
            if (isArray(range6)) {
              if (isXorY(channel)) {
                return makeExplicit(range6.map((v) => {
                  if (v === "width" || v === "height") {
                    const sizeSignal = model.getName(v);
                    const getSignalName = model.getSignalName.bind(model);
                    return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                  }
                  return v;
                }));
              }
            } else if (isObject(range6)) {
              return makeExplicit({
                data: model.requestDataName(DataSourceType.Main),
                field: range6.field,
                sort: { op: "min", field: model.vgField(channel) }
              });
            }
            return makeExplicit(range6);
          }
          case "scheme":
            return makeExplicit(parseScheme(specifiedScale[property2]));
        }
      }
    }
  }
  const sizeChannel = channel === X2 || channel === "xOffset" ? "width" : "height";
  const sizeValue = size[sizeChannel];
  if (isStep(sizeValue)) {
    if (isXorY(channel)) {
      if (hasDiscreteDomain(scaleType2)) {
        const step = getPositionStep(sizeValue, model, channel);
        if (step) {
          return makeExplicit({ step });
        }
      } else {
        warn2(message_exports.stepDropped(sizeChannel));
      }
    } else if (isXorYOffset(channel)) {
      const positionChannel = channel === XOFFSET ? "x" : "y";
      const positionScaleCmpt = model.getScaleComponent(positionChannel);
      const positionScaleType = positionScaleCmpt.get("type");
      if (positionScaleType === "band") {
        const step = getOffsetStep(sizeValue, scaleType2);
        if (step) {
          return makeExplicit(step);
        }
      }
    }
  }
  const { rangeMin: rangeMin2, rangeMax: rangeMax2 } = specifiedScale;
  const d = defaultRange(channel, model);
  if ((rangeMin2 !== void 0 || rangeMax2 !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
  scaleTypeSupportProperty(scaleType2, "rangeMin") && isArray(d) && d.length === 2) {
    return makeExplicit([rangeMin2 !== null && rangeMin2 !== void 0 ? rangeMin2 : d[0], rangeMax2 !== null && rangeMax2 !== void 0 ? rangeMax2 : d[1]]);
  }
  return makeImplicit(d);
}
function parseScheme(scheme3) {
  if (isExtendedScheme(scheme3)) {
    return Object.assign({ scheme: scheme3.name }, omit(scheme3, ["name"]));
  }
  return { scheme: scheme3 };
}
function defaultRange(channel, model) {
  const { size, config, mark: mark2, encoding } = model;
  const getSignalName = model.getSignalName.bind(model);
  const { type: type3 } = getFieldOrDatumDef(encoding[channel]);
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  const { domain: domain4, domainMid } = model.specifiedScales[channel];
  switch (channel) {
    case X2:
    case Y2: {
      if (contains2(["point", "band"], scaleType2)) {
        const positionSize = getDiscretePositionSize(channel, size, config.view);
        if (isStep(positionSize)) {
          const step = getPositionStep(positionSize, model, channel);
          return { step };
        }
      }
      const sizeType = getSizeChannel(channel);
      const sizeSignal = model.getName(sizeType);
      if (channel === Y2 && hasContinuousDomain(scaleType2)) {
        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
      } else {
        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
      }
    }
    case XOFFSET:
    case YOFFSET:
      return getOffsetRange(channel, model, scaleType2);
    case SIZE2: {
      const zero4 = model.component.scales[channel].get("zero");
      const rangeMin2 = sizeRangeMin(mark2, zero4, config);
      const rangeMax2 = sizeRangeMax(mark2, size, model, config);
      if (isContinuousToDiscrete(scaleType2)) {
        return interpolateRange2(rangeMin2, rangeMax2, defaultContinuousToDiscreteCount(scaleType2, config, domain4, channel));
      } else {
        return [rangeMin2, rangeMax2];
      }
    }
    case THETA:
      return [0, Math.PI * 2];
    case ANGLE:
      return [0, 360];
    case RADIUS: {
      return [
        0,
        new SignalRefWrapper(() => {
          const w4 = model.getSignalName("width");
          const h2 = model.getSignalName("height");
          return `min(${w4},${h2})/2`;
        })
      ];
    }
    case STROKEWIDTH:
      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
    case STROKEDASH:
      return [
        // TODO: add this to Vega's config.range?
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case SHAPE:
      return "symbol";
    case COLOR:
    case FILL:
    case STROKE:
      if (scaleType2 === "ordinal") {
        return type3 === "nominal" ? "category" : "ordinal";
      } else {
        if (domainMid !== void 0) {
          return "diverging";
        } else {
          return mark2 === "rect" || mark2 === "geoshape" ? "heatmap" : "ramp";
        }
      }
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
      return [config.scale.minOpacity, config.scale.maxOpacity];
  }
}
function getPositionStep(step, model, channel) {
  var _a, _b, _c2, _d2, _e;
  const { encoding } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const offsetChannel = getOffsetScaleChannel(channel);
  const offsetDef = encoding[offsetChannel];
  const stepFor = getStepFor({ step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete2(offsetDef.type) });
  if (stepFor === "offset" && channelHasFieldOrDatum(encoding, offsetChannel)) {
    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);
    const offsetScaleName = model.scaleName(offsetChannel);
    let stepCount = `domain('${offsetScaleName}').length`;
    if (offsetScaleCmpt.get("type") === "band") {
      const offsetPaddingInner = (_b = (_a = offsetScaleCmpt.get("paddingInner")) !== null && _a !== void 0 ? _a : offsetScaleCmpt.get("padding")) !== null && _b !== void 0 ? _b : 0;
      const offsetPaddingOuter = (_d2 = (_c2 = offsetScaleCmpt.get("paddingOuter")) !== null && _c2 !== void 0 ? _c2 : offsetScaleCmpt.get("padding")) !== null && _d2 !== void 0 ? _d2 : 0;
      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;
    }
    const paddingInner2 = (_e = mergedScaleCmpt.get("paddingInner")) !== null && _e !== void 0 ? _e : mergedScaleCmpt.get("padding");
    return {
      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner2)})`
    };
  } else {
    return step.step;
  }
}
function getOffsetStep(step, offsetScaleType) {
  const stepFor = getStepFor({ step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType) });
  if (stepFor === "offset") {
    return { step: step.step };
  }
  return void 0;
}
function getOffsetRange(channel, model, offsetScaleType) {
  const positionChannel = channel === XOFFSET ? "x" : "y";
  const positionScaleCmpt = model.getScaleComponent(positionChannel);
  const positionScaleType = positionScaleCmpt.get("type");
  const positionScaleName = model.scaleName(positionChannel);
  if (positionScaleType === "band") {
    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);
    if (isStep(size)) {
      const step = getOffsetStep(size, offsetScaleType);
      if (step) {
        return step;
      }
    }
    return [0, { signal: `bandwidth('${positionScaleName}')` }];
  } else {
    return never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);
  }
}
function getDiscretePositionSize(channel, size, viewConfig) {
  const sizeChannel = channel === X2 ? "width" : "height";
  const sizeValue = size[sizeChannel];
  if (sizeValue) {
    return sizeValue;
  }
  return getViewConfigDiscreteSize(viewConfig, sizeChannel);
}
function defaultContinuousToDiscreteCount(scaleType2, config, domain4, channel) {
  switch (scaleType2) {
    case "quantile":
      return config.scale.quantileCount;
    case "quantize":
      return config.scale.quantizeCount;
    case "threshold":
      if (domain4 !== void 0 && isArray(domain4)) {
        return domain4.length + 1;
      } else {
        warn2(message_exports.domainRequiredForThresholdScale(channel));
        return 3;
      }
  }
}
function interpolateRange2(rangeMin2, rangeMax2, cardinality) {
  const f = () => {
    const rMax = signalOrStringValue(rangeMax2);
    const rMin = signalOrStringValue(rangeMin2);
    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
  };
  if (isSignalRef(rangeMax2)) {
    return new SignalRefWrapper(f);
  } else {
    return { signal: f() };
  }
}
function sizeRangeMin(mark2, zero4, config) {
  if (zero4) {
    if (isSignalRef(zero4)) {
      return { signal: `${zero4.signal} ? 0 : ${sizeRangeMin(mark2, false, config)}` };
    } else {
      return 0;
    }
  }
  switch (mark2) {
    case "bar":
    case "tick":
      return config.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return config.scale.minStrokeWidth;
    case "text":
      return config.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return config.scale.minSize;
  }
  throw new Error(message_exports.incompatibleChannel("size", mark2));
}
var MAX_SIZE_RANGE_STEP_RATIO = 0.95;
function sizeRangeMax(mark2, size, model, config) {
  const xyStepSignals = {
    x: getBinStepSignal(model, "x"),
    y: getBinStepSignal(model, "y")
  };
  switch (mark2) {
    case "bar":
    case "tick": {
      if (config.scale.maxBandSize !== void 0) {
        return config.scale.maxBandSize;
      }
      const min4 = minXYStep(size, xyStepSignals, config.view);
      if (isNumber(min4)) {
        return min4 - 1;
      } else {
        return new SignalRefWrapper(() => `${min4.signal} - 1`);
      }
    }
    case "line":
    case "trail":
    case "rule":
      return config.scale.maxStrokeWidth;
    case "text":
      return config.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (config.scale.maxSize) {
        return config.scale.maxSize;
      }
      const pointStep = minXYStep(size, xyStepSignals, config.view);
      if (isNumber(pointStep)) {
        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
      } else {
        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
      }
    }
  }
  throw new Error(message_exports.incompatibleChannel("size", mark2));
}
function minXYStep(size, xyStepSignals, viewConfig) {
  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width");
  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
  if (xyStepSignals.x || xyStepSignals.y) {
    return new SignalRefWrapper(() => {
      const exprs = [
        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
        xyStepSignals.y ? xyStepSignals.y.signal : heightStep
      ];
      return `min(${exprs.join(", ")})`;
    });
  }
  return Math.min(widthStep, heightStep);
}

// node_modules/vega-lite/build/src/compile/scale/properties.js
function parseScaleProperty(model, property2) {
  if (isUnitModel(model)) {
    parseUnitScaleProperty(model, property2);
  } else {
    parseNonUnitScaleProperty(model, property2);
  }
}
function parseUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  const { config, encoding, markDef, specifiedScales } = model;
  for (const channel of keys3(localScaleComponents)) {
    const specifiedScale = specifiedScales[channel];
    const localScaleCmpt = localScaleComponents[channel];
    const mergedScaleCmpt = model.getScaleComponent(channel);
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    const specifiedValue = specifiedScale[property2];
    const scaleType2 = mergedScaleCmpt.get("type");
    const scalePadding = mergedScaleCmpt.get("padding");
    const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
    const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
    const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
    if (specifiedValue !== void 0) {
      if (!supportedByScaleType) {
        warn2(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn2(channelIncompatability);
      }
    }
    if (supportedByScaleType && channelIncompatability === void 0) {
      if (specifiedValue !== void 0) {
        const timeUnit = fieldOrDatumDef["timeUnit"];
        const type3 = fieldOrDatumDef.type;
        switch (property2) {
          case "domainMax":
          case "domainMin":
            if (isDateTime(specifiedScale[property2]) || type3 === "temporal" || timeUnit) {
              localScaleCmpt.set(property2, { signal: valueExpr(specifiedScale[property2], { type: type3, timeUnit }) }, true);
            } else {
              localScaleCmpt.set(property2, specifiedScale[property2], true);
            }
            break;
          default:
            localScaleCmpt.copyKeyFromObject(property2, specifiedScale);
        }
      } else {
        const value3 = property2 in scaleRules ? scaleRules[property2]({
          model,
          channel,
          fieldOrDatumDef,
          scaleType: scaleType2,
          scalePadding,
          scalePaddingInner,
          domain: specifiedScale.domain,
          domainMin: specifiedScale.domainMin,
          domainMax: specifiedScale.domainMax,
          markDef,
          config,
          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel)
        }) : config.scale[property2];
        if (value3 !== void 0) {
          localScaleCmpt.set(property2, value3, false);
        }
      }
    }
  }
}
var scaleRules = {
  bins: ({ model, fieldOrDatumDef }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
  interpolate: ({ channel, fieldOrDatumDef }) => interpolate2(channel, fieldOrDatumDef.type),
  nice: ({ scaleType: scaleType2, channel, domain: domain4, domainMin, domainMax, fieldOrDatumDef }) => nice(scaleType2, channel, domain4, domainMin, domainMax, fieldOrDatumDef),
  padding: ({ channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config }) => padding2(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
  paddingInner: ({ scalePadding, channel, markDef, scaleType: scaleType2, config, hasNestedOffsetScale }) => paddingInner(scalePadding, channel, markDef.type, scaleType2, config.scale, hasNestedOffsetScale),
  paddingOuter: ({ scalePadding, channel, scaleType: scaleType2, scalePaddingInner, config, hasNestedOffsetScale }) => paddingOuter(scalePadding, channel, scaleType2, scalePaddingInner, config.scale, hasNestedOffsetScale),
  reverse: ({ fieldOrDatumDef, scaleType: scaleType2, channel, config }) => {
    const sort3 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
    return reverse2(scaleType2, sort3, channel, config.scale);
  },
  zero: ({ channel, fieldOrDatumDef, domain: domain4, markDef, scaleType: scaleType2 }) => zero3(channel, fieldOrDatumDef, domain4, markDef, scaleType2)
};
function parseScaleRange2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleRange(model);
  } else {
    parseNonUnitScaleProperty(model, "range");
  }
}
function parseNonUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  for (const child of model.children) {
    if (property2 === "range") {
      parseScaleRange2(child);
    } else {
      parseScaleProperty(child, property2);
    }
  }
  for (const channel of keys3(localScaleComponents)) {
    let valueWithExplicit;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        const childValueWithExplicit = childComponent.getWithExplicit(property2);
        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property2, "scale", tieBreakByComparing((v1, v2) => {
          switch (property2) {
            case "range":
              if (v1.step && v2.step) {
                return v1.step - v2.step;
              }
              return 0;
          }
          return 0;
        }));
      }
    }
    localScaleComponents[channel].setWithExplicit(property2, valueWithExplicit);
  }
}
function bins(model, fieldDef) {
  const bin3 = fieldDef.bin;
  if (isBinning(bin3)) {
    const binSignal = getBinSignalName(model, fieldDef.field, bin3);
    return new SignalRefWrapper(() => {
      return model.getSignalName(binSignal);
    });
  } else if (isBinned(bin3) && isBinParams(bin3) && bin3.step !== void 0) {
    return {
      step: bin3.step
    };
  }
  return void 0;
}
function interpolate2(channel, type3) {
  if (contains2([COLOR, FILL, STROKE], channel) && type3 !== "nominal") {
    return "hcl";
  }
  return void 0;
}
function nice(scaleType2, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {
  var _a;
  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray(specifiedDomain) || domainMax != null || domainMin != null || contains2([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
    return void 0;
  }
  return isXorY(channel) ? true : void 0;
}
function padding2(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
  if (isXorY(channel)) {
    if (isContinuousToContinuous(scaleType2)) {
      if (scaleConfig.continuousPadding !== void 0) {
        return scaleConfig.continuousPadding;
      }
      const { type: type3, orient: orient2 } = markDef;
      if (type3 === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
        if (orient2 === "vertical" && channel === "x" || orient2 === "horizontal" && channel === "y") {
          return barConfig.continuousBandSize;
        }
      }
    }
    if (scaleType2 === ScaleType.POINT) {
      return scaleConfig.pointPadding;
    }
  }
  return void 0;
}
function paddingInner(paddingValue, channel, mark2, scaleType2, scaleConfig, hasNestedOffsetScale = false) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (isXorY(channel)) {
    const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, bandWithNestedOffsetPaddingInner } = scaleConfig;
    if (hasNestedOffsetScale) {
      return bandWithNestedOffsetPaddingInner;
    }
    return getFirstDefined(bandPaddingInner, mark2 === "bar" ? barBandPaddingInner : rectBandPaddingInner);
  } else if (isXorYOffset(channel)) {
    if (scaleType2 === ScaleType.BAND) {
      return scaleConfig.offsetBandPaddingInner;
    }
  }
  return void 0;
}
function paddingOuter(paddingValue, channel, scaleType2, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (isXorY(channel)) {
    const { bandPaddingOuter, bandWithNestedOffsetPaddingOuter } = scaleConfig;
    if (hasNestedOffsetScale) {
      return bandWithNestedOffsetPaddingOuter;
    }
    if (scaleType2 === ScaleType.BAND) {
      return getFirstDefined(
        bandPaddingOuter,
        /* By default, paddingOuter is paddingInner / 2. The reason is that
          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
          and we want the width/height to be integer by default.
          Note that step (by default) and cardinality are integers.) */
        isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2
      );
    }
  } else if (isXorYOffset(channel)) {
    if (scaleType2 === ScaleType.POINT) {
      return 0.5;
    } else if (scaleType2 === ScaleType.BAND) {
      return scaleConfig.offsetBandPaddingOuter;
    }
  }
  return void 0;
}
function reverse2(scaleType2, sort3, channel, scaleConfig) {
  if (channel === "x" && scaleConfig.xReverse !== void 0) {
    if (hasContinuousDomain(scaleType2) && sort3 === "descending") {
      if (isSignalRef(scaleConfig.xReverse)) {
        return { signal: `!${scaleConfig.xReverse.signal}` };
      } else {
        return !scaleConfig.xReverse;
      }
    }
    return scaleConfig.xReverse;
  }
  if (hasContinuousDomain(scaleType2) && sort3 === "descending") {
    return true;
  }
  return void 0;
}
function zero3(channel, fieldDef, specifiedDomain, markDef, scaleType2) {
  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
  if (hasCustomDomain) {
    if (hasContinuousDomain(scaleType2)) {
      if (isArray(specifiedDomain)) {
        const first = specifiedDomain[0];
        const last = specifiedDomain[specifiedDomain.length - 1];
        if (first <= 0 && last >= 0) {
          return true;
        }
      }
      return false;
    }
  }
  if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
    return true;
  }
  if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains2([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
    const { orient: orient2, type: type3 } = markDef;
    if (contains2(["bar", "area", "line", "trail"], type3)) {
      if (orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x") {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/vega-lite/build/src/compile/scale/type.js
function scaleType(specifiedScale, channel, fieldDef, mark2, hasNestedOffsetScale = false) {
  const defaultScaleType = defaultType3(channel, fieldDef, mark2, hasNestedOffsetScale);
  const { type: type3 } = specifiedScale;
  if (!isScaleChannel(channel)) {
    return null;
  }
  if (type3 !== void 0) {
    if (!channelSupportScaleType(channel, type3)) {
      warn2(message_exports.scaleTypeNotWorkWithChannel(channel, type3, defaultScaleType));
      return defaultScaleType;
    }
    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type3, fieldDef.type)) {
      warn2(message_exports.scaleTypeNotWorkWithFieldDef(type3, defaultScaleType));
      return defaultScaleType;
    }
    return type3;
  }
  return defaultScaleType;
}
function defaultType3(channel, fieldDef, mark2, hasNestedOffsetScale) {
  var _a;
  switch (fieldDef.type) {
    case "nominal":
    case "ordinal": {
      if (isColorChannel(channel) || rangeType(channel) === "discrete") {
        if (channel === "shape" && fieldDef.type === "ordinal") {
          warn2(message_exports.discreteChannelCannotEncode(channel, "ordinal"));
        }
        return "ordinal";
      }
      if (isXorY(channel) || isXorYOffset(channel)) {
        if (contains2(["rect", "bar", "image", "rule"], mark2.type)) {
          return "band";
        }
        if (hasNestedOffsetScale) {
          return "band";
        }
      } else if (mark2.type === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
        return "band";
      }
      const dimensionSize = mark2[getSizeChannel(channel)];
      if (isRelativeBandSize(dimensionSize)) {
        return "band";
      }
      if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {
        return "band";
      }
      return "point";
    }
    case "temporal":
      if (isColorChannel(channel)) {
        return "time";
      } else if (rangeType(channel) === "discrete") {
        warn2(message_exports.discreteChannelCannotEncode(channel, "temporal"));
        return "ordinal";
      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
        return "utc";
      }
      return "time";
    case "quantitative":
      if (isColorChannel(channel)) {
        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
          return "bin-ordinal";
        }
        return "linear";
      } else if (rangeType(channel) === "discrete") {
        warn2(message_exports.discreteChannelCannotEncode(channel, "quantitative"));
        return "ordinal";
      }
      return "linear";
    case "geojson":
      return void 0;
  }
  throw new Error(message_exports.invalidFieldType(fieldDef.type));
}

// node_modules/vega-lite/build/src/compile/scale/parse.js
function parseScales(model, { ignoreRange } = {}) {
  parseScaleCore(model);
  parseScaleDomain2(model);
  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
    parseScaleProperty(model, prop);
  }
  if (!ignoreRange) {
    parseScaleRange2(model);
  }
}
function parseScaleCore(model) {
  if (isUnitModel(model)) {
    model.component.scales = parseUnitScaleCore(model);
  } else {
    model.component.scales = parseNonUnitScaleCore(model);
  }
}
function parseUnitScaleCore(model) {
  const { encoding, mark: mark2, markDef } = model;
  const scaleComponents = {};
  for (const channel of SCALE_CHANNELS) {
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    if (fieldOrDatumDef && mark2 === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
      continue;
    }
    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef["scale"];
    if (isXorYOffset(channel)) {
      const mainChannel = getMainChannelFromOffsetChannel(channel);
      if (!channelHasNestedOffsetScale(encoding, mainChannel)) {
        if (specifiedScale) {
          warn2(message_exports.offsetEncodingScaleIgnored(channel));
        }
        continue;
      }
    }
    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
      specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};
      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);
      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);
      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {
        value: sType,
        explicit: specifiedScale.type === sType
      });
    }
  }
  return scaleComponents;
}
var scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
function parseNonUnitScaleCore(model) {
  var _a;
  var _b;
  const scaleComponents = model.component.scales = {};
  const scaleTypeWithExplicitIndex = {};
  const resolve2 = model.component.resolve;
  for (const child of model.children) {
    parseScaleCore(child);
    for (const channel of keys3(child.component.scales)) {
      (_a = (_b = resolve2.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);
      if (resolve2.scale[channel] === "shared") {
        const explicitScaleType = scaleTypeWithExplicitIndex[channel];
        const childScaleType = child.component.scales[channel].getWithExplicit("type");
        if (explicitScaleType) {
          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
          } else {
            resolve2.scale[channel] = "independent";
            delete scaleTypeWithExplicitIndex[channel];
          }
        } else {
          scaleTypeWithExplicitIndex[channel] = childScaleType;
        }
      }
    }
  }
  for (const channel of keys3(scaleTypeWithExplicitIndex)) {
    const name4 = model.scaleName(channel, true);
    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
    scaleComponents[channel] = new ScaleComponent(name4, typeWithExplicit);
    for (const child of model.children) {
      const childScale = child.component.scales[channel];
      if (childScale) {
        child.renameScale(childScale.get("name"), name4);
        childScale.merged = true;
      }
    }
  }
  return scaleComponents;
}

// node_modules/vega-lite/build/src/compile/model.js
var __rest27 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var NameMap = class {
  constructor() {
    this.nameMap = {};
  }
  rename(oldName, newName) {
    this.nameMap[oldName] = newName;
  }
  has(name4) {
    return this.nameMap[name4] !== void 0;
  }
  get(name4) {
    while (this.nameMap[name4] && name4 !== this.nameMap[name4]) {
      name4 = this.nameMap[name4];
    }
    return name4;
  }
};
function isUnitModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "unit";
}
function isFacetModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "facet";
}
function isConcatModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "concat";
}
function isLayerModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "layer";
}
var Model = class {
  constructor(spec, type3, parent, parentGivenName, config, resolve2, view) {
    var _a, _b;
    this.type = type3;
    this.parent = parent;
    this.config = config;
    this.correctDataNames = (mark2) => {
      var _a2, _b2, _c2;
      if ((_a2 = mark2.from) === null || _a2 === void 0 ? void 0 : _a2.data) {
        mark2.from.data = this.lookupDataSource(mark2.from.data);
      }
      if ((_c2 = (_b2 = mark2.from) === null || _b2 === void 0 ? void 0 : _b2.facet) === null || _c2 === void 0 ? void 0 : _c2.data) {
        mark2.from.facet.data = this.lookupDataSource(mark2.from.facet.data);
      }
      return mark2;
    };
    this.parent = parent;
    this.config = config;
    this.view = replaceExprRef(view);
    this.name = (_a = spec.name) !== null && _a !== void 0 ? _a : parentGivenName;
    this.title = isText(spec.title) ? { text: spec.title } : spec.title ? replaceExprRef(spec.title) : void 0;
    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
    this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
    this.data = spec.data;
    this.description = spec.description;
    this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);
    this.layout = type3 === "layer" || type3 === "unit" ? {} : extractCompositionLayout(spec, type3, config);
    this.component = {
      data: {
        sources: parent ? parent.component.data.sources : [],
        outputNodes: parent ? parent.component.data.outputNodes : {},
        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
        isFaceted: isFacetSpec(spec) || (parent === null || parent === void 0 ? void 0 : parent.component.data.isFaceted) && spec.data === void 0
      },
      layoutSize: new Split(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: Object.assign({ scale: {}, axis: {}, legend: {} }, resolve2 ? duplicate(resolve2) : {}),
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale();
    this.parseLayoutSize();
    this.renameTopLevelLayoutSizeSignal();
    this.parseSelections();
    this.parseProjection();
    this.parseData();
    this.parseAxesAndHeaders();
    this.parseLegends();
    this.parseMarkGroup();
  }
  parseScale() {
    parseScales(this);
  }
  parseProjection() {
    parseProjection2(this);
  }
  /**
   * Rename top-level spec's size to be just width / height, ignoring model name.
   * This essentially merges the top-level spec's width/height signals with the width/height signals
   * to help us reduce redundant signals declaration.
   */
  renameTopLevelLayoutSizeSignal() {
    if (this.getName("width") !== "width") {
      this.renameSignal(this.getName("width"), "width");
    }
    if (this.getName("height") !== "height") {
      this.renameSignal(this.getName("height"), "height");
    }
  }
  parseLegends() {
    parseLegend2(this);
  }
  assembleEncodeFromView(view) {
    const { style: _ } = view, baseView = __rest27(view, ["style"]);
    const e2 = {};
    for (const property2 of keys3(baseView)) {
      const value3 = baseView[property2];
      if (value3 !== void 0) {
        e2[property2] = signalOrValueRef(value3);
      }
    }
    return e2;
  }
  assembleGroupEncodeEntry(isTopLevel) {
    let encodeEntry2 = {};
    if (this.view) {
      encodeEntry2 = this.assembleEncodeFromView(this.view);
    }
    if (!isTopLevel) {
      if (this.description) {
        encodeEntry2["description"] = signalOrValueRef(this.description);
      }
      if (this.type === "unit" || this.type === "layer") {
        return Object.assign({ width: this.getSizeSignalRef("width"), height: this.getSizeSignalRef("height") }, encodeEntry2 !== null && encodeEntry2 !== void 0 ? encodeEntry2 : {});
      }
    }
    return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
  }
  assembleLayout() {
    if (!this.layout) {
      return void 0;
    }
    const _a = this.layout, { spacing } = _a, layout = __rest27(_a, ["spacing"]);
    const { component, config } = this;
    const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
    return Object.assign(Object.assign(Object.assign({ padding: spacing }, this.assembleDefaultLayout()), layout), titleBand ? { titleBand } : {});
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: layoutHeaders2 } = this.component;
    let headerMarks = [];
    for (const channel of FACET_CHANNELS) {
      if (layoutHeaders2[channel].title) {
        headerMarks.push(assembleTitleGroup(this, channel));
      }
    }
    for (const channel of HEADER_CHANNELS) {
      headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
    }
    return headerMarks;
  }
  assembleAxes() {
    return assembleAxes(this.component.axes, this.config);
  }
  assembleLegends() {
    return assembleLegends(this);
  }
  assembleProjections() {
    return assembleProjections(this);
  }
  assembleTitle() {
    var _a, _b, _c2;
    const _d2 = (_a = this.title) !== null && _a !== void 0 ? _a : {}, { encoding } = _d2, titleNoEncoding = __rest27(_d2, ["encoding"]);
    const title2 = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMarkTitleProperties), titleNoEncoding), encoding ? { encode: { update: encoding } } : {});
    if (title2.text) {
      if (contains2(["unit", "layer"], this.type)) {
        if (contains2(["middle", void 0], title2.anchor)) {
          (_b = title2.frame) !== null && _b !== void 0 ? _b : title2.frame = "group";
        }
      } else {
        (_c2 = title2.anchor) !== null && _c2 !== void 0 ? _c2 : title2.anchor = "start";
      }
      return isEmpty(title2) ? void 0 : title2;
    }
    return void 0;
  }
  /**
   * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
   */
  assembleGroup(signals = []) {
    const group2 = {};
    signals = signals.concat(this.assembleSignals());
    if (signals.length > 0) {
      group2.signals = signals;
    }
    const layout = this.assembleLayout();
    if (layout) {
      group2.layout = layout;
    }
    group2.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const scales2 = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
    if (scales2.length > 0) {
      group2.scales = scales2;
    }
    const axes = this.assembleAxes();
    if (axes.length > 0) {
      group2.axes = axes;
    }
    const legends = this.assembleLegends();
    if (legends.length > 0) {
      group2.legends = legends;
    }
    return group2;
  }
  getName(text4) {
    return varName((this.name ? `${this.name}_` : "") + text4);
  }
  getDataName(type3) {
    return this.getName(DataSourceType[type3].toLowerCase());
  }
  /**
   * Request a data source name for the given data source type and mark that data source as required.
   * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
   * You can lookup the correct dataset name in assemble with `lookupDataSource`.
   */
  requestDataName(name4) {
    const fullName = this.getDataName(name4);
    const refCounts = this.component.data.outputNodeRefCounts;
    refCounts[fullName] = (refCounts[fullName] || 0) + 1;
    return fullName;
  }
  getSizeSignalRef(layoutSizeType) {
    if (isFacetModel(this.parent)) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
      const channel = getPositionScaleChannel(sizeType);
      const scaleComponent = this.component.scales[channel];
      if (scaleComponent && !scaleComponent.merged) {
        const type3 = scaleComponent.get("type");
        const range6 = scaleComponent.get("range");
        if (hasDiscreteDomain(type3) && isVgRangeStep(range6)) {
          const scaleName = scaleComponent.get("name");
          const domain4 = assembleDomain(this, channel);
          const field3 = getFieldFromDomain(domain4);
          if (field3) {
            const fieldRef2 = vgField({ aggregate: "distinct", field: field3 }, { expr: "datum" });
            return {
              signal: sizeExpr(scaleName, scaleComponent, fieldRef2)
            };
          } else {
            warn2(message_exports.unknownField(channel));
            return null;
          }
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(layoutSizeType))
    };
  }
  /**
   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
   */
  lookupDataSource(name4) {
    const node = this.component.data.outputNodes[name4];
    if (!node) {
      return name4;
    }
    return node.getSource();
  }
  getSignalName(oldSignalName) {
    return this.signalNameMap.get(oldSignalName);
  }
  renameSignal(oldName, newName) {
    this.signalNameMap.rename(oldName, newName);
  }
  renameScale(oldName, newName) {
    this.scaleNameMap.rename(oldName, newName);
  }
  renameProjection(oldName, newName) {
    this.projectionNameMap.rename(oldName, newName);
  }
  /**
   * @return scale name for a given channel after the scale has been parsed and named.
   */
  scaleName(originalScaleName, parse7) {
    if (parse7) {
      return this.getName(originalScaleName);
    }
    if (
      // If there is a scale for the channel, there should be a local scale component for it
      isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || // in the scale name map (the scale get merged by its parent)
      this.scaleNameMap.has(this.getName(originalScaleName))
    ) {
      return this.scaleNameMap.get(this.getName(originalScaleName));
    }
    return void 0;
  }
  /**
   * @return projection name after the projection has been parsed and named.
   */
  projectionName(parse7) {
    if (parse7) {
      return this.getName("projection");
    }
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
      return this.projectionNameMap.get(this.getName("projection"));
    }
    return void 0;
  }
  /**
   * Traverse a model's hierarchy to get the scale component for a particular channel.
   */
  getScaleComponent(channel) {
    if (!this.component.scales) {
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    }
    const localScaleComponent = this.component.scales[channel];
    if (localScaleComponent && !localScaleComponent.merged) {
      return localScaleComponent;
    }
    return this.parent ? this.parent.getScaleComponent(channel) : void 0;
  }
  /**
   * Traverse a model's hierarchy to get a particular selection component.
   */
  getSelectionComponent(variableName, origName) {
    let sel = this.component.selection[variableName];
    if (!sel && this.parent) {
      sel = this.parent.getSelectionComponent(variableName, origName);
    }
    if (!sel) {
      throw new Error(message_exports.selectionNotFound(origName));
    }
    return sel;
  }
  /**
   * Returns true if the model has a signalRef for an axis orient.
   */
  hasAxisOrientSignalRef() {
    var _a, _b;
    return ((_a = this.component.axes.x) === null || _a === void 0 ? void 0 : _a.some((a) => a.hasOrientSignalRef())) || ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some((a) => a.hasOrientSignalRef()));
  }
};
var ModelWithField = class extends Model {
  /** Get "field" reference for Vega */
  vgField(channel, opt = {}) {
    const fieldDef = this.fieldDef(channel);
    if (!fieldDef) {
      return void 0;
    }
    return vgField(fieldDef, opt);
  }
  reduceFieldDef(f, init2) {
    return reduce(this.getMapping(), (acc, cd, c) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        return f(acc, fieldDef, c);
      }
      return acc;
    }, init2);
  }
  forEachFieldDef(f, t2) {
    forEach(this.getMapping(), (cd, c) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        f(fieldDef, c);
      }
    }, t2);
  }
};

// node_modules/vega-lite/build/src/compile/data/density.js
var __rest28 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var DensityTransformNode = class _DensityTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "value", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "density"];
    if (transform4.groupby && transform4.minsteps == null && transform4.maxsteps == null && transform4.steps == null) {
      this.transform.steps = 200;
    }
  }
  clone() {
    return new _DensityTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.density, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { density } = _a, rest = __rest28(_a, ["density"]);
    const result = Object.assign({ type: "kde", field: density }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/filterinvalid.js
var FilterInvalidNode = class _FilterInvalidNode extends DataFlowNode {
  constructor(parent, filter3) {
    super(parent);
    this.filter = filter3;
  }
  clone() {
    return new _FilterInvalidNode(null, Object.assign({}, this.filter));
  }
  static make(parent, model) {
    const { config, mark: mark2, markDef } = model;
    const invalid = getMarkPropOrConfig("invalid", markDef, config);
    if (invalid !== "filter") {
      return null;
    }
    const filter3 = model.reduceFieldDef((aggregator, fieldDef, channel) => {
      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
      if (scaleComponent) {
        const scaleType2 = scaleComponent.get("type");
        if (hasContinuousDomain(scaleType2) && fieldDef.aggregate !== "count" && !isPathMark(mark2)) {
          aggregator[fieldDef.field] = fieldDef;
        }
      }
      return aggregator;
    }, {});
    if (!keys3(filter3).length) {
      return null;
    }
    return new _FilterInvalidNode(parent, filter3);
  }
  dependentFields() {
    return new Set(keys3(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${hash(this.filter)}`;
  }
  /**
   * Create the VgTransforms for each of the filtered fields.
   */
  assemble() {
    const filters2 = keys3(this.filter).reduce((vegaFilters, field3) => {
      const fieldDef = this.filter[field3];
      const ref2 = vgField(fieldDef, { expr: "datum" });
      if (fieldDef !== null) {
        if (fieldDef.type === "temporal") {
          vegaFilters.push(`(isDate(${ref2}) || (isValid(${ref2}) && isFinite(+${ref2})))`);
        } else if (fieldDef.type === "quantitative") {
          vegaFilters.push(`isValid(${ref2})`);
          vegaFilters.push(`isFinite(+${ref2})`);
        } else {
        }
      }
      return vegaFilters;
    }, []);
    return filters2.length > 0 ? {
      type: "filter",
      expr: filters2.join(" && ")
    } : null;
  }
};

// node_modules/vega-lite/build/src/compile/data/flatten.js
var FlattenTransformNode = class _FlattenTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const { flatten, as = [] } = this.transform;
    this.transform.as = flatten.map((f, i) => {
      var _a;
      return (_a = as[i]) !== null && _a !== void 0 ? _a : f;
    });
  }
  clone() {
    return new _FlattenTransformNode(this.parent, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { flatten: fields, as } = this.transform;
    const result = {
      type: "flatten",
      fields,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/fold.js
var FoldTransformNode = class _FoldTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "key", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "value"];
  }
  clone() {
    return new _FoldTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { fold, as } = this.transform;
    const result = {
      type: "fold",
      fields: fold,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/geojson.js
var GeoJSONNode = class _GeoJSONNode extends DataFlowNode {
  constructor(parent, fields, geojson, signal) {
    super(parent);
    this.fields = fields;
    this.geojson = geojson;
    this.signal = signal;
  }
  clone() {
    return new _GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
  }
  static parseAll(parent, model) {
    if (model.component.projection && !model.component.projection.isFit) {
      return parent;
    }
    let geoJsonCounter = 0;
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def2 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? { expr: `${def2.datum}` } : isValueDef(def2) ? { expr: `${def2["value"]}` } : void 0;
      });
      if (pair[0] || pair[1]) {
        parent = new _GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    if (model.channelHasField(SHAPE)) {
      const fieldDef = model.typedFieldDef(SHAPE);
      if (fieldDef.type === GEOJSON) {
        parent = new _GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    return parent;
  }
  dependentFields() {
    var _a;
    const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...fields]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      Object.assign(Object.assign(Object.assign({ type: "geojson" }, this.fields ? { fields: this.fields } : {}), this.geojson ? { geojson: this.geojson } : {}), { signal: this.signal })
    ];
  }
};

// node_modules/vega-lite/build/src/compile/data/geopoint.js
var GeoPointNode = class _GeoPointNode extends DataFlowNode {
  constructor(parent, projection3, fields, as) {
    super(parent);
    this.projection = projection3;
    this.fields = fields;
    this.as = as;
  }
  clone() {
    return new _GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
  }
  static parseAll(parent, model) {
    if (!model.projectionName()) {
      return parent;
    }
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def2 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? { expr: `${def2.datum}` } : isValueDef(def2) ? { expr: `${def2["value"]}` } : void 0;
      });
      const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
      if (pair[0] || pair[1]) {
        parent = new _GeoPointNode(parent, model.projectionName(), pair, [
          model.getName(`x${suffix}`),
          model.getName(`y${suffix}`)
        ]);
      }
    }
    return parent;
  }
  dependentFields() {
    return new Set(this.fields.filter(isString));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
};

// node_modules/vega-lite/build/src/compile/data/impute.js
var ImputeNode = class _ImputeNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new _ImputeNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(keyvals) {
    const { start = 0, stop: stop3, step } = keyvals;
    const result = [start, stop3, ...step ? [step] : []].join(",");
    return { signal: `sequence(${result})` };
  }
  static makeFromTransform(parent, imputeTransform) {
    return new _ImputeNode(parent, imputeTransform);
  }
  static makeFromEncoding(parent, model) {
    const encoding = model.encoding;
    const xDef = encoding.x;
    const yDef = encoding.y;
    if (isFieldDef(xDef) && isFieldDef(yDef)) {
      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
      if (imputedChannel === void 0) {
        return void 0;
      }
      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
      const { method: method2, value: value3, frame, keyvals } = imputedChannel.impute;
      const groupbyFields = pathGroupingFields(model.mark, encoding);
      return new _ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, method2 ? { method: method2 } : {}), value3 !== void 0 ? { value: value3 } : {}), frame ? { frame } : {}), keyvals !== void 0 ? { keyvals } : {}), groupbyFields.length ? { groupby: groupbyFields } : {}));
    }
    return null;
  }
  hash() {
    return `Impute ${hash(this.transform)}`;
  }
  assemble() {
    const { impute, key: key2, keyvals, method: method2, groupby, value: value3, frame = [null, null] } = this.transform;
    const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: "impute", field: impute, key: key2 }, keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {}), { method: "value" }), groupby ? { groupby } : {}), { value: !method2 || method2 === "value" ? value3 : null });
    if (method2 && method2 !== "value") {
      const deriveNewField = Object.assign({ type: "window", as: [`imputed_${impute}_value`], ops: [method2], fields: [impute], frame, ignorePeers: false }, groupby ? { groupby } : {});
      const replaceOriginal = {
        type: "formula",
        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
        as: impute
      };
      return [imputeTransform, deriveNewField, replaceOriginal];
    } else {
      return [imputeTransform];
    }
  }
};

// node_modules/vega-lite/build/src/compile/data/loess.js
var __rest29 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var LoessTransformNode = class _LoessTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform4.on, (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : transform4.loess];
  }
  clone() {
    return new _LoessTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { loess: loess2, on: on2 } = _a, rest = __rest29(_a, ["loess", "on"]);
    const result = Object.assign({ type: "loess", x: on2, y: loess2 }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/lookup.js
var LookupNode = class _LookupNode extends DataFlowNode {
  constructor(parent, transform4, secondary) {
    super(parent);
    this.transform = transform4;
    this.secondary = secondary;
  }
  clone() {
    return new _LookupNode(null, duplicate(this.transform), this.secondary);
  }
  static make(parent, model, transform4, counter) {
    const sources = model.component.data.sources;
    const { from } = transform4;
    let fromOutputNode = null;
    if (isLookupData(from)) {
      let fromSource = findSource(from.data, sources);
      if (!fromSource) {
        fromSource = new SourceNode(from.data);
        sources.push(fromSource);
      }
      const fromOutputName = model.getName(`lookup_${counter}`);
      fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
      model.component.data.outputNodes[fromOutputName] = fromOutputNode;
    } else if (isLookupSelection(from)) {
      const selName = from.param;
      transform4 = Object.assign({ as: selName }, transform4);
      let selCmpt;
      try {
        selCmpt = model.getSelectionComponent(varName(selName), selName);
      } catch (e2) {
        throw new Error(message_exports.cannotLookupVariableParameter(selName));
      }
      fromOutputNode = selCmpt.materialized;
      if (!fromOutputNode) {
        throw new Error(message_exports.noSameUnitLookup(selName));
      }
    }
    return new _LookupNode(parent, transform4, fromOutputNode.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let foreign;
    if (this.transform.from.fields) {
      foreign = Object.assign({ values: this.transform.from.fields }, this.transform.as ? { as: array(this.transform.as) } : {});
    } else {
      let asName = this.transform.as;
      if (!isString(asName)) {
        warn2(message_exports.NO_FIELDS_NEEDS_AS);
        asName = "_lookup";
      }
      foreign = {
        as: [asName]
      };
    }
    return Object.assign(Object.assign({ type: "lookup", from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, foreign), this.transform.default ? { default: this.transform.default } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/quantile.js
var __rest30 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var QuantileTransformNode = class _QuantileTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "prob", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "value"];
  }
  clone() {
    return new _QuantileTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.quantile, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { quantile: quantile3 } = _a, rest = __rest30(_a, ["quantile"]);
    const result = Object.assign({ type: "quantile", field: quantile3 }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/regression.js
var __rest31 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var RegressionTransformNode = class _RegressionTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    var _a, _b, _c2;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform4.on, (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : transform4.regression];
  }
  clone() {
    return new _RegressionTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { regression, on: on2 } = _a, rest = __rest31(_a, ["regression", "on"]);
    const result = Object.assign({ type: "regression", x: on2, y: regression }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/pivot.js
var PivotTransformNode = class _PivotTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new _PivotTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    var _a;
    this.transform.groupby = unique(((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).concat(fields), (d) => d);
  }
  producedFields() {
    return void 0;
  }
  dependentFields() {
    var _a;
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  hash() {
    return `PivotTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { pivot, value: value3, groupby, limit, op } = this.transform;
    return Object.assign(Object.assign(Object.assign({ type: "pivot", field: pivot, value: value3 }, limit !== void 0 ? { limit } : {}), op !== void 0 ? { op } : {}), groupby !== void 0 ? { groupby } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/sample.js
var SampleTransformNode = class _SampleTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new _SampleTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${hash(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
};

// node_modules/vega-lite/build/src/compile/data/assemble.js
function makeWalkTree(data3) {
  let datasetIndex = 0;
  function walkTree(node, dataSource) {
    var _a;
    if (node instanceof SourceNode) {
      if (!node.isGenerator && !isUrlData(node.data)) {
        data3.push(dataSource);
        const newData = {
          name: null,
          source: dataSource.name,
          transform: []
        };
        dataSource = newData;
      }
    }
    if (node instanceof ParseNode) {
      if (node.parent instanceof SourceNode && !dataSource.source) {
        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), { parse: node.assembleFormatParse() });
        dataSource.transform.push(...node.assembleTransforms(true));
      } else {
        dataSource.transform.push(...node.assembleTransforms());
      }
    }
    if (node instanceof FacetNode) {
      if (!dataSource.name) {
        dataSource.name = `data_${datasetIndex++}`;
      }
      if (!dataSource.source || dataSource.transform.length > 0) {
        data3.push(dataSource);
        node.data = dataSource.name;
      } else {
        node.data = dataSource.source;
      }
      data3.push(...node.assemble());
      return;
    }
    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {
      dataSource.transform.push(node.assemble());
    }
    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {
      dataSource.transform.push(...node.assemble());
    }
    if (node instanceof OutputNode) {
      if (dataSource.source && dataSource.transform.length === 0) {
        node.setSource(dataSource.source);
      } else if (node.parent instanceof OutputNode) {
        node.setSource(dataSource.name);
      } else {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        node.setSource(dataSource.name);
        if (node.numChildren() === 1) {
          data3.push(dataSource);
          const newData = {
            name: null,
            source: dataSource.name,
            transform: []
          };
          dataSource = newData;
        }
      }
    }
    switch (node.numChildren()) {
      case 0:
        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
          data3.push(dataSource);
        }
        break;
      case 1:
        walkTree(node.children[0], dataSource);
        break;
      default: {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        let source4 = dataSource.name;
        if (!dataSource.source || dataSource.transform.length > 0) {
          data3.push(dataSource);
        } else {
          source4 = dataSource.source;
        }
        for (const child of node.children) {
          const newData = {
            name: null,
            source: source4,
            transform: []
          };
          walkTree(child, newData);
        }
        break;
      }
    }
  }
  return walkTree;
}
function assembleFacetData(root) {
  const data3 = [];
  const walkTree = makeWalkTree(data3);
  for (const child of root.children) {
    walkTree(child, {
      source: root.name,
      name: null,
      transform: []
    });
  }
  return data3;
}
function assembleRootData(dataComponent, datasets) {
  var _a, _b;
  const data3 = [];
  const walkTree = makeWalkTree(data3);
  let sourceIndex = 0;
  for (const root of dataComponent.sources) {
    if (!root.hasName()) {
      root.dataName = `source_${sourceIndex++}`;
    }
    const newData = root.assemble();
    walkTree(root, newData);
  }
  for (const d of data3) {
    if (d.transform.length === 0) {
      delete d.transform;
    }
  }
  let whereTo = 0;
  for (const [i, d] of data3.entries()) {
    if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {
      data3.splice(whereTo++, 0, data3.splice(i, 1)[0]);
    }
  }
  for (const d of data3) {
    for (const t2 of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {
      if (t2.type === "lookup") {
        t2.from = dataComponent.outputNodes[t2.from].getSource();
      }
    }
  }
  for (const d of data3) {
    if (d.name in datasets) {
      d.values = datasets[d.name];
    }
  }
  return data3;
}

// node_modules/vega-lite/build/src/compile/header/parse.js
function getHeaderType(orient2) {
  if (orient2 === "top" || orient2 === "left" || isSignalRef(orient2)) {
    return "header";
  }
  return "footer";
}
function parseFacetHeaders(model) {
  for (const channel of FACET_CHANNELS) {
    parseFacetHeader(model, channel);
  }
  mergeChildAxis(model, "x");
  mergeChildAxis(model, "y");
}
function parseFacetHeader(model, channel) {
  var _a;
  const { facet, config, child, component } = model;
  if (model.channelHasField(channel)) {
    const fieldDef = facet[channel];
    const titleConfig = getHeaderProperty("title", null, config, channel);
    let title2 = title(fieldDef, config, {
      allowDisabling: true,
      includeDefault: titleConfig === void 0 || !!titleConfig
    });
    if (child.component.layoutHeaders[channel].title) {
      title2 = isArray(title2) ? title2.join(", ") : title2;
      title2 += ` / ${child.component.layoutHeaders[channel].title}`;
      child.component.layoutHeaders[channel].title = null;
    }
    const labelOrient = getHeaderProperty("labelOrient", fieldDef.header, config, channel);
    const labels3 = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;
    const headerType = contains2(["bottom", "right"], labelOrient) ? "footer" : "header";
    component.layoutHeaders[channel] = {
      title: fieldDef.header !== null ? title2 : null,
      facetFieldDef: fieldDef,
      [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels3)]
    };
  }
}
function makeHeaderComponent(model, channel, labels3) {
  const sizeType = channel === "row" ? "height" : "width";
  return {
    labels: labels3,
    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
    axes: []
  };
}
function mergeChildAxis(model, channel) {
  var _a;
  const { child } = model;
  if (child.component.axes[channel]) {
    const { layoutHeaders: layoutHeaders2, resolve: resolve2 } = model.component;
    resolve2.axis[channel] = parseGuideResolve(resolve2, channel);
    if (resolve2.axis[channel] === "shared") {
      const headerChannel = channel === "x" ? "column" : "row";
      const layoutHeader = layoutHeaders2[headerChannel];
      for (const axisComponent of child.component.axes[channel]) {
        const headerType = getHeaderType(axisComponent.get("orient"));
        (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)];
        const mainAxis = assembleAxis(axisComponent, "main", model.config, { header: true });
        if (mainAxis) {
          layoutHeader[headerType][0].axes.push(mainAxis);
        }
        axisComponent.mainExtracted = true;
      }
    } else {
    }
  }
}

// node_modules/vega-lite/build/src/compile/layoutsize/parse.js
function parseLayerLayoutSize(model) {
  parseChildrenLayoutSize(model);
  parseNonUnitLayoutSizeForChannel(model, "width");
  parseNonUnitLayoutSizeForChannel(model, "height");
}
function parseConcatLayoutSize(model) {
  parseChildrenLayoutSize(model);
  const widthType = model.layout.columns === 1 ? "width" : "childWidth";
  const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
  parseNonUnitLayoutSizeForChannel(model, widthType);
  parseNonUnitLayoutSizeForChannel(model, heightType);
}
function parseChildrenLayoutSize(model) {
  for (const child of model.children) {
    child.parseLayoutSize();
  }
}
function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
  var _a;
  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
  const channel = getPositionScaleChannel(sizeType);
  const resolve2 = model.component.resolve;
  const layoutSizeCmpt = model.component.layoutSize;
  let mergedSize;
  for (const child of model.children) {
    const childSize = child.component.layoutSize.getWithExplicit(sizeType);
    const scaleResolve = (_a = resolve2.scale[channel]) !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model);
    if (scaleResolve === "independent" && childSize.value === "step") {
      mergedSize = void 0;
      break;
    }
    if (mergedSize) {
      if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
        mergedSize = void 0;
        break;
      }
      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
    } else {
      mergedSize = childSize;
    }
  }
  if (mergedSize) {
    for (const child of model.children) {
      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
      child.component.layoutSize.set(sizeType, "merged", false);
    }
    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
  } else {
    layoutSizeCmpt.setWithExplicit(layoutSizeType, {
      explicit: false,
      value: void 0
    });
  }
}
function parseUnitLayoutSize(model) {
  const { size, component } = model;
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (size[sizeType]) {
      const specifiedSize = size[sizeType];
      component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
    } else {
      const defaultSize2 = defaultUnitSize(model, sizeType);
      component.layoutSize.set(sizeType, defaultSize2, false);
    }
  }
}
function defaultUnitSize(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const config = model.config;
  const scaleComponent = model.getScaleComponent(channel);
  if (scaleComponent) {
    const scaleType2 = scaleComponent.get("type");
    const range6 = scaleComponent.get("range");
    if (hasDiscreteDomain(scaleType2)) {
      const size = getViewConfigDiscreteSize(config.view, sizeType);
      if (isVgRangeStep(range6) || isStep(size)) {
        return "step";
      } else {
        return size;
      }
    } else {
      return getViewConfigContinuousSize(config.view, sizeType);
    }
  } else if (model.hasProjection || model.mark === "arc") {
    return getViewConfigContinuousSize(config.view, sizeType);
  } else {
    const size = getViewConfigDiscreteSize(config.view, sizeType);
    return isStep(size) ? size.step : size;
  }
}

// node_modules/vega-lite/build/src/compile/facet.js
function facetSortFieldName(fieldDef, sort3, opt) {
  return vgField(sort3, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, opt !== null && opt !== void 0 ? opt : {}));
}
var FacetModel = class _FacetModel extends ModelWithField {
  constructor(spec, parent, parentGivenName, config) {
    super(spec, "facet", parent, parentGivenName, config, spec.resolve);
    this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
    this.children = [this.child];
    this.facet = this.initFacet(spec.facet);
  }
  initFacet(facet) {
    if (!isFacetMapping(facet)) {
      return { facet: this.initFacetFieldDef(facet, "facet") };
    }
    const channels = keys3(facet);
    const normalizedFacet = {};
    for (const channel of channels) {
      if (![ROW, COLUMN].includes(channel)) {
        warn2(message_exports.incompatibleChannel(channel, "facet"));
        break;
      }
      const fieldDef = facet[channel];
      if (fieldDef.field === void 0) {
        warn2(message_exports.emptyFieldDef(fieldDef, channel));
        break;
      }
      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);
    }
    return normalizedFacet;
  }
  initFacetFieldDef(fieldDef, channel) {
    const facetFieldDef = initFieldDef(fieldDef, channel);
    if (facetFieldDef.header) {
      facetFieldDef.header = replaceExprRef(facetFieldDef.header);
    } else if (facetFieldDef.header === null) {
      facetFieldDef.header = null;
    }
    return facetFieldDef;
  }
  channelHasField(channel) {
    return !!this.facet[channel];
  }
  fieldDef(channel) {
    return this.facet[channel];
  }
  parseData() {
    this.component.data = parseData2(this);
    this.child.parseData();
  }
  parseLayoutSize() {
    parseChildrenLayoutSize(this);
  }
  parseSelections() {
    this.child.parseSelections();
    this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders();
    parseFacetHeaders(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.child.assembleSelectionTopLevelSignals(signals);
  }
  assembleSignals() {
    this.child.assembleSignals();
    return [];
  }
  assembleSelectionData(data3) {
    return this.child.assembleSelectionData(data3);
  }
  getHeaderLayoutMixins() {
    var _a, _b, _c2;
    const layoutMixins = {};
    for (const channel of FACET_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const layoutHeaderComponent = this.component.layoutHeaders[channel];
        const headerComponent = layoutHeaderComponent[headerType];
        const { facetFieldDef } = layoutHeaderComponent;
        if (facetFieldDef) {
          const titleOrient = getHeaderProperty("titleOrient", facetFieldDef.header, this.config, channel);
          if (["right", "bottom"].includes(titleOrient)) {
            const headerChannel = getHeaderChannel(channel, titleOrient);
            (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};
            layoutMixins.titleAnchor[headerChannel] = "end";
          }
        }
        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {
          const sizeType = channel === "row" ? "height" : "width";
          const bandType = headerType === "header" ? "headerBand" : "footerBand";
          if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
            (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};
            layoutMixins[bandType][channel] = 0.5;
          }
          if (layoutHeaderComponent.title) {
            (_c2 = layoutMixins.offset) !== null && _c2 !== void 0 ? _c2 : layoutMixins.offset = {};
            layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
          }
        }
      }
    }
    return layoutMixins;
  }
  assembleDefaultLayout() {
    const { column, row } = this.facet;
    const columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
    let align2 = "all";
    if (!row && this.component.resolve.scale.x === "independent") {
      align2 = "none";
    } else if (!column && this.component.resolve.scale.y === "independent") {
      align2 = "none";
    }
    return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? { columns } : {}), { bounds: "full", align: align2 });
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (this.parent && this.parent instanceof _FacetModel) {
      return void 0;
    } else {
      const facetLayoutDataName = this.getName("column_domain");
      return { signal: `length(data('${facetLayoutDataName}'))` };
    }
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleGroup(signals) {
    if (this.parent && this.parent instanceof _FacetModel) {
      return Object.assign(Object.assign({}, this.channelHasField("column") ? {
        encode: {
          update: {
            // TODO(https://github.com/vega/vega-lite/issues/2759):
            // Correct the signal for facet of concat of facet_column
            columns: { field: vgField(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {}), super.assembleGroup(signals));
    }
    return super.assembleGroup(signals);
  }
  /**
   * Aggregate cardinality for calculating size
   */
  getCardinalityAggregateForChild() {
    const fields = [];
    const ops2 = [];
    const as = [];
    if (this.child instanceof _FacetModel) {
      if (this.child.channelHasField("column")) {
        const field3 = vgField(this.child.facet.column);
        fields.push(field3);
        ops2.push("distinct");
        as.push(`distinct_${field3}`);
      }
    } else {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const childScaleComponent = this.child.component.scales[channel];
        if (childScaleComponent && !childScaleComponent.merged) {
          const type3 = childScaleComponent.get("type");
          const range6 = childScaleComponent.get("range");
          if (hasDiscreteDomain(type3) && isVgRangeStep(range6)) {
            const domain4 = assembleDomain(this.child, channel);
            const field3 = getFieldFromDomain(domain4);
            if (field3) {
              fields.push(field3);
              ops2.push("distinct");
              as.push(`distinct_${field3}`);
            } else {
              warn2(message_exports.unknownField(channel));
            }
          }
        }
      }
    }
    return { fields, ops: ops2, as };
  }
  assembleFacet() {
    const { name: name4, data: data3 } = this.component.data.facetRoot;
    const { row, column } = this.facet;
    const { fields, ops: ops2, as } = this.getCardinalityAggregateForChild();
    const groupby = [];
    for (const channel of FACET_CHANNELS) {
      const fieldDef = this.facet[channel];
      if (fieldDef) {
        groupby.push(vgField(fieldDef));
        const { bin: bin3, sort: sort3 } = fieldDef;
        if (isBinning(bin3)) {
          groupby.push(vgField(fieldDef, { binSuffix: "end" }));
        }
        if (isSortField(sort3)) {
          const { field: field3, op = DEFAULT_SORT_OP } = sort3;
          const outputName = facetSortFieldName(fieldDef, sort3);
          if (row && column) {
            fields.push(outputName);
            ops2.push("max");
            as.push(outputName);
          } else {
            fields.push(field3);
            ops2.push(op);
            as.push(outputName);
          }
        } else if (isArray(sort3)) {
          const outputName = sortArrayIndexField(fieldDef, channel);
          fields.push(outputName);
          ops2.push("max");
          as.push(outputName);
        }
      }
    }
    const cross2 = !!row && !!column;
    return Object.assign({
      name: name4,
      data: data3,
      groupby
    }, cross2 || fields.length > 0 ? {
      aggregate: Object.assign(Object.assign({}, cross2 ? { cross: cross2 } : {}), fields.length ? { fields, ops: ops2, as } : {})
    } : {});
  }
  facetSortFields(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      if (isSortField(fieldDef.sort)) {
        return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: "datum" })];
      } else if (isArray(fieldDef.sort)) {
        return [sortArrayIndexField(fieldDef, channel, { expr: "datum" })];
      }
      return [vgField(fieldDef, { expr: "datum" })];
    }
    return [];
  }
  facetSortOrder(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      const { sort: sort3 } = fieldDef;
      const order = (isSortField(sort3) ? sort3.order : !isArray(sort3) && sort3) || "ascending";
      return [order];
    }
    return [];
  }
  assembleLabelTitle() {
    var _a;
    const { facet, config } = this;
    if (facet.facet) {
      return assembleLabelTitle(facet.facet, "facet", config);
    }
    const ORTHOGONAL_ORIENT = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const channel of HEADER_CHANNELS) {
      if (facet[channel]) {
        const labelOrient = getHeaderProperty("labelOrient", (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);
        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {
          return assembleLabelTitle(facet[channel], channel, config);
        }
      }
    }
    return void 0;
  }
  assembleMarks() {
    const { child } = this;
    const facetRoot = this.component.data.facetRoot;
    const data3 = assembleFacetData(facetRoot);
    const encodeEntry2 = child.assembleGroupEncodeEntry(false);
    const title2 = this.assembleLabelTitle() || child.assembleTitle();
    const style2 = child.assembleGroupStyle();
    const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName("cell"), type: "group" }, title2 ? { title: title2 } : {}), style2 ? { style: style2 } : {}), {
      from: {
        facet: this.assembleFacet()
      },
      // TODO: move this to after data
      sort: {
        field: FACET_CHANNELS.map((c) => this.facetSortFields(c)).flat(),
        order: FACET_CHANNELS.map((c) => this.facetSortOrder(c)).flat()
      }
    }), data3.length > 0 ? { data: data3 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup(assembleFacetSignals(this, [])));
    return [markGroup];
  }
  getMapping() {
    return this.facet;
  }
};

// node_modules/vega-lite/build/src/compile/data/joinaggregatefacet.js
function makeJoinAggregateFromFacet(parent, facet) {
  const { row, column } = facet;
  if (row && column) {
    let newParent = null;
    for (const fieldDef of [row, column]) {
      if (isSortField(fieldDef.sort)) {
        const { field: field3, op = DEFAULT_SORT_OP } = fieldDef.sort;
        parent = newParent = new JoinAggregateTransformNode(parent, {
          joinaggregate: [
            {
              op,
              field: field3,
              as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })
            }
          ],
          groupby: [vgField(fieldDef)]
        });
      }
    }
    return newParent;
  }
  return null;
}

// node_modules/vega-lite/build/src/compile/data/parse.js
function findSource(data3, sources) {
  var _a, _b, _c2, _d2;
  for (const other of sources) {
    const otherData = other.data;
    if (data3.name && other.hasName() && data3.name !== other.dataName) {
      continue;
    }
    const formatMesh = (_a = data3["format"]) === null || _a === void 0 ? void 0 : _a.mesh;
    const otherFeature = (_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature;
    if (formatMesh && otherFeature) {
      continue;
    }
    const formatFeature = (_c2 = data3["format"]) === null || _c2 === void 0 ? void 0 : _c2.feature;
    if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {
      continue;
    }
    const otherMesh = (_d2 = otherData.format) === null || _d2 === void 0 ? void 0 : _d2.mesh;
    if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {
      continue;
    }
    if (isInlineData(data3) && isInlineData(otherData)) {
      if (deepEqual(data3.values, otherData.values)) {
        return other;
      }
    } else if (isUrlData(data3) && isUrlData(otherData)) {
      if (data3.url === otherData.url) {
        return other;
      }
    } else if (isNamedData(data3)) {
      if (data3.name === other.dataName) {
        return other;
      }
    }
  }
  return null;
}
function parseRoot(model, sources) {
  if (model.data || !model.parent) {
    if (model.data === null) {
      const source4 = new SourceNode({ values: [] });
      sources.push(source4);
      return source4;
    }
    const existingSource = findSource(model.data, sources);
    if (existingSource) {
      if (!isGenerator(model.data)) {
        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);
      }
      if (!existingSource.hasName() && model.data.name) {
        existingSource.dataName = model.data.name;
      }
      return existingSource;
    } else {
      const source4 = new SourceNode(model.data);
      sources.push(source4);
      return source4;
    }
  } else {
    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
  }
}
function parseTransformArray(head, model, ancestorParse) {
  var _a, _b;
  let lookupCounter = 0;
  for (const t2 of model.transforms) {
    let derivedType = void 0;
    let transformNode;
    if (isCalculate(t2)) {
      transformNode = head = new CalculateNode(head, t2);
      derivedType = "derived";
    } else if (isFilter(t2)) {
      const implicit2 = getImplicitFromFilterTransform(t2);
      transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit2, ancestorParse)) !== null && _a !== void 0 ? _a : head;
      head = new FilterNode(head, model, t2.filter);
    } else if (isBin(t2)) {
      transformNode = head = BinNode.makeFromTransform(head, t2, model);
      derivedType = "number";
    } else if (isTimeUnit(t2)) {
      derivedType = "date";
      const parsedAs = ancestorParse.getWithExplicit(t2.field);
      if (parsedAs.value === void 0) {
        head = new ParseNode(head, { [t2.field]: derivedType });
        ancestorParse.set(t2.field, derivedType, false);
      }
      transformNode = head = TimeUnitNode.makeFromTransform(head, t2);
    } else if (isAggregate2(t2)) {
      transformNode = head = AggregateNode.makeFromTransform(head, t2);
      derivedType = "number";
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    } else if (isLookup(t2)) {
      transformNode = head = LookupNode.make(head, model, t2, lookupCounter++);
      derivedType = "derived";
    } else if (isWindow(t2)) {
      transformNode = head = new WindowTransformNode(head, t2);
      derivedType = "number";
    } else if (isJoinAggregate(t2)) {
      transformNode = head = new JoinAggregateTransformNode(head, t2);
      derivedType = "number";
    } else if (isStack(t2)) {
      transformNode = head = StackNode.makeFromTransform(head, t2);
      derivedType = "derived";
    } else if (isFold(t2)) {
      transformNode = head = new FoldTransformNode(head, t2);
      derivedType = "derived";
    } else if (isFlatten(t2)) {
      transformNode = head = new FlattenTransformNode(head, t2);
      derivedType = "derived";
    } else if (isPivot(t2)) {
      transformNode = head = new PivotTransformNode(head, t2);
      derivedType = "derived";
    } else if (isSample(t2)) {
      head = new SampleTransformNode(head, t2);
    } else if (isImpute(t2)) {
      transformNode = head = ImputeNode.makeFromTransform(head, t2);
      derivedType = "derived";
    } else if (isDensity(t2)) {
      transformNode = head = new DensityTransformNode(head, t2);
      derivedType = "derived";
    } else if (isQuantile2(t2)) {
      transformNode = head = new QuantileTransformNode(head, t2);
      derivedType = "derived";
    } else if (isRegression(t2)) {
      transformNode = head = new RegressionTransformNode(head, t2);
      derivedType = "derived";
    } else if (isLoess(t2)) {
      transformNode = head = new LoessTransformNode(head, t2);
      derivedType = "derived";
    } else {
      warn2(message_exports.invalidTransformIgnored(t2));
      continue;
    }
    if (transformNode && derivedType !== void 0) {
      for (const field3 of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {
        ancestorParse.set(field3, derivedType, false);
      }
    }
  }
  return head;
}
function parseData2(model) {
  var _a, _b, _c2, _d2, _e, _f2, _g2, _h, _j, _k2;
  let head = parseRoot(model, model.component.data.sources);
  const { outputNodes, outputNodeRefCounts } = model.component.data;
  const data3 = model.data;
  const newData = data3 && (isGenerator(data3) || isUrlData(data3) || isInlineData(data3));
  const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
  if (isGenerator(data3)) {
    if (isSequenceGenerator(data3)) {
      head = new SequenceNode(head, data3.sequence);
    } else if (isGraticuleGenerator(data3)) {
      head = new GraticuleNode(head, data3.graticule);
    }
    ancestorParse.parseNothing = true;
  } else if (((_a = data3 === null || data3 === void 0 ? void 0 : data3.format) === null || _a === void 0 ? void 0 : _a.parse) === null) {
    ancestorParse.parseNothing = true;
  }
  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;
  head = new IdentifierNode(head);
  const parentIsLayer = model.parent && isLayerModel(model.parent);
  if (isUnitModel(model) || isFacetModel(model)) {
    if (parentIsLayer) {
      head = (_c2 = BinNode.makeFromEncoding(head, model)) !== null && _c2 !== void 0 ? _c2 : head;
    }
  }
  if (model.transforms.length > 0) {
    head = parseTransformArray(head, model, ancestorParse);
  }
  const implicitSelection = getImplicitFromSelection(model);
  const implicitEncoding = getImplicitFromEncoding(model);
  head = (_d2 = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d2 !== void 0 ? _d2 : head;
  if (isUnitModel(model)) {
    head = GeoJSONNode.parseAll(head, model);
    head = GeoPointNode.parseAll(head, model);
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    if (!parentIsLayer) {
      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;
    }
    head = (_f2 = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f2 !== void 0 ? _f2 : head;
    head = CalculateNode.parseAllForSortIndex(head, model);
  }
  const rawName = model.getDataName(DataSourceType.Raw);
  const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);
  outputNodes[rawName] = raw;
  head = raw;
  if (isUnitModel(model)) {
    const agg = AggregateNode.makeFromEncoding(head, model);
    if (agg) {
      head = agg;
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    }
    head = (_g2 = ImputeNode.makeFromEncoding(head, model)) !== null && _g2 !== void 0 ? _g2 : head;
    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;
  }
  if (isUnitModel(model)) {
    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;
  }
  const mainName = model.getDataName(DataSourceType.Main);
  const main5 = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);
  outputNodes[mainName] = main5;
  head = main5;
  if (isUnitModel(model)) {
    materializeSelections(model, main5);
  }
  let facetRoot = null;
  if (isFacetModel(model)) {
    const facetName = model.getName("facet");
    head = (_k2 = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k2 !== void 0 ? _k2 : head;
    facetRoot = new FacetNode(head, model, facetName, main5.getSource());
    outputNodes[facetName] = facetRoot;
  }
  return Object.assign(Object.assign({}, model.component.data), {
    outputNodes,
    outputNodeRefCounts,
    raw,
    main: main5,
    facetRoot,
    ancestorParse
  });
}

// node_modules/vega-lite/build/src/compile/concat.js
var ConcatModel = class extends Model {
  constructor(spec, parent, parentGivenName, config) {
    var _a, _b, _c2, _d2;
    super(spec, "concat", parent, parentGivenName, config, spec.resolve);
    if (((_b = (_a = spec.resolve) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.x) === "shared" || ((_d2 = (_c2 = spec.resolve) === null || _c2 === void 0 ? void 0 : _c2.axis) === null || _d2 === void 0 ? void 0 : _d2.y) === "shared") {
      warn2(message_exports.CONCAT_CANNOT_SHARE_AXIS);
    }
    this.children = this.getChildren(spec).map((child, i) => {
      return buildModel(child, this, this.getName(`concat_${i}`), void 0, config);
    });
  }
  parseData() {
    this.component.data = parseData2(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key2 of keys3(child.component.selection)) {
        this.component.selection[key2] = child.component.selection[key2];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    for (const child of this.children) {
      child.parseAxesAndHeaders();
    }
  }
  getChildren(spec) {
    if (isVConcatSpec(spec)) {
      return spec.vconcat;
    } else if (isHConcatSpec(spec)) {
      return spec.hconcat;
    }
    return spec.concat;
  }
  parseLayoutSize() {
    parseConcatLayoutSize(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    this.children.forEach((child) => child.assembleSignals());
    return [];
  }
  assembleLayoutSignals() {
    const layoutSignals = assembleLayoutSignals(this);
    for (const child of this.children) {
      layoutSignals.push(...child.assembleLayoutSignals());
    }
    return layoutSignals;
  }
  assembleSelectionData(data3) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data3);
  }
  assembleMarks() {
    return this.children.map((child) => {
      const title2 = child.assembleTitle();
      const style2 = child.assembleGroupStyle();
      const encodeEntry2 = child.assembleGroupEncodeEntry(false);
      return Object.assign(Object.assign(Object.assign(Object.assign({ type: "group", name: child.getName("group") }, title2 ? { title: title2 } : {}), style2 ? { style: style2 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup());
    });
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleDefaultLayout() {
    const columns = this.layout.columns;
    return Object.assign(Object.assign({}, columns != null ? { columns } : {}), {
      bounds: "full",
      // Use align each so it can work with multiple plots with different size
      align: "each"
    });
  }
};

// node_modules/vega-lite/build/src/compile/axis/component.js
function isFalseOrNull(v) {
  return v === false || v === null;
}
var AXIS_COMPONENT_PROPERTIES_INDEX = Object.assign(Object.assign({ disable: 1, gridScale: 1, scale: 1 }, COMMON_AXIS_PROPERTIES_INDEX), { labelExpr: 1, encode: 1 });
var AXIS_COMPONENT_PROPERTIES = keys3(AXIS_COMPONENT_PROPERTIES_INDEX);
var AxisComponent = class _AxisComponent extends Split {
  constructor(explicit = {}, implicit2 = {}, mainExtracted = false) {
    super();
    this.explicit = explicit;
    this.implicit = implicit2;
    this.mainExtracted = mainExtracted;
  }
  clone() {
    return new _AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
  }
  hasAxisPart(part) {
    if (part === "axis") {
      return true;
    }
    if (part === "grid" || part === "title") {
      return !!this.get(part);
    }
    return !isFalseOrNull(this.get(part));
  }
  hasOrientSignalRef() {
    return isSignalRef(this.explicit.orient);
  }
};

// node_modules/vega-lite/build/src/compile/axis/encode.js
function labels2(model, channel, specifiedLabelsSpec) {
  var _a;
  const { encoding, config } = model;
  const fieldOrDatumDef = (_a = getFieldOrDatumDef(encoding[channel])) !== null && _a !== void 0 ? _a : getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
  const axis = model.axis(channel) || {};
  const { format: format5, formatType } = axis;
  if (isCustomFormatType(formatType)) {
    return Object.assign({ text: formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format5,
      formatType,
      config
    }) }, specifiedLabelsSpec);
  } else if (format5 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (channelDefType(fieldOrDatumDef) === "quantitative") {
      if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormatType) {
        return Object.assign({ text: formatCustomType({
          fieldOrDatumDef,
          field: "datum.value",
          format: config.normalizedNumberFormat,
          formatType: config.normalizedNumberFormatType,
          config
        }) }, specifiedLabelsSpec);
      } else if (config.numberFormatType) {
        return Object.assign({ text: formatCustomType({
          fieldOrDatumDef,
          field: "datum.value",
          format: config.numberFormat,
          formatType: config.numberFormatType,
          config
        }) }, specifiedLabelsSpec);
      }
    }
    if (channelDefType(fieldOrDatumDef) === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && !fieldOrDatumDef.timeUnit) {
      return Object.assign({ text: formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.timeFormat,
        formatType: config.timeFormatType,
        config
      }) }, specifiedLabelsSpec);
    }
  }
  return specifiedLabelsSpec;
}

// node_modules/vega-lite/build/src/compile/axis/parse.js
function parseUnitAxes(model) {
  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
    if (model.component.scales[channel]) {
      axis[channel] = [parseAxis2(channel, model)];
    }
    return axis;
  }, {});
}
var OPPOSITE_ORIENT = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function parseLayerAxes(model) {
  var _a;
  const { axes, resolve: resolve2 } = model.component;
  const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const child of model.children) {
    child.parseAxesAndHeaders();
    for (const channel of keys3(child.component.axes)) {
      resolve2.axis[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.axis[channel] === "shared") {
        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
        if (!axes[channel]) {
          resolve2.axis[channel] = "independent";
          delete axes[channel];
        }
      }
    }
  }
  for (const channel of POSITION_SCALE_CHANNELS) {
    for (const child of model.children) {
      if (!child.component.axes[channel]) {
        continue;
      }
      if (resolve2.axis[channel] === "independent") {
        axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]);
        for (const axisComponent of child.component.axes[channel]) {
          const { value: orient2, explicit } = axisComponent.getWithExplicit("orient");
          if (isSignalRef(orient2)) {
            continue;
          }
          if (axisCount[orient2] > 0 && !explicit) {
            const oppositeOrient = OPPOSITE_ORIENT[orient2];
            if (axisCount[orient2] > axisCount[oppositeOrient]) {
              axisComponent.set("orient", oppositeOrient, false);
            }
          }
          axisCount[orient2]++;
        }
      }
      delete child.component.axes[channel];
    }
    if (resolve2.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
      for (const axisCmpt of axes[channel]) {
        if (!!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
          axisCmpt.implicit.grid = false;
        }
      }
    }
  }
}
function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
  if (mergedAxisCmpts) {
    if (mergedAxisCmpts.length !== childAxisCmpts.length) {
      return void 0;
    }
    const length3 = mergedAxisCmpts.length;
    for (let i = 0; i < length3; i++) {
      const merged = mergedAxisCmpts[i];
      const child = childAxisCmpts[i];
      if (!!merged !== !!child) {
        return void 0;
      } else if (merged && child) {
        const mergedOrient = merged.getWithExplicit("orient");
        const childOrient = child.getWithExplicit("orient");
        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
          return void 0;
        } else {
          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
        }
      }
    }
  } else {
    return childAxisCmpts.map((axisComponent) => axisComponent.clone());
  }
  return mergedAxisCmpts;
}
function mergeAxisComponent(merged, child) {
  for (const prop of AXIS_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      merged.getWithExplicit(prop),
      child.getWithExplicit(prop),
      prop,
      "axis",
      // Tie breaker function
      (v1, v2) => {
        switch (prop) {
          case "title":
            return mergeTitleComponent(v1, v2);
          case "gridScale":
            return {
              explicit: v1.explicit,
              value: getFirstDefined(v1.value, v2.value)
            };
        }
        return defaultTieBreaker(v1, v2, prop, "axis");
      }
    );
    merged.setWithExplicit(prop, mergedValueWithExplicit);
  }
  return merged;
}
function isExplicit2(value3, property2, axis, model, channel) {
  if (property2 === "disable") {
    return axis !== void 0;
  }
  axis = axis || {};
  switch (property2) {
    case "titleAngle":
    case "labelAngle":
      return value3 === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
    case "values":
      return !!axis.values;
    case "encode":
      return !!axis.encoding || !!axis.labelAngle;
    case "title":
      if (value3 === getFieldDefTitle(model, channel)) {
        return true;
      }
  }
  return value3 === axis[property2];
}
var propsToAlwaysIncludeConfig = /* @__PURE__ */ new Set([
  "grid",
  "translate",
  // the rest are not axis configs in Vega, but are in VL, so we need to set too.
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function parseAxis2(channel, model) {
  var _a, _b, _c2;
  let axis = model.axis(channel);
  const axisComponent = new AxisComponent();
  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
  const { mark: mark2, config } = model;
  const orient2 = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a = config[channel === "x" ? "axisX" : "axisY"]) === null || _a === void 0 ? void 0 : _a.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const axisConfigs = getAxisConfigs(channel, scaleType2, orient2, model.config);
  const disable = axis !== void 0 ? !axis : getAxisConfig("disable", config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;
  axisComponent.set("disable", disable, axis !== void 0);
  if (disable) {
    return axisComponent;
  }
  axis = axis || {};
  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);
  const ruleParams = {
    fieldOrDatumDef,
    axis,
    channel,
    model,
    scaleType: scaleType2,
    orient: orient2,
    labelAngle,
    mark: mark2,
    config
  };
  for (const property2 of AXIS_COMPONENT_PROPERTIES) {
    const value3 = property2 in axisRules ? axisRules[property2](ruleParams) : isAxisProperty(property2) ? axis[property2] : void 0;
    const hasValue = value3 !== void 0;
    const explicit = isExplicit2(value3, property2, axis, model, channel);
    if (hasValue && explicit) {
      axisComponent.set(property2, value3, explicit);
    } else {
      const { configValue = void 0, configFrom = void 0 } = isAxisProperty(property2) && property2 !== "values" ? getAxisConfig(property2, config.style, axis.style, axisConfigs) : {};
      const hasConfigValue = configValue !== void 0;
      if (hasValue && !hasConfigValue) {
        axisComponent.set(property2, value3, explicit);
      } else if (
        // Cases need implicit values
        // 1. Axis config that aren't available in Vega
        !(configFrom === "vgAxisConfig") || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
        propsToAlwaysIncludeConfig.has(property2) && hasConfigValue || // 3. Conditional axis values and signals
        isConditionalAxisValue(configValue) || isSignalRef(configValue)
      ) {
        axisComponent.set(property2, configValue, false);
      }
    }
  }
  const axisEncoding = (_c2 = axis.encoding) !== null && _c2 !== void 0 ? _c2 : {};
  const axisEncode = AXIS_PARTS.reduce((e2, part) => {
    var _a2;
    if (!axisComponent.hasAxisPart(part)) {
      return e2;
    }
    const axisEncodingPart = guideEncodeEntry((_a2 = axisEncoding[part]) !== null && _a2 !== void 0 ? _a2 : {}, model);
    const value3 = part === "labels" ? labels2(model, channel, axisEncodingPart) : axisEncodingPart;
    if (value3 !== void 0 && !isEmpty(value3)) {
      e2[part] = { update: value3 };
    }
    return e2;
  }, {});
  if (!isEmpty(axisEncode)) {
    axisComponent.set("encode", axisEncode, !!axis.encoding || axis.labelAngle !== void 0);
  }
  return axisComponent;
}

// node_modules/vega-lite/build/src/compile/layoutsize/init.js
function initLayoutSize({ encoding, size }) {
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (isStep(size[sizeType])) {
      if (isContinuousFieldOrDatumDef(encoding[channel])) {
        delete size[sizeType];
        warn2(message_exports.stepDropped(sizeType));
      }
    }
  }
  return size;
}

// node_modules/vega-lite/build/src/compile/mark/init.js
function initMarkdef(originalMarkDef, encoding, config) {
  const markDef = replaceExprRef(originalMarkDef);
  const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
  markDef.orient = orient(markDef.type, encoding, specifiedOrient);
  if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
    warn2(message_exports.orientOverridden(markDef.orient, specifiedOrient));
  }
  if (markDef.type === "bar" && markDef.orient) {
    const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
    if (cornerRadiusEnd !== void 0) {
      const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
      for (const newProp of newProps) {
        markDef[newProp] = cornerRadiusEnd;
      }
      if (markDef.cornerRadiusEnd !== void 0) {
        delete markDef.cornerRadiusEnd;
      }
    }
  }
  const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
  if (specifiedOpacity === void 0) {
    markDef.opacity = opacity(markDef.type, encoding);
  }
  const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
  if (specifiedCursor === void 0) {
    markDef.cursor = cursor2(markDef, encoding, config);
  }
  return markDef;
}
function cursor2(markDef, encoding, config) {
  if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
    return "pointer";
  }
  return markDef.cursor;
}
function opacity(mark2, encoding) {
  if (contains2([POINT, TICK, CIRCLE, SQUARE], mark2)) {
    if (!isAggregate(encoding)) {
      return 0.7;
    }
  }
  return void 0;
}
function defaultFilled(markDef, config, { graticule: graticule2 }) {
  if (graticule2) {
    return false;
  }
  const filledConfig = getMarkConfig("filled", markDef, config);
  const mark2 = markDef.type;
  return getFirstDefined(filledConfig, mark2 !== POINT && mark2 !== LINE && mark2 !== RULE);
}
function orient(mark2, encoding, specifiedOrient) {
  switch (mark2) {
    case POINT:
    case CIRCLE:
    case SQUARE:
    case TEXT2:
    case RECT:
    case IMAGE:
      return void 0;
  }
  const { x: x2, y: y2, x2: x22, y2: y22 } = encoding;
  switch (mark2) {
    case BAR:
      if (isFieldDef(x2) && (isBinned(x2.bin) || isFieldDef(y2) && y2.aggregate && !x2.aggregate)) {
        return "vertical";
      }
      if (isFieldDef(y2) && (isBinned(y2.bin) || isFieldDef(x2) && x2.aggregate && !y2.aggregate)) {
        return "horizontal";
      }
      if (y22 || x22) {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        if (!x22) {
          if (isFieldDef(x2) && x2.type === QUANTITATIVE && !isBinning(x2.bin) || isNumericDataDef(x2)) {
            return "horizontal";
          }
        }
        if (!y22) {
          if (isFieldDef(y2) && y2.type === QUANTITATIVE && !isBinning(y2.bin) || isNumericDataDef(y2)) {
            return "vertical";
          }
        }
      }
    case RULE:
      if (x22 && !(isFieldDef(x2) && isBinned(x2.bin)) && y22 && !(isFieldDef(y2) && isBinned(y2.bin))) {
        return void 0;
      }
    case AREA:
      if (y22) {
        if (isFieldDef(y2) && isBinned(y2.bin)) {
          return "horizontal";
        } else {
          return "vertical";
        }
      } else if (x22) {
        if (isFieldDef(x2) && isBinned(x2.bin)) {
          return "vertical";
        } else {
          return "horizontal";
        }
      } else if (mark2 === RULE) {
        if (x2 && !y2) {
          return "vertical";
        } else if (y2 && !x2) {
          return "horizontal";
        }
      }
    case LINE:
    case TICK: {
      const xIsContinuous = isContinuousFieldOrDatumDef(x2);
      const yIsContinuous = isContinuousFieldOrDatumDef(y2);
      if (specifiedOrient) {
        return specifiedOrient;
      } else if (xIsContinuous && !yIsContinuous) {
        return mark2 !== "tick" ? "horizontal" : "vertical";
      } else if (!xIsContinuous && yIsContinuous) {
        return mark2 !== "tick" ? "vertical" : "horizontal";
      } else if (xIsContinuous && yIsContinuous) {
        const xDef = x2;
        const yDef = y2;
        const xIsTemporal = xDef.type === TEMPORAL;
        const yIsTemporal = yDef.type === TEMPORAL;
        if (xIsTemporal && !yIsTemporal) {
          return mark2 !== "tick" ? "vertical" : "horizontal";
        } else if (!xIsTemporal && yIsTemporal) {
          return mark2 !== "tick" ? "horizontal" : "vertical";
        }
        if (!xDef.aggregate && yDef.aggregate) {
          return mark2 !== "tick" ? "vertical" : "horizontal";
        } else if (xDef.aggregate && !yDef.aggregate) {
          return mark2 !== "tick" ? "horizontal" : "vertical";
        }
        return "vertical";
      } else {
        return void 0;
      }
    }
  }
  return "vertical";
}

// node_modules/vega-lite/build/src/compile/mark/arc.js
var arc3 = {
  vgMark: "arc",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), rectPosition(model, "radius")), rectPosition(model, "theta"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/area.js
var area3 = {
  vgMark: "area",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "horizontal"
    })), pointOrRangePosition("y", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "vertical"
    })), defined(model));
  }
};

// node_modules/vega-lite/build/src/compile/mark/bar.js
var bar = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x")), rectPosition(model, "y"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/geoshape.js
var geoshape = {
  vgMark: "shape",
  encodeEntry: (model) => {
    return Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }));
  },
  postEncodingTransform: (model) => {
    const { encoding } = model;
    const shapeDef = encoding.shape;
    const transform4 = Object.assign({ type: "geoshape", projection: model.projectionName() }, shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? { field: vgField(shapeDef, { expr: "datum" }) } : {});
    return [transform4];
  }
};

// node_modules/vega-lite/build/src/compile/mark/image.js
var image2 = {
  vgMark: "image",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x")), rectPosition(model, "y")), text2(model, "url"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/line.js
var line3 = {
  vgMark: "line",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
      // VL's line size is strokeWidth
    })), defined(model));
  }
};
var trail2 = {
  vgMark: "trail",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), defined(model));
  }
};

// node_modules/vega-lite/build/src/compile/mark/point.js
function encodeEntry(model, fixedShape) {
  const { config } = model;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
    align: "ignore",
    baseline: "ignore",
    color: "include",
    size: "include",
    orient: "ignore",
    theta: "ignore"
  })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), nonPosition("angle", model)), shapeMixins(model, config, fixedShape));
}
function shapeMixins(model, config, fixedShape) {
  if (fixedShape) {
    return { shape: { value: fixedShape } };
  }
  return nonPosition("shape", model);
}
var point4 = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model);
  }
};
var circle = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "circle");
  }
};
var square = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "square");
  }
};

// node_modules/vega-lite/build/src/compile/mark/rect.js
var rect2 = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x")), rectPosition(model, "y"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/rule.js
var rule3 = {
  vgMark: "rule",
  encodeEntry: (model) => {
    const { markDef } = model;
    const orient2 = markDef.orient;
    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
      return {};
    }
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: orient2 === "horizontal" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient2 !== "vertical"
      // include x2 for horizontal or line segment rule
    })), pointOrRangePosition("y", model, {
      defaultPos: orient2 === "vertical" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient2 !== "horizontal"
      // include y2 for vertical or line segment rule
    })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
      // VL's rule size is strokeWidth
    }));
  }
};

// node_modules/vega-lite/build/src/compile/mark/text.js
var text3 = {
  vgMark: "text",
  encodeEntry: (model) => {
    const { config, encoding } = model;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "include",
      baseline: "include",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "include"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), text2(model)), nonPosition("size", model, {
      vgChannel: "fontSize"
      // VL's text size is fontSize
    })), nonPosition("angle", model)), valueIfDefined("align", align(model.markDef, encoding, config))), valueIfDefined("baseline", baseline2(model.markDef, encoding, config))), pointPosition("radius", model, { defaultPos: null })), pointPosition("theta", model, { defaultPos: null }));
  }
};
function align(markDef, encoding, config) {
  const a = getMarkPropOrConfig("align", markDef, config);
  if (a === void 0) {
    return "center";
  }
  return void 0;
}
function baseline2(markDef, encoding, config) {
  const b2 = getMarkPropOrConfig("baseline", markDef, config);
  if (b2 === void 0) {
    return "middle";
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/tick.js
var tick = {
  vgMark: "rect",
  encodeEntry: (model) => {
    const { config, markDef } = model;
    const orient2 = markDef.orient;
    const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
    const vgThicknessChannel = orient2 === "horizontal" ? "height" : "width";
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid", vgChannel: "xc" })), pointPosition("y", model, { defaultPos: "mid", vgChannel: "yc" })), nonPosition("size", model, {
      defaultValue: defaultSize(model),
      vgChannel: vgSizeChannel
    })), { [vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config)) });
  }
};
function defaultSize(model) {
  var _a;
  const { config, markDef } = model;
  const { orient: orient2 } = markDef;
  const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
  const scale6 = model.getScaleComponent(orient2 === "horizontal" ? "x" : "y");
  const markPropOrConfig = (_a = getMarkPropOrConfig("size", markDef, config, { vgChannel: vgSizeChannel })) !== null && _a !== void 0 ? _a : config.tick.bandSize;
  if (markPropOrConfig !== void 0) {
    return markPropOrConfig;
  } else {
    const scaleRange = scale6 ? scale6.get("range") : void 0;
    if (scaleRange && isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {
      return scaleRange.step * 3 / 4;
    }
    const defaultViewStep = getViewConfigDiscreteStep(config.view, vgSizeChannel);
    return defaultViewStep * 3 / 4;
  }
}

// node_modules/vega-lite/build/src/compile/mark/mark.js
var markCompiler = {
  arc: arc3,
  area: area3,
  bar,
  circle,
  geoshape,
  image: image2,
  line: line3,
  point: point4,
  rect: rect2,
  rule: rule3,
  square,
  text: text3,
  tick,
  trail: trail2
};
function parseMarkGroups(model) {
  if (contains2([LINE, AREA, TRAIL], model.mark)) {
    const details = pathGroupingFields(model.mark, model.encoding);
    if (details.length > 0) {
      return getPathGroups(model, details);
    }
  } else if (model.mark === BAR) {
    const hasCornerRadius2 = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
    if (model.stack && !model.fieldDef("size") && hasCornerRadius2) {
      return getGroupsForStackedBarWithCornerRadius(model);
    }
  }
  return getMarkGroup(model);
}
var FACETED_PATH_PREFIX = "faceted_path_";
function getPathGroups(model, details) {
  return [
    {
      name: model.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),
          data: model.requestDataName(DataSourceType.Main),
          groupby: details
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      // With subfacet for line/area group, need to use faceted data from above.
      marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })
    }
  ];
}
var STACK_GROUP_PREFIX = "stack_group_";
function getGroupsForStackedBarWithCornerRadius(model) {
  var _a;
  const [mark2] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });
  const fieldScale = model.scaleName(model.stack.fieldChannel);
  const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
  const stackFieldGroup = (func, expr2) => {
    const vgFieldMinMax = [
      stackField({ prefix: "min", suffix: "start", expr: expr2 }),
      stackField({ prefix: "max", suffix: "start", expr: expr2 }),
      stackField({ prefix: "min", suffix: "end", expr: expr2 }),
      stackField({ prefix: "max", suffix: "end", expr: expr2 })
    ];
    return `${func}(${vgFieldMinMax.map((field3) => `scale('${fieldScale}',${field3})`).join(",")})`;
  };
  let groupUpdate;
  let innerGroupUpdate;
  if (model.stack.fieldChannel === "x") {
    groupUpdate = Object.assign(Object.assign({}, pick2(mark2.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS])), { x: { signal: stackFieldGroup("min", "datum") }, x2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
    innerGroupUpdate = {
      x: { field: { group: "x" }, mult: -1 },
      height: { field: { group: "height" } }
    };
    mark2.encode.update = Object.assign(Object.assign({}, omit(mark2.encode.update, ["y", "yc", "y2"])), { height: { field: { group: "height" } } });
  } else {
    groupUpdate = Object.assign(Object.assign({}, pick2(mark2.encode.update, ["x", "xc", "x2", "width"])), { y: { signal: stackFieldGroup("min", "datum") }, y2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
    innerGroupUpdate = {
      y: { field: { group: "y" }, mult: -1 },
      width: { field: { group: "width" } }
    };
    mark2.encode.update = Object.assign(Object.assign({}, omit(mark2.encode.update, ["x", "xc", "x2"])), { width: { field: { group: "width" } } });
  }
  for (const key2 of VG_CORNERRADIUS_CHANNELS) {
    const configValue = getMarkConfig(key2, model.markDef, model.config);
    if (mark2.encode.update[key2]) {
      groupUpdate[key2] = mark2.encode.update[key2];
      delete mark2.encode.update[key2];
    } else if (configValue) {
      groupUpdate[key2] = signalOrValueRef(configValue);
    }
    if (configValue) {
      mark2.encode.update[key2] = { value: 0 };
    }
  }
  const groupby = [];
  if (((_a = model.stack.groupbyChannels) === null || _a === void 0 ? void 0 : _a.length) > 0) {
    for (const groupbyChannel of model.stack.groupbyChannels) {
      const groupByField = model.fieldDef(groupbyChannel);
      const field3 = vgField(groupByField);
      if (field3) {
        groupby.push(field3);
      }
      if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {
        groupby.push(vgField(groupByField, { binSuffix: "end" }));
      }
    }
  }
  const strokeProperties = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ];
  groupUpdate = strokeProperties.reduce((encode2, prop) => {
    if (mark2.encode.update[prop]) {
      return Object.assign(Object.assign({}, encode2), { [prop]: mark2.encode.update[prop] });
    } else {
      const configValue = getMarkConfig(prop, model.markDef, model.config);
      if (configValue !== void 0) {
        return Object.assign(Object.assign({}, encode2), { [prop]: signalOrValueRef(configValue) });
      } else {
        return encode2;
      }
    }
  }, groupUpdate);
  if (groupUpdate.stroke) {
    groupUpdate.strokeForeground = { value: true };
    groupUpdate.strokeOffset = { value: 0 };
  }
  return [
    {
      type: "group",
      from: {
        facet: {
          data: model.requestDataName(DataSourceType.Main),
          name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),
          groupby,
          aggregate: {
            fields: [
              stackField({ suffix: "start" }),
              stackField({ suffix: "start" }),
              stackField({ suffix: "end" }),
              stackField({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: groupUpdate
      },
      marks: [
        {
          type: "group",
          encode: { update: innerGroupUpdate },
          marks: [mark2]
        }
      ]
    }
  ];
}
function getSort2(model) {
  var _a;
  const { encoding, stack: stack2, mark: mark2, markDef, config } = model;
  const order = encoding.order;
  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
    return void 0;
  } else if ((isArray(order) || isFieldDef(order)) && !stack2) {
    return sortParams(order, { expr: "datum" });
  } else if (isPathMark(mark2)) {
    const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
    const dimensionChannelDef = encoding[dimensionChannel];
    if (isFieldDef(dimensionChannelDef)) {
      const s = dimensionChannelDef.sort;
      if (isArray(s)) {
        return {
          field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: "sort_index", expr: "datum" })
        };
      } else if (isSortField(s)) {
        return {
          field: vgField({
            // FIXME: this op might not already exist?
            // FIXME: what if dimensionChannel (x or y) contains custom domain?
            aggregate: isAggregate(model.encoding) ? s.op : void 0,
            field: s.field
          }, { expr: "datum" })
        };
      } else if (isSortByEncoding(s)) {
        const fieldDefToSort = model.fieldDef(s.encoding);
        return {
          field: vgField(fieldDefToSort, { expr: "datum" }),
          order: s.order
        };
      } else if (s === null) {
        return void 0;
      } else {
        return {
          field: vgField(dimensionChannelDef, {
            // For stack with imputation, we only have bin_mid
            binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? "mid" : void 0,
            expr: "datum"
          })
        };
      }
    }
    return void 0;
  }
  return void 0;
}
function getMarkGroup(model, opt = { fromPrefix: "" }) {
  const { mark: mark2, markDef, encoding, config } = model;
  const clip3 = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
  const style2 = getStyles(markDef);
  const key2 = encoding.key;
  const sort3 = getSort2(model);
  const interactive2 = interactiveFlag(model);
  const aria2 = getMarkPropOrConfig("aria", markDef, config);
  const postEncodingTransform = markCompiler[mark2].postEncodingTransform ? markCompiler[mark2].postEncodingTransform(model) : null;
  return [
    Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName("marks"), type: markCompiler[mark2].vgMark }, clip3 ? { clip: true } : {}), style2 ? { style: style2 } : {}), key2 ? { key: key2.field } : {}), sort3 ? { sort: sort3 } : {}), interactive2 ? interactive2 : {}), aria2 === false ? { aria: aria2 } : {}), { from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) }, encode: {
      update: markCompiler[mark2].encodeEntry(model)
    } }), postEncodingTransform ? {
      transform: postEncodingTransform
    } : {})
  ];
}
function scaleClip(model) {
  const xScale = model.getScaleComponent("x");
  const yScale = model.getScaleComponent("y");
  return (xScale === null || xScale === void 0 ? void 0 : xScale.get("selectionExtent")) || (yScale === null || yScale === void 0 ? void 0 : yScale.get("selectionExtent")) ? true : void 0;
}
function projectionClip(model) {
  const projection3 = model.component.projection;
  return projection3 && !projection3.isFit ? true : void 0;
}
function interactiveFlag(model) {
  if (!model.component.selection)
    return null;
  const unitCount = keys3(model.component.selection).length;
  let parentCount = unitCount;
  let parent = model.parent;
  while (parent && parentCount === 0) {
    parentCount = keys3(parent.component.selection).length;
    parent = parent.parent;
  }
  return parentCount ? {
    interactive: unitCount > 0 || !!model.encoding.tooltip
  } : null;
}

// node_modules/vega-lite/build/src/compile/unit.js
var UnitModel = class extends ModelWithField {
  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
    var _a;
    super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
    this.specifiedScales = {};
    this.specifiedAxes = {};
    this.specifiedLegends = {};
    this.specifiedProjection = {};
    this.selection = [];
    this.children = [];
    const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : { type: spec.mark };
    const mark2 = markDef.type;
    if (markDef.filled === void 0) {
      markDef.filled = defaultFilled(markDef, config, {
        graticule: spec.data && isGraticuleGenerator(spec.data)
      });
    }
    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark2, markDef.filled, config);
    this.markDef = initMarkdef(markDef, encoding, config);
    this.size = initLayoutSize({
      encoding,
      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {}) : parentGivenSize
    });
    this.stack = stack(mark2, encoding);
    this.specifiedScales = this.initScales(mark2, encoding);
    this.specifiedAxes = this.initAxes(encoding);
    this.specifiedLegends = this.initLegends(encoding);
    this.specifiedProjection = spec.projection;
    this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter((p) => isSelectionParameter(p));
  }
  get hasProjection() {
    const { encoding } = this;
    const isGeoShapeMark = this.mark === GEOSHAPE;
    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
    return isGeoShapeMark || hasGeoPosition;
  }
  /**
   * Return specified Vega-Lite scale domain for a particular channel
   * @param channel
   */
  scaleDomain(channel) {
    const scale6 = this.specifiedScales[channel];
    return scale6 ? scale6.domain : void 0;
  }
  axis(channel) {
    return this.specifiedAxes[channel];
  }
  legend(channel) {
    return this.specifiedLegends[channel];
  }
  initScales(mark2, encoding) {
    return SCALE_CHANNELS.reduce((scales2, channel) => {
      var _a;
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef) {
        scales2[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});
      }
      return scales2;
    }, {});
  }
  initScale(scale6) {
    const { domain: domain4, range: range6 } = scale6;
    const scaleInternal = replaceExprRef(scale6);
    if (isArray(domain4)) {
      scaleInternal.domain = domain4.map(signalRefOrValue);
    }
    if (isArray(range6)) {
      scaleInternal.range = range6.map(signalRefOrValue);
    }
    return scaleInternal;
  }
  initAxes(encoding) {
    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
      const channelDef = encoding[channel];
      if (isFieldOrDatumDef(channelDef) || channel === X2 && isFieldOrDatumDef(encoding.x2) || channel === Y2 && isFieldOrDatumDef(encoding.y2)) {
        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
        _axis[channel] = axisSpec ? this.initAxis(Object.assign({}, axisSpec)) : axisSpec;
      }
      return _axis;
    }, {});
  }
  initAxis(axis) {
    const props = keys3(axis);
    const axisInternal = {};
    for (const prop of props) {
      const val = axis[prop];
      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
    }
    return axisInternal;
  }
  initLegends(encoding) {
    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef && supportLegend(channel)) {
        const legend = fieldOrDatumDef.legend;
        _legend[channel] = legend ? replaceExprRef(legend) : legend;
      }
      return _legend;
    }, {});
  }
  parseData() {
    this.component.data = parseData2(this);
  }
  parseLayoutSize() {
    parseUnitLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = parseUnitSelection(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = parseMarkGroups(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = parseUnitAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return assembleTopLevelSignals(this, signals);
  }
  assembleSignals() {
    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
  }
  assembleSelectionData(data3) {
    return assembleUnitSelectionData(this, data3);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return assembleLayoutSignals(this);
  }
  assembleMarks() {
    var _a;
    let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];
    if (!this.parent || !isLayerModel(this.parent)) {
      marks = assembleUnitSelectionMarks(this, marks);
    }
    return marks.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: style2 } = this.view || {};
    if (style2 !== void 0) {
      return style2;
    }
    if (this.encoding.x || this.encoding.y) {
      return "cell";
    } else {
      return void 0;
    }
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(channel) {
    return channelHasField(this.encoding, channel);
  }
  fieldDef(channel) {
    const channelDef = this.encoding[channel];
    return getFieldDef(channelDef);
  }
  typedFieldDef(channel) {
    const fieldDef = this.fieldDef(channel);
    if (isTypedFieldDef(fieldDef)) {
      return fieldDef;
    }
    return null;
  }
};

// node_modules/vega-lite/build/src/compile/layer.js
var LayerModel = class _LayerModel extends Model {
  constructor(spec, parent, parentGivenName, parentGivenSize, config) {
    super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {});
    this.children = spec.layer.map((layer, i) => {
      if (isLayerSpec(layer)) {
        return new _LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      } else if (isUnitSpec(layer)) {
        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      }
      throw new Error(message_exports.invalidSpec(layer));
    });
  }
  parseData() {
    this.component.data = parseData2(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseLayoutSize() {
    parseLayerLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key2 of keys3(child.component.selection)) {
        this.component.selection[key2] = child.component.selection[key2];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    parseLayerAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  // TODO: Support same named selections across children.
  assembleSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleSignals());
    }, assembleAxisSignals(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleLayoutSignals());
    }, assembleLayoutSignals(this));
  }
  assembleSelectionData(data3) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data3);
  }
  assembleGroupStyle() {
    const uniqueStyles = /* @__PURE__ */ new Set();
    for (const child of this.children) {
      for (const style2 of array(child.assembleGroupStyle())) {
        uniqueStyles.add(style2);
      }
    }
    const styles = Array.from(uniqueStyles);
    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : void 0;
  }
  assembleTitle() {
    let title2 = super.assembleTitle();
    if (title2) {
      return title2;
    }
    for (const child of this.children) {
      title2 = child.assembleTitle();
      if (title2) {
        return title2;
      }
    }
    return void 0;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
      return child.assembleMarks();
    }));
  }
  assembleLegends() {
    return this.children.reduce((legends, child) => {
      return legends.concat(child.assembleLegends());
    }, assembleLegends(this));
  }
};

// node_modules/vega-lite/build/src/compile/buildmodel.js
function buildModel(spec, parent, parentGivenName, unitSize, config) {
  if (isFacetSpec(spec)) {
    return new FacetModel(spec, parent, parentGivenName, config);
  } else if (isLayerSpec(spec)) {
    return new LayerModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isUnitSpec(spec)) {
    return new UnitModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isAnyConcatSpec(spec)) {
    return new ConcatModel(spec, parent, parentGivenName, config);
  }
  throw new Error(message_exports.invalidSpec(spec));
}

// node_modules/vega-lite/build/src/compile/compile.js
var __rest32 = function(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function compile(inputSpec, opt = {}) {
  if (opt.logger) {
    set4(opt.logger);
  }
  if (opt.fieldTitle) {
    setTitleFormatter(opt.fieldTitle);
  }
  try {
    const config = initConfig(mergeConfig(opt.config, inputSpec.config));
    const spec = normalize(inputSpec, config);
    const model = buildModel(spec, null, "", void 0, config);
    model.parse();
    optimizeDataflow(model.component.data, model);
    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
    return {
      spec: vgSpec,
      normalized: spec
    };
  } finally {
    if (opt.logger) {
      reset2();
    }
    if (opt.fieldTitle) {
      resetTitleFormatter();
    }
  }
}
function getTopLevelProperties(inputSpec, autosize, config, model) {
  const width2 = model.component.layoutSize.get("width");
  const height2 = model.component.layoutSize.get("height");
  if (autosize === void 0) {
    autosize = { type: "pad" };
    if (model.hasAxisOrientSignalRef()) {
      autosize.resize = true;
    }
  } else if (isString(autosize)) {
    autosize = { type: autosize };
  }
  if (width2 && height2 && isFitType(autosize.type)) {
    if (width2 === "step" && height2 === "step") {
      warn2(message_exports.droppingFit());
      autosize.type = "pad";
    } else if (width2 === "step" || height2 === "step") {
      const sizeType = width2 === "step" ? "width" : "height";
      warn2(message_exports.droppingFit(getPositionScaleChannel(sizeType)));
      const inverseSizeType = sizeType === "width" ? "height" : "width";
      autosize.type = getFitType(inverseSizeType);
    }
  }
  return Object.assign(Object.assign(Object.assign({}, keys3(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : { autosize: autosize.type } : { autosize }), extractTopLevelProperties(config, false)), extractTopLevelProperties(inputSpec, true));
}
function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
  const data3 = [].concat(
    model.assembleSelectionData([]),
    // only assemble data in the root
    assembleRootData(model.component.data, datasets)
  );
  const projections2 = model.assembleProjections();
  const title2 = model.assembleTitle();
  const style2 = model.assembleGroupStyle();
  const encodeEntry2 = model.assembleGroupEncodeEntry(true);
  let layoutSignals = model.assembleLayoutSignals();
  layoutSignals = layoutSignals.filter((signal) => {
    if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
      topLevelProperties[signal.name] = +signal.value;
      return false;
    }
    return true;
  });
  const { params: params2 } = topLevelProperties, otherTopLevelProps = __rest32(topLevelProperties, ["params"]);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ $schema: "https://vega.github.io/schema/vega/v5.json" }, model.description ? { description: model.description } : {}), otherTopLevelProps), title2 ? { title: title2 } : {}), style2 ? { style: style2 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), { data: data3 }), projections2.length > 0 ? { projections: projections2 } : {}), model.assembleGroup([
    ...layoutSignals,
    ...model.assembleSelectionTopLevelSignals([]),
    ...assembleParameterSignals(params2)
  ])), vgConfig ? { config: vgConfig } : {}), usermeta ? { usermeta } : {});
}

// node_modules/vega-lite/build/src/index.js
var version2 = package_default.version;

// node_modules/vega-schema-url-parser/dist/parser.module.js
function e(e2) {
  const [n, r2] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e2).slice(1, 3);
  return { library: n, version: r2 };
}
var parser_module_default = e;

// node_modules/vega-themes/build/vega-themes.module.js
var vega_themes_module_exports = {};
__export(vega_themes_module_exports, {
  dark: () => darkTheme,
  excel: () => excelTheme,
  fivethirtyeight: () => fiveThirtyEightTheme,
  ggplot2: () => ggplot2Theme,
  googlecharts: () => googlechartsTheme,
  latimes: () => latimesTheme,
  powerbi: () => powerbiTheme,
  quartz: () => quartzTheme,
  urbaninstitute: () => urbanInstituteTheme,
  version: () => version3,
  vox: () => voxTheme
});
var name = "vega-themes";
var version$1 = "2.10.0";
var description2 = "Themes for stylized Vega and Vega-Lite visualizations.";
var keywords3 = [
  "vega",
  "vega-lite",
  "themes",
  "style"
];
var license = "BSD-3-Clause";
var author = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var contributors = [
  {
    name: "Emily Gu",
    url: "https://github.com/emilygu"
  },
  {
    name: "Arvind Satyanarayan",
    url: "http://arvindsatya.com"
  },
  {
    name: "Jeffrey Heer",
    url: "https://idl.cs.washington.edu"
  },
  {
    name: "Dominik Moritz",
    url: "https://www.domoritz.de"
  }
];
var main2 = "build/vega-themes.js";
var module = "build/vega-themes.module.js";
var unpkg = "build/vega-themes.min.js";
var jsdelivr = "build/vega-themes.min.js";
var types = "build/vega-themes.module.d.ts";
var repository = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
};
var files = [
  "src",
  "build"
];
var scripts = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  prepare: "beemo create-config",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix",
  lint: "yarn eslintbase",
  release: "auto shipit"
};
var devDependencies = {
  "@auto-it/conventional-commits": "^10.32.2",
  "@auto-it/first-time-contributor": "^10.32.2",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.6",
  "rollup-plugin-ts": "^1.4.7",
  auto: "^10.32.2",
  "browser-sync": "^2.27.7",
  concurrently: "^6.4.0",
  "gh-pages": "^3.2.3",
  rollup: "^2.60.0",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  typescript: "^4.4.4",
  vega: "^5.19.1",
  "vega-lite": "^5.0.0",
  "vega-lite-dev-config": "^0.20.0"
};
var peerDependencies = {
  vega: "*",
  "vega-lite": "*"
};
var pkg = {
  name,
  version: version$1,
  description: description2,
  keywords: keywords3,
  license,
  author,
  contributors,
  main: main2,
  module,
  unpkg,
  jsdelivr,
  types,
  repository,
  files,
  scripts,
  devDependencies,
  peerDependencies
};
var lightColor = "#fff";
var medColor = "#888";
var darkTheme = {
  background: "#333",
  title: {
    color: lightColor,
    subtitleColor: lightColor
  },
  style: {
    "guide-label": {
      fill: lightColor
    },
    "guide-title": {
      fill: lightColor
    }
  },
  axis: {
    domainColor: lightColor,
    gridColor: medColor,
    tickColor: lightColor
  }
};
var markColor$7 = "#4572a7";
var excelTheme = {
  background: "#fff",
  arc: { fill: markColor$7 },
  area: { fill: markColor$7 },
  line: { stroke: markColor$7, strokeWidth: 2 },
  path: { stroke: markColor$7 },
  rect: { fill: markColor$7 },
  shape: { stroke: markColor$7 },
  symbol: { fill: markColor$7, strokeWidth: 1.5, size: 50 },
  axis: {
    bandPosition: 0.5,
    grid: true,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: false,
    tickExtra: true
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: [
      "#4572a7",
      "#aa4643",
      "#8aa453",
      "#71598e",
      "#4598ae",
      "#d98445",
      "#94aace",
      "#d09393",
      "#b9cc98",
      "#a99cbc"
    ]
  }
};
var markColor$6 = "#30a2da";
var axisColor$2 = "#cbcbcb";
var guideLabelColor = "#999";
var guideTitleColor = "#333";
var backgroundColor$2 = "#f0f0f0";
var blackTitle = "#333";
var fiveThirtyEightTheme = {
  arc: { fill: markColor$6 },
  area: { fill: markColor$6 },
  axis: {
    domainColor: axisColor$2,
    grid: true,
    gridColor: axisColor$2,
    gridWidth: 1,
    labelColor: guideLabelColor,
    labelFontSize: 10,
    titleColor: guideTitleColor,
    tickColor: axisColor$2,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: false
  },
  background: backgroundColor$2,
  group: {
    fill: backgroundColor$2
  },
  legend: {
    labelColor: blackTitle,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: blackTitle,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: markColor$6,
    strokeWidth: 2
  },
  path: { stroke: markColor$6, strokeWidth: 0.5 },
  rect: { fill: markColor$6 },
  range: {
    category: [
      "#30a2da",
      "#fc4f30",
      "#e5ae38",
      "#6d904f",
      "#8b8b8b",
      "#b96db8",
      "#ff9e27",
      "#56cc60",
      "#52d2ca",
      "#52689e",
      "#545454",
      "#9fe4f8"
    ],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: true,
    shape: "circle"
  },
  shape: { stroke: markColor$6 },
  bar: {
    binSpacing: 2,
    fill: markColor$6,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
};
var markColor$5 = "#000";
var ggplot2Theme = {
  group: {
    fill: "#e5e5e5"
  },
  arc: { fill: markColor$5 },
  area: { fill: markColor$5 },
  line: { stroke: markColor$5 },
  path: { stroke: markColor$5 },
  rect: { fill: markColor$5 },
  shape: { stroke: markColor$5 },
  symbol: { fill: markColor$5, size: 40 },
  axis: {
    domain: false,
    grid: true,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: [
      "#000000",
      "#7F7F7F",
      "#1A1A1A",
      "#999999",
      "#333333",
      "#B0B0B0",
      "#4D4D4D",
      "#C9C9C9",
      "#666666",
      "#DCDCDC"
    ]
  }
};
var headlineFontSize = 22;
var headlineFontWeight = "normal";
var labelFont$1 = "Benton Gothic, sans-serif";
var labelFontSize = 11.5;
var labelFontWeight = "normal";
var markColor$4 = "#82c6df";
var titleFont = "Benton Gothic Bold, sans-serif";
var titleFontWeight = "normal";
var titleFontSize$1 = 13;
var colorSchemes$1 = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
};
var latimesTheme = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: titleFont,
    fontSize: headlineFontSize,
    fontWeight: headlineFontWeight
  },
  arc: { fill: markColor$4 },
  area: { fill: markColor$4 },
  line: { stroke: markColor$4, strokeWidth: 2 },
  path: { stroke: markColor$4 },
  rect: { fill: markColor$4 },
  shape: { stroke: markColor$4 },
  symbol: { fill: markColor$4, size: 30 },
  axis: {
    labelFont: labelFont$1,
    labelFontSize,
    labelFontWeight,
    titleFont,
    titleFontSize: titleFontSize$1,
    titleFontWeight
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: labelFont$1,
    labelFontSize,
    symbolType: "square",
    titleFont,
    titleFontSize: titleFontSize$1,
    titleFontWeight
  },
  range: {
    category: colorSchemes$1["category-6"],
    diverging: colorSchemes$1["fireandice-6"],
    heatmap: colorSchemes$1["fire-7"],
    ordinal: colorSchemes$1["fire-7"],
    ramp: colorSchemes$1["fire-7"]
  }
};
var markColor$3 = "#ab5787";
var axisColor$1 = "#979797";
var quartzTheme = {
  background: "#f9f9f9",
  arc: { fill: markColor$3 },
  area: { fill: markColor$3 },
  line: { stroke: markColor$3 },
  path: { stroke: markColor$3 },
  rect: { fill: markColor$3 },
  shape: { stroke: markColor$3 },
  symbol: { fill: markColor$3, size: 30 },
  axis: {
    domainColor: axisColor$1,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: axisColor$1,
    tickColor: axisColor$1,
    tickWidth: 0.2,
    titleColor: axisColor$1
  },
  axisBand: {
    grid: false
  },
  axisX: {
    grid: true,
    tickSize: 10
  },
  axisY: {
    domain: false,
    grid: true,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: [
      "#ab5787",
      "#51b2e5",
      "#703c5c",
      "#168dd9",
      "#d190b6",
      "#00609f",
      "#d365ba",
      "#154866",
      "#666666",
      "#c4c4c4"
    ]
  }
};
var markColor$2 = "#3e5c69";
var voxTheme = {
  background: "#fff",
  arc: { fill: markColor$2 },
  area: { fill: markColor$2 },
  line: { stroke: markColor$2 },
  path: { stroke: markColor$2 },
  rect: { fill: markColor$2 },
  shape: { stroke: markColor$2 },
  symbol: { fill: markColor$2 },
  axis: {
    domainWidth: 0.5,
    grid: true,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: false
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
};
var markColor$1 = "#1696d2";
var axisColor = "#000000";
var backgroundColor$1 = "#FFFFFF";
var font2 = "Lato";
var labelFont = "Lato";
var sourceFont = "Lato";
var gridColor$1 = "#DEDDDD";
var titleFontSize = 18;
var colorSchemes = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
};
var urbanInstituteTheme = {
  background: backgroundColor$1,
  title: {
    anchor: "start",
    fontSize: titleFontSize,
    font: font2
  },
  axisX: {
    domain: true,
    domainColor: axisColor,
    domainWidth: 1,
    grid: false,
    labelFontSize: 12,
    labelFont,
    labelAngle: 0,
    tickColor: axisColor,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font2
  },
  axisY: {
    domain: false,
    domainWidth: 1,
    grid: true,
    gridColor: gridColor$1,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont,
    labelPadding: 8,
    ticks: false,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font2,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font2,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: colorSchemes["six-groups-cat-1"],
    diverging: colorSchemes["diverging-colors"],
    heatmap: colorSchemes["diverging-colors"],
    ordinal: colorSchemes["six-groups-seq"],
    ramp: colorSchemes["shades-blue"]
  },
  area: {
    fill: markColor$1
  },
  rect: {
    fill: markColor$1
  },
  line: {
    color: markColor$1,
    stroke: markColor$1,
    strokeWidth: 5
  },
  trail: {
    color: markColor$1,
    stroke: markColor$1,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: markColor$1,
    strokeWidth: 0.5
  },
  point: {
    filled: true
  },
  text: {
    font: sourceFont,
    color: markColor$1,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: markColor$1,
      stroke: null
    }
  },
  arc: { fill: markColor$1 },
  shape: { stroke: markColor$1 },
  symbol: { fill: markColor$1, size: 30 }
};
var markColor = "#3366CC";
var gridColor = "#ccc";
var defaultFont = "Arial, sans-serif";
var googlechartsTheme = {
  arc: { fill: markColor },
  area: { fill: markColor },
  path: { stroke: markColor },
  rect: { fill: markColor },
  shape: { stroke: markColor },
  symbol: { stroke: markColor },
  circle: { fill: markColor },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: defaultFont,
      fontSize: 12
    },
    "guide-title": {
      font: defaultFont,
      fontSize: 12
    },
    "group-title": {
      font: defaultFont,
      fontSize: 12
    }
  },
  title: {
    font: defaultFont,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor,
    tickColor: gridColor,
    domain: false,
    grid: true
  },
  range: {
    category: [
      "#4285F4",
      "#DB4437",
      "#F4B400",
      "#0F9D58",
      "#AB47BC",
      "#00ACC1",
      "#FF7043",
      "#9E9D24",
      "#5C6BC0",
      "#F06292",
      "#00796B",
      "#C2185B"
    ],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
};
var ptToPx = (value3) => value3 * (1 / 3 + 1);
var fontSmallPx = ptToPx(9);
var legendFontPx = ptToPx(10);
var fontLargePx = ptToPx(12);
var fontStandard = "Segoe UI";
var fontTitle = "wf_standard-font, helvetica, arial, sans-serif";
var firstLevelElementColor = "#252423";
var secondLevelElementColor = "#605E5C";
var backgroundColor = "transparent";
var backgroundSecondaryColor = "#C8C6C4";
var paletteColor1 = "#118DFF";
var paletteColor2 = "#12239E";
var paletteColor3 = "#E66C37";
var paletteColor4 = "#6B007B";
var paletteColor5 = "#E044A7";
var paletteColor6 = "#744EC2";
var paletteColor7 = "#D9B300";
var paletteColor8 = "#D64550";
var divergentColorMax = paletteColor1;
var divergentColorMin = "#DEEFFF";
var divergentPalette = [divergentColorMin, divergentColorMax];
var ordinalPalette = [
  divergentColorMin,
  "#c7e4ff",
  "#b0d9ff",
  "#9aceff",
  "#83c3ff",
  "#6cb9ff",
  "#55aeff",
  "#3fa3ff",
  "#2898ff",
  divergentColorMax
];
var powerbiTheme = {
  view: { stroke: backgroundColor },
  background: backgroundColor,
  font: fontStandard,
  header: {
    titleFont: fontTitle,
    titleFontSize: fontLargePx,
    titleColor: firstLevelElementColor,
    labelFont: fontStandard,
    labelFontSize: legendFontPx,
    labelColor: secondLevelElementColor
  },
  axis: {
    ticks: false,
    grid: false,
    domain: false,
    labelColor: secondLevelElementColor,
    labelFontSize: fontSmallPx,
    titleFont: fontTitle,
    titleColor: firstLevelElementColor,
    titleFontSize: fontLargePx,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: true,
    gridColor: backgroundSecondaryColor,
    gridDash: [1, 5],
    labelFlush: false
  },
  axisBand: { tickExtra: true },
  axisX: { labelPadding: 5 },
  axisY: { labelPadding: 10 },
  bar: { fill: paletteColor1 },
  line: {
    stroke: paletteColor1,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: { font: fontStandard, fontSize: fontSmallPx, fill: secondLevelElementColor },
  arc: { fill: paletteColor1 },
  area: { fill: paletteColor1, line: true, opacity: 0.6 },
  path: { stroke: paletteColor1 },
  rect: { fill: paletteColor1 },
  point: { fill: paletteColor1, filled: true, size: 75 },
  shape: { stroke: paletteColor1 },
  symbol: { fill: paletteColor1, strokeWidth: 1.5, size: 50 },
  legend: {
    titleFont: fontStandard,
    titleFontWeight: "bold",
    titleColor: secondLevelElementColor,
    labelFont: fontStandard,
    labelFontSize: legendFontPx,
    labelColor: secondLevelElementColor,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [
      paletteColor1,
      paletteColor2,
      paletteColor3,
      paletteColor4,
      paletteColor5,
      paletteColor6,
      paletteColor7,
      paletteColor8
    ],
    diverging: divergentPalette,
    heatmap: divergentPalette,
    ordinal: ordinalPalette
  }
};
var version3 = pkg.version;

// node_modules/vega-tooltip/build/vega-tooltip.module.js
var name2 = "vega-tooltip";
var version$12 = "0.28.0";
var description3 = "A tooltip plugin for Vega-Lite and Vega visualizations.";
var keywords4 = [
  "vega-lite",
  "vega",
  "tooltip"
];
var repository2 = {
  type: "git",
  url: "https://github.com/vega/vega-tooltip.git"
};
var author2 = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var collaborators = [
  "Dominik Moritz",
  "Sira Horradarn",
  "Zening Qu",
  "Kanit Wongsuphasawat",
  "Yuri Astrakhan",
  "Jeffrey Heer"
];
var license2 = "BSD-3-Clause";
var bugs = {
  url: "https://github.com/vega/vega-tooltip/issues"
};
var homepage = "https://github.com/vega/vega-tooltip#readme";
var main3 = "build/vega-tooltip.js";
var module2 = "build/vega-tooltip.module.js";
var unpkg2 = "build/vega-tooltip.min.js";
var jsdelivr2 = "build/vega-tooltip.min.js";
var types2 = "build/vega-tooltip.module.d.ts";
var files2 = [
  "src",
  "build",
  "types"
];
var scripts2 = {
  prebuild: "yarn clean && yarn build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "rimraf build && rimraf src/style.ts",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && yarn copy:build && gh-pages -d examples && yarn clean",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint && yarn test",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  pretest: "yarn build:style",
  test: "beemo jest",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prepare: "beemo create-config && yarn copy:data",
  prettierbase: "beemo prettier '*.{css,scss,html}'",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  release: "yarn run prebuild && yarn build && auto shipit"
};
var devDependencies2 = {
  "@auto-it/conventional-commits": "^10.32.3",
  "@auto-it/first-time-contributor": "^10.32.3",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.6",
  "rollup-plugin-ts": "^2.0.4",
  auto: "^10.32.3",
  "browser-sync": "^2.27.7",
  concurrently: "^6.4.0",
  "gh-pages": "^3.2.3",
  sass: "^1.44.0",
  path: "^0.12.7",
  rollup: "^2.60.2",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  typescript: "~4.5.2",
  "vega-datasets": "^2.2.0",
  "vega-lite-dev-config": "^0.20.0",
  "vega-typings": "^0.22.1"
};
var dependencies = {
  "vega-util": "^1.17.0"
};
var pkg2 = {
  name: name2,
  version: version$12,
  description: description3,
  keywords: keywords4,
  repository: repository2,
  author: author2,
  collaborators,
  license: license2,
  bugs,
  homepage,
  main: main3,
  module: module2,
  unpkg: unpkg2,
  jsdelivr: jsdelivr2,
  types: types2,
  files: files2,
  scripts: scripts2,
  devDependencies: devDependencies2,
  dependencies
};
function __rest33(s, e2) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function formatValue3(value3, valueToHtml, maxDepth) {
  if (isArray(value3)) {
    return `[${value3.map((v) => valueToHtml(isString(v) ? v : stringify2(v, maxDepth))).join(", ")}]`;
  }
  if (isObject(value3)) {
    let content2 = "";
    const _a = value3, { title: title2, image: image3 } = _a, rest = __rest33(_a, ["title", "image"]);
    if (title2) {
      content2 += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image3) {
      content2 += `<img src="${valueToHtml(image3)}">`;
    }
    const keys5 = Object.keys(rest);
    if (keys5.length > 0) {
      content2 += "<table>";
      for (const key2 of keys5) {
        let val = rest[key2];
        if (val === void 0) {
          continue;
        }
        if (isObject(val)) {
          val = stringify2(val, maxDepth);
        }
        content2 += `<tr><td class="key">${valueToHtml(key2)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content2 += `</table>`;
    }
    return content2 || "{}";
  }
  return valueToHtml(value3);
}
function replacer(maxDepth) {
  const stack2 = [];
  return function(key2, value3) {
    if (typeof value3 !== "object" || value3 === null) {
      return value3;
    }
    const pos = stack2.indexOf(this) + 1;
    stack2.length = pos;
    if (stack2.length > maxDepth) {
      return "[Object]";
    }
    if (stack2.indexOf(value3) >= 0) {
      return "[Circular]";
    }
    stack2.push(value3);
    return value3;
  };
}
function stringify2(obj, maxDepth) {
  return JSON.stringify(obj, replacer(maxDepth));
}
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element img {
  max-width: 200px;
  max-height: 200px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
var EL_ID = "vg-tooltip-element";
var DEFAULT_OPTIONS = {
  /**
   * X offset.
   */
  offsetX: 10,
  /**
   * Y offset.
   */
  offsetY: 10,
  /**
   * ID of the tooltip element.
   */
  id: EL_ID,
  /**
   * ID of the tooltip CSS style.
   */
  styleId: "vega-tooltip-style",
  /**
   * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
   *
   * There are two predefined themes: "light" (default) and "dark".
   */
  theme: "light",
  /**
   * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
   */
  disableDefaultStyle: false,
  /**
   * HTML sanitizer function that removes dangerous HTML to prevent XSS.
   *
   * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
   */
  sanitize: escapeHTML,
  /**
   * The maximum recursion depth when printing objects in the tooltip.
   */
  maxDepth: 2,
  /**
   * A function to customize the rendered HTML of the tooltip.
   * @param value A value string, or object of value strings keyed by field
   * @param sanitize The `sanitize` function from `options.sanitize`
   * @returns {string} The returned string will become the `innerHTML` of the tooltip element
   */
  formatTooltip: formatValue3
};
function escapeHTML(value3) {
  return String(value3).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id2) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id2)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle.toString().replace(EL_ID, id2);
}
function calculatePosition(event2, tooltipBox, offsetX, offsetY) {
  let x2 = event2.clientX + offsetX;
  if (x2 + tooltipBox.width > window.innerWidth) {
    x2 = +event2.clientX - offsetX - tooltipBox.width;
  }
  let y2 = event2.clientY + offsetY;
  if (y2 + tooltipBox.height > window.innerHeight) {
    y2 = +event2.clientY - offsetY - tooltipBox.height;
  }
  return { x: x2, y: y2 };
}
var Handler2 = class {
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(options) {
    this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    const elementId = this.options.id;
    this.el = null;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style2 = document.createElement("style");
      style2.setAttribute("id", this.options.styleId);
      style2.innerHTML = createDefaultStyle(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style2, head.childNodes[0]);
      } else {
        head.appendChild(style2);
      }
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(handler, event2, item, value3) {
    var _a;
    this.el = document.getElementById(this.options.id);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", this.options.id);
      this.el.classList.add("vg-tooltip");
      const tooltipContainer = (_a = document.fullscreenElement) !== null && _a !== void 0 ? _a : document.body;
      tooltipContainer.appendChild(this.el);
    }
    if (value3 == null || value3 === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(value3, this.options.sanitize, this.options.maxDepth);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x: x2, y: y2 } = calculatePosition(event2, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.setAttribute("style", `top: ${y2}px; left: ${x2}px`);
  }
};
var version4 = pkg2.version;

// node_modules/vega-embed/build/vega-embed.module.js
function _defineProperty(obj, key2, value3) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value3,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value3;
  }
  return obj;
}
function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key2, arg) {
  try {
    var info2 = gen[key2](arg);
    var value3 = info2.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info2.done) {
    resolve2(value3);
  } else {
    Promise.resolve(value3).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn.apply(self, args);
      function _next(value3) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value3);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var undefined$1;
var $Symbol = typeof Symbol === "function" ? Symbol : {};
var iteratorSymbol = $Symbol.iterator || "@@iterator";
var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
function wrap2(innerFn, outerFn, self, tryLocsList) {
  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context3 = new Context2(tryLocsList || []);
  generator._invoke = makeInvokeMethod(innerFn, self, context3);
  return generator;
}
function tryCatch(fn, obj, arg) {
  try {
    return {
      type: "normal",
      arg: fn.call(obj, arg)
    };
  } catch (err) {
    return {
      type: "throw",
      arg: err
    };
  }
}
var GenStateSuspendedStart = "suspendedStart";
var GenStateSuspendedYield = "suspendedYield";
var GenStateExecuting = "executing";
var GenStateCompleted = "completed";
var ContinueSentinel = {};
function Generator() {
}
function GeneratorFunction() {
}
function GeneratorFunctionPrototype() {
}
var IteratorPrototype = {};
IteratorPrototype[iteratorSymbol] = function() {
  return this;
};
var getProto = Object.getPrototypeOf;
var NativeIteratorPrototype = getProto && getProto(getProto(values4([])));
if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
  IteratorPrototype = NativeIteratorPrototype;
}
var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
GeneratorFunctionPrototype.constructor = GeneratorFunction;
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
function defineIteratorMethods(prototype2) {
  ["next", "throw", "return"].forEach(function(method2) {
    prototype2[method2] = function(arg) {
      return this._invoke(method2, arg);
    };
  });
}
function isGeneratorFunction(genFun) {
  var ctor = typeof genFun === "function" && genFun.constructor;
  return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
  // do is to check its .name property.
  (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
}
function mark(genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = "GeneratorFunction";
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
}
function awrap(arg) {
  return {
    __await: arg
  };
}
function AsyncIterator(generator, PromiseImpl) {
  function invoke2(method2, arg, resolve2, reject) {
    var record = tryCatch(generator[method2], generator, arg);
    if (record.type === "throw") {
      reject(record.arg);
    } else {
      var result = record.arg;
      var value3 = result.value;
      if (value3 && typeof value3 === "object" && hasOwn.call(value3, "__await")) {
        return PromiseImpl.resolve(value3.__await).then(function(value4) {
          invoke2("next", value4, resolve2, reject);
        }, function(err) {
          invoke2("throw", err, resolve2, reject);
        });
      }
      return PromiseImpl.resolve(value3).then(function(unwrapped) {
        result.value = unwrapped;
        resolve2(result);
      }, function(error2) {
        return invoke2("throw", error2, resolve2, reject);
      });
    }
  }
  var previousPromise;
  function enqueue2(method2, arg) {
    function callInvokeWithMethodAndArg() {
      return new PromiseImpl(function(resolve2, reject) {
        invoke2(method2, arg, resolve2, reject);
      });
    }
    return previousPromise = // If enqueue has been called before, then we want to wait until
    // all previous Promises have been resolved before calling invoke,
    // so that results are always delivered in the correct order. If
    // enqueue has not been called before, then it is important to
    // call invoke immediately, without waiting on a callback to fire,
    // so that the async generator function has the opportunity to do
    // any necessary setup in a predictable way. This predictability
    // is why the Promise constructor synchronously invokes its
    // executor callback, and why async functions synchronously
    // execute code before the first await. Since we implement simple
    // async functions in terms of async generators, it is especially
    // important to get this right, even though it requires care.
    previousPromise ? previousPromise.then(
      callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg
    ) : callInvokeWithMethodAndArg();
  }
  this._invoke = enqueue2;
}
defineIteratorMethods(AsyncIterator.prototype);
AsyncIterator.prototype[asyncIteratorSymbol] = function() {
  return this;
};
function async(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
  if (PromiseImpl === void 0) PromiseImpl = Promise;
  var iter = new AsyncIterator(wrap2(innerFn, outerFn, self, tryLocsList), PromiseImpl);
  return isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
    return result.done ? result.value : iter.next();
  });
}
function makeInvokeMethod(innerFn, self, context3) {
  var state = GenStateSuspendedStart;
  return function invoke2(method2, arg) {
    if (state === GenStateExecuting) {
      throw new Error("Generator is already running");
    }
    if (state === GenStateCompleted) {
      if (method2 === "throw") {
        throw arg;
      }
      return doneResult();
    }
    context3.method = method2;
    context3.arg = arg;
    while (true) {
      var delegate = context3.delegate;
      if (delegate) {
        var delegateResult = maybeInvokeDelegate(delegate, context3);
        if (delegateResult) {
          if (delegateResult === ContinueSentinel) continue;
          return delegateResult;
        }
      }
      if (context3.method === "next") {
        context3.sent = context3._sent = context3.arg;
      } else if (context3.method === "throw") {
        if (state === GenStateSuspendedStart) {
          state = GenStateCompleted;
          throw context3.arg;
        }
        context3.dispatchException(context3.arg);
      } else if (context3.method === "return") {
        context3.abrupt("return", context3.arg);
      }
      state = GenStateExecuting;
      var record = tryCatch(innerFn, self, context3);
      if (record.type === "normal") {
        state = context3.done ? GenStateCompleted : GenStateSuspendedYield;
        if (record.arg === ContinueSentinel) {
          continue;
        }
        return {
          value: record.arg,
          done: context3.done
        };
      } else if (record.type === "throw") {
        state = GenStateCompleted;
        context3.method = "throw";
        context3.arg = record.arg;
      }
    }
  };
}
function maybeInvokeDelegate(delegate, context3) {
  var method2 = delegate.iterator[context3.method];
  if (method2 === undefined$1) {
    context3.delegate = null;
    if (context3.method === "throw") {
      if (delegate.iterator["return"]) {
        context3.method = "return";
        context3.arg = undefined$1;
        maybeInvokeDelegate(delegate, context3);
        if (context3.method === "throw") {
          return ContinueSentinel;
        }
      }
      context3.method = "throw";
      context3.arg = new TypeError("The iterator does not provide a 'throw' method");
    }
    return ContinueSentinel;
  }
  var record = tryCatch(method2, delegate.iterator, context3.arg);
  if (record.type === "throw") {
    context3.method = "throw";
    context3.arg = record.arg;
    context3.delegate = null;
    return ContinueSentinel;
  }
  var info2 = record.arg;
  if (!info2) {
    context3.method = "throw";
    context3.arg = new TypeError("iterator result is not an object");
    context3.delegate = null;
    return ContinueSentinel;
  }
  if (info2.done) {
    context3[delegate.resultName] = info2.value;
    context3.next = delegate.nextLoc;
    if (context3.method !== "return") {
      context3.method = "next";
      context3.arg = undefined$1;
    }
  } else {
    return info2;
  }
  context3.delegate = null;
  return ContinueSentinel;
}
defineIteratorMethods(Gp);
Gp[toStringTagSymbol] = "Generator";
Gp[iteratorSymbol] = function() {
  return this;
};
Gp.toString = function() {
  return "[object Generator]";
};
function pushTryEntry(locs) {
  var entry2 = {
    tryLoc: locs[0]
  };
  if (1 in locs) {
    entry2.catchLoc = locs[1];
  }
  if (2 in locs) {
    entry2.finallyLoc = locs[2];
    entry2.afterLoc = locs[3];
  }
  this.tryEntries.push(entry2);
}
function resetTryEntry(entry2) {
  var record = entry2.completion || {};
  record.type = "normal";
  delete record.arg;
  entry2.completion = record;
}
function Context2(tryLocsList) {
  this.tryEntries = [{
    tryLoc: "root"
  }];
  tryLocsList.forEach(pushTryEntry, this);
  this.reset(true);
}
function keys4(object2) {
  var keys5 = [];
  for (var key2 in object2) {
    keys5.push(key2);
  }
  keys5.reverse();
  return function next() {
    while (keys5.length) {
      var key3 = keys5.pop();
      if (key3 in object2) {
        next.value = key3;
        next.done = false;
        return next;
      }
    }
    next.done = true;
    return next;
  };
}
function values4(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];
    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }
    if (typeof iterable.next === "function") {
      return iterable;
    }
    if (!isNaN(iterable.length)) {
      var i = -1, next = function next2() {
        while (++i < iterable.length) {
          if (hasOwn.call(iterable, i)) {
            next2.value = iterable[i];
            next2.done = false;
            return next2;
          }
        }
        next2.value = undefined$1;
        next2.done = true;
        return next2;
      };
      return next.next = next;
    }
  }
  return {
    next: doneResult
  };
}
function doneResult() {
  return {
    value: undefined$1,
    done: true
  };
}
Context2.prototype = {
  constructor: Context2,
  reset: function reset3(skipTempReset) {
    this.prev = 0;
    this.next = 0;
    this.sent = this._sent = undefined$1;
    this.done = false;
    this.delegate = null;
    this.method = "next";
    this.arg = undefined$1;
    this.tryEntries.forEach(resetTryEntry);
    if (!skipTempReset) {
      for (var name4 in this) {
        if (name4.charAt(0) === "t" && hasOwn.call(this, name4) && !isNaN(+name4.slice(1))) {
          this[name4] = undefined$1;
        }
      }
    }
  },
  stop: function stop2() {
    this.done = true;
    var rootEntry = this.tryEntries[0];
    var rootRecord = rootEntry.completion;
    if (rootRecord.type === "throw") {
      throw rootRecord.arg;
    }
    return this.rval;
  },
  dispatchException: function dispatchException(exception) {
    if (this.done) {
      throw exception;
    }
    var context3 = this;
    function handle(loc, caught) {
      record.type = "throw";
      record.arg = exception;
      context3.next = loc;
      if (caught) {
        context3.method = "next";
        context3.arg = undefined$1;
      }
      return !!caught;
    }
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      var record = entry2.completion;
      if (entry2.tryLoc === "root") {
        return handle("end");
      }
      if (entry2.tryLoc <= this.prev) {
        var hasCatch = hasOwn.call(entry2, "catchLoc");
        var hasFinally = hasOwn.call(entry2, "finallyLoc");
        if (hasCatch && hasFinally) {
          if (this.prev < entry2.catchLoc) {
            return handle(entry2.catchLoc, true);
          } else if (this.prev < entry2.finallyLoc) {
            return handle(entry2.finallyLoc);
          }
        } else if (hasCatch) {
          if (this.prev < entry2.catchLoc) {
            return handle(entry2.catchLoc, true);
          }
        } else if (hasFinally) {
          if (this.prev < entry2.finallyLoc) {
            return handle(entry2.finallyLoc);
          }
        } else {
          throw new Error("try statement without catch or finally");
        }
      }
    }
  },
  abrupt: function abrupt(type3, arg) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      if (entry2.tryLoc <= this.prev && hasOwn.call(entry2, "finallyLoc") && this.prev < entry2.finallyLoc) {
        var finallyEntry = entry2;
        break;
      }
    }
    if (finallyEntry && (type3 === "break" || type3 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
      finallyEntry = null;
    }
    var record = finallyEntry ? finallyEntry.completion : {};
    record.type = type3;
    record.arg = arg;
    if (finallyEntry) {
      this.method = "next";
      this.next = finallyEntry.finallyLoc;
      return ContinueSentinel;
    }
    return this.complete(record);
  },
  complete: function complete(record, afterLoc) {
    if (record.type === "throw") {
      throw record.arg;
    }
    if (record.type === "break" || record.type === "continue") {
      this.next = record.arg;
    } else if (record.type === "return") {
      this.rval = this.arg = record.arg;
      this.method = "return";
      this.next = "end";
    } else if (record.type === "normal" && afterLoc) {
      this.next = afterLoc;
    }
    return ContinueSentinel;
  },
  finish: function finish(finallyLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      if (entry2.finallyLoc === finallyLoc) {
        this.complete(entry2.completion, entry2.afterLoc);
        resetTryEntry(entry2);
        return ContinueSentinel;
      }
    }
  },
  "catch": function _catch(tryLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry2 = this.tryEntries[i];
      if (entry2.tryLoc === tryLoc) {
        var record = entry2.completion;
        if (record.type === "throw") {
          var thrown = record.arg;
          resetTryEntry(entry2);
        }
        return thrown;
      }
    }
    throw new Error("illegal catch attempt");
  },
  delegateYield: function delegateYield(iterable, resultName, nextLoc) {
    this.delegate = {
      iterator: values4(iterable),
      resultName,
      nextLoc
    };
    if (this.method === "next") {
      this.arg = undefined$1;
    }
    return ContinueSentinel;
  }
};
var _regeneratorRuntime = {
  wrap: wrap2,
  isGeneratorFunction,
  AsyncIterator,
  mark,
  awrap,
  async,
  keys: keys4,
  values: values4
};
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self = this;
  if (!(self instanceof Yallist$1)) {
    self = new Yallist$1();
  }
  self.tail = null;
  self.head = null;
  self.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }
  return self;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
    walker = insert2(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? void 0 : arguments[i + 2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert2(self, node, value3) {
  var inserted = node === self.head ? new Node(value3, null, node, self) : new Node(value3, node, node.next, self);
  if (inserted.next === null) {
    self.tail = inserted;
  }
  if (inserted.prev === null) {
    self.head = inserted;
  }
  self.length++;
  return inserted;
}
function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);
  if (!self.head) {
    self.head = self.tail;
  }
  self.length++;
}
function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);
  if (!self.tail) {
    self.tail = self.head;
  }
  self.length++;
}
function Node(value3, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value3, prev, next, list);
  }
  this.list = list;
  this.value = value3;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  Yallist$1.prototype[Symbol.iterator] = _regeneratorRuntime.mark(function _callee() {
    var walker;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;
          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }
            _context.next = 4;
            return walker.value;
          case 4:
            walker = walker.next;
            _context.next = 1;
            break;
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
} catch (er) {
}
var Yallist = yallist;
var MAX = Symbol("max");
var LENGTH = Symbol("length");
var LENGTH_CALCULATOR = Symbol("lengthCalculator");
var ALLOW_STALE = Symbol("allowStale");
var MAX_AGE = Symbol("maxAge");
var DISPOSE = Symbol("dispose");
var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
var LRU_LIST = Symbol("lruList");
var CACHE2 = Symbol("cache");
var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
var naiveLength = () => 1;
var LRUCache = class {
  constructor(options) {
    if (typeof options === "number") options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function") lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit2) => {
        hit2.length = this[LENGTH_CALCULATOR](hit2.value, hit2.key);
        this[LENGTH] += hit2.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].tail; walker !== null; ) {
      var prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].head; walker !== null; ) {
      var next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k2) => k2.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k2) => k2.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit2) => this[DISPOSE](hit2.key, hit2.value));
    }
    this[CACHE2] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit2) => isStale(this, hit2) ? false : {
      k: hit2.key,
      v: hit2.value,
      e: hit2.now + (hit2.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key2, value3, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
    var now = maxAge ? Date.now() : 0;
    var len = this[LENGTH_CALCULATOR](value3, key2);
    if (this[CACHE2].has(key2)) {
      if (len > this[MAX]) {
        del(this, this[CACHE2].get(key2));
        return false;
      }
      var node = this[CACHE2].get(key2);
      var item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key2, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value3;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key2);
      trim(this);
      return true;
    }
    var hit2 = new Entry2(key2, value3, len, now, maxAge);
    if (hit2.length > this[MAX]) {
      if (this[DISPOSE]) this[DISPOSE](key2, value3);
      return false;
    }
    this[LENGTH] += hit2.length;
    this[LRU_LIST].unshift(hit2);
    this[CACHE2].set(key2, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key2) {
    if (!this[CACHE2].has(key2)) return false;
    var hit2 = this[CACHE2].get(key2).value;
    return !isStale(this, hit2);
  }
  get(key2) {
    return get5(this, key2, true);
  }
  peek(key2) {
    return get5(this, key2, false);
  }
  pop() {
    var node = this[LRU_LIST].tail;
    if (!node) return null;
    del(this, node);
    return node.value;
  }
  del(key2) {
    del(this, this[CACHE2].get(key2));
  }
  load(arr) {
    this.reset();
    var now = Date.now();
    for (var l = arr.length - 1; l >= 0; l--) {
      var hit2 = arr[l];
      var expiresAt = hit2.e || 0;
      if (expiresAt === 0)
        this.set(hit2.k, hit2.v);
      else {
        var maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit2.k, hit2.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE2].forEach((value3, key2) => get5(this, key2, false));
  }
};
var get5 = (self, key2, doUse) => {
  var node = self[CACHE2].get(key2);
  if (node) {
    var hit2 = node.value;
    if (isStale(self, hit2)) {
      del(self, node);
      if (!self[ALLOW_STALE]) return void 0;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }
    return hit2.value;
  }
};
var isStale = (self, hit2) => {
  if (!hit2 || !hit2.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit2.now;
  return hit2.maxAge ? diff > hit2.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
var trim = (self) => {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
      var prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
  }
};
var del = (self, node) => {
  if (node) {
    var hit2 = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit2.key, hit2.value);
    self[LENGTH] -= hit2.length;
    self[CACHE2].delete(hit2.key);
    self[LRU_LIST].removeNode(node);
  }
};
var Entry2 = class {
  constructor(key2, value3, length3, now, maxAge) {
    this.key = key2;
    this.value = value3;
    this.length = length3;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
};
var forEachStep = (self, fn, node, thisp) => {
  var hit2 = node.value;
  if (isStale(self, hit2)) {
    del(self, node);
    if (!self[ALLOW_STALE]) hit2 = void 0;
  }
  if (hit2) fn.call(thisp, hit2.value, hit2.key, self);
};
var lruCache2 = LRUCache;
var opts = ["includePrerelease", "loose", "rtl"];
var parseOptions$1 = (options) => !options ? {} : typeof options !== "object" ? {
  loose: true
} : opts.filter((k2) => options[k2]).reduce((o, k2) => {
  o[k2] = true;
  return o;
}, {});
var parseOptions_1 = parseOptions$1;
var re$1 = { exports: {} };
var SEMVER_SPEC_VERSION = "2.0.0";
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
var debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return console.error("SEMVER", ...args);
} : () => {
};
var debug_1 = debug$1;
(function(module4, exports) {
  var MAX_SAFE_COMPONENT_LENGTH2 = constants.MAX_SAFE_COMPONENT_LENGTH;
  var debug4 = debug_1;
  exports = module4.exports = {};
  var re2 = exports.re = [];
  var src = exports.src = [];
  var t2 = exports.t = {};
  var R = 0;
  var createToken = (name4, value3, isGlobal) => {
    var index3 = R++;
    debug4(name4, index3, value3);
    t2[name4] = index3;
    src[index3] = value3;
    re2[index3] = new RegExp(value3, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", "(".concat(src[t2.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIER], ")"));
  createToken("MAINVERSIONLOOSE", "(".concat(src[t2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIERLOOSE], ")"));
  createToken("PRERELEASEIDENTIFIER", "(?:".concat(src[t2.NUMERICIDENTIFIER], "|").concat(src[t2.NONNUMERICIDENTIFIER], ")"));
  createToken("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(src[t2.NUMERICIDENTIFIERLOOSE], "|").concat(src[t2.NONNUMERICIDENTIFIER], ")"));
  createToken("PRERELEASE", "(?:-(".concat(src[t2.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t2.PRERELEASEIDENTIFIER], ")*))"));
  createToken("PRERELEASELOOSE", "(?:-?(".concat(src[t2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t2.PRERELEASEIDENTIFIERLOOSE], ")*))"));
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", "(?:\\+(".concat(src[t2.BUILDIDENTIFIER], "(?:\\.").concat(src[t2.BUILDIDENTIFIER], ")*))"));
  createToken("FULLPLAIN", "v?".concat(src[t2.MAINVERSION]).concat(src[t2.PRERELEASE], "?").concat(src[t2.BUILD], "?"));
  createToken("FULL", "^".concat(src[t2.FULLPLAIN], "$"));
  createToken("LOOSEPLAIN", "[v=\\s]*".concat(src[t2.MAINVERSIONLOOSE]).concat(src[t2.PRERELEASELOOSE], "?").concat(src[t2.BUILD], "?"));
  createToken("LOOSE", "^".concat(src[t2.LOOSEPLAIN], "$"));
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", "".concat(src[t2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
  createToken("XRANGEIDENTIFIER", "".concat(src[t2.NUMERICIDENTIFIER], "|x|X|\\*"));
  createToken("XRANGEPLAIN", "[v=\\s]*(".concat(src[t2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t2.PRERELEASE], ")?").concat(src[t2.BUILD], "?") + ")?)?");
  createToken("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(src[t2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t2.PRERELEASELOOSE], ")?").concat(src[t2.BUILD], "?") + ")?)?");
  createToken("XRANGE", "^".concat(src[t2.GTLT], "\\s*").concat(src[t2.XRANGEPLAIN], "$"));
  createToken("XRANGELOOSE", "^".concat(src[t2.GTLT], "\\s*").concat(src[t2.XRANGEPLAINLOOSE], "$"));
  createToken("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(MAX_SAFE_COMPONENT_LENGTH2, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH2, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH2, "}))?") + "(?:$|[^\\d])");
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", "(\\s*)".concat(src[t2.LONETILDE], "\\s+"), true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", "^".concat(src[t2.LONETILDE]).concat(src[t2.XRANGEPLAIN], "$"));
  createToken("TILDELOOSE", "^".concat(src[t2.LONETILDE]).concat(src[t2.XRANGEPLAINLOOSE], "$"));
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", "(\\s*)".concat(src[t2.LONECARET], "\\s+"), true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", "^".concat(src[t2.LONECARET]).concat(src[t2.XRANGEPLAIN], "$"));
  createToken("CARETLOOSE", "^".concat(src[t2.LONECARET]).concat(src[t2.XRANGEPLAINLOOSE], "$"));
  createToken("COMPARATORLOOSE", "^".concat(src[t2.GTLT], "\\s*(").concat(src[t2.LOOSEPLAIN], ")$|^$"));
  createToken("COMPARATOR", "^".concat(src[t2.GTLT], "\\s*(").concat(src[t2.FULLPLAIN], ")$|^$"));
  createToken("COMPARATORTRIM", "(\\s*)".concat(src[t2.GTLT], "\\s*(").concat(src[t2.LOOSEPLAIN], "|").concat(src[t2.XRANGEPLAIN], ")"), true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", "^\\s*(".concat(src[t2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t2.XRANGEPLAIN], ")") + "\\s*$");
  createToken("HYPHENRANGELOOSE", "^\\s*(".concat(src[t2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t2.XRANGEPLAINLOOSE], ")") + "\\s*$");
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$1, re$1.exports);
var numeric = /^[0-9]+$/;
var compareIdentifiers$1 = (a, b2) => {
  var anum = numeric.test(a);
  var bnum = numeric.test(b2);
  if (anum && bnum) {
    a = +a;
    b2 = +b2;
  }
  return a === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b2 ? -1 : 1;
};
var rcompareIdentifiers = (a, b2) => compareIdentifiers$1(b2, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
var debug3 = debug_1;
var MAX_LENGTH = constants.MAX_LENGTH;
var MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
var re = re$1.exports.re;
var t = re$1.exports.t;
var parseOptions = parseOptions_1;
var compareIdentifiers = identifiers.compareIdentifiers;
var SemVer$1 = class _SemVer$1 {
  constructor(version6, options) {
    options = parseOptions(options);
    if (version6 instanceof _SemVer$1) {
      if (version6.loose === !!options.loose && version6.includePrerelease === !!options.includePrerelease) {
        return version6;
      } else {
        version6 = version6.version;
      }
    } else if (typeof version6 !== "string") {
      throw new TypeError("Invalid Version: ".concat(version6));
    }
    if (version6.length > MAX_LENGTH) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
    }
    debug3("SemVer", version6, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    var m = version6.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: ".concat(version6));
    }
    this.raw = version6;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          var num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    if (this.prerelease.length) {
      this.version += "-".concat(this.prerelease.join("."));
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug3("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof _SemVer$1)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new _SemVer$1(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof _SemVer$1)) {
      other = new _SemVer$1(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof _SemVer$1)) {
      other = new _SemVer$1(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i = 0;
    do {
      var a = this.prerelease[i];
      var b2 = other.prerelease[i];
      debug3("prerelease compare", i, a, b2);
      if (a === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b2) {
        continue;
      } else {
        return compareIdentifiers(a, b2);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof _SemVer$1)) {
      other = new _SemVer$1(other, this.options);
    }
    var i = 0;
    do {
      var a = this.build[i];
      var b2 = other.build[i];
      debug3("prerelease compare", i, a, b2);
      if (a === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b2) {
        continue;
      } else {
        return compareIdentifiers(a, b2);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: ".concat(release));
    }
    this.format();
    this.raw = this.version;
    return this;
  }
};
var semver = SemVer$1;
var SemVer = semver;
var compare$6 = (a, b2, loose) => new SemVer(a, loose).compare(new SemVer(b2, loose));
var compare_1 = compare$6;
var compare$5 = compare_1;
var eq$1 = (a, b2, loose) => compare$5(a, b2, loose) === 0;
var eq_1 = eq$1;
var compare$4 = compare_1;
var neq$1 = (a, b2, loose) => compare$4(a, b2, loose) !== 0;
var neq_1 = neq$1;
var compare$3 = compare_1;
var gt$1 = (a, b2, loose) => compare$3(a, b2, loose) > 0;
var gt_1 = gt$1;
var compare$2 = compare_1;
var gte$1 = (a, b2, loose) => compare$2(a, b2, loose) >= 0;
var gte_1 = gte$1;
var compare$1 = compare_1;
var lt$1 = (a, b2, loose) => compare$1(a, b2, loose) < 0;
var lt_1 = lt$1;
var compare4 = compare_1;
var lte$1 = (a, b2, loose) => compare4(a, b2, loose) <= 0;
var lte_1 = lte$1;
var eq = eq_1;
var neq = neq_1;
var gt = gt_1;
var gte = gte_1;
var lt = lt_1;
var lte = lte_1;
var cmp = (a, op, b2, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a === b2;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a !== b2;
    case "":
    case "=":
    case "==":
      return eq(a, b2, loose);
    case "!=":
      return neq(a, b2, loose);
    case ">":
      return gt(a, b2, loose);
    case ">=":
      return gte(a, b2, loose);
    case "<":
      return lt(a, b2, loose);
    case "<=":
      return lte(a, b2, loose);
    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};
var cmp_1 = cmp;
var comparator2;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator2;
  hasRequiredComparator = 1;
  var ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug4("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug4("comp", this);
    }
    parse(comp) {
      var r2 = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      var m = comp.match(r2);
      if (!m) {
        throw new TypeError("Invalid comparator: ".concat(comp));
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer2(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version6) {
      debug4("Comparator.test", version6, this.options.loose);
      if (this.semver === ANY || version6 === ANY) {
        return true;
      }
      if (typeof version6 === "string") {
        try {
          version6 = new SemVer2(version6, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version6, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp2(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      var oppositeDirectionsGreaterThan = cmp2(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }
  comparator2 = Comparator;
  var parseOptions2 = parseOptions_1;
  var re2 = re$1.exports.re, t2 = re$1.exports.t;
  var cmp2 = cmp_1;
  var debug4 = debug_1;
  var SemVer2 = semver;
  var Range2 = requireRange();
  return comparator2;
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var range5;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range5;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range6, options) {
      options = parseOptions2(options);
      if (range6 instanceof Range2) {
        if (range6.loose === !!options.loose && range6.includePrerelease === !!options.includePrerelease) {
          return range6;
        } else {
          return new Range2(range6.raw, options);
        }
      }
      if (range6 instanceof Comparator) {
        this.raw = range6.value;
        this.set = [[range6]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range6;
      this.set = range6.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: ".concat(range6));
      }
      if (this.set.length > 1) {
        var first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          var _iterator = _createForOfIteratorHelper$1(this.set), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var c = _step.value;
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range6) {
      range6 = range6.trim();
      var memoOpts = Object.keys(this.options).join(",");
      var memoKey = "parseRange:".concat(memoOpts, ":").concat(range6);
      var cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      var loose = this.options.loose;
      var hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range6 = range6.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug4("hyphen replace", range6);
      range6 = range6.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug4("comparator trim", range6);
      range6 = range6.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      range6 = range6.replace(re2[t2.CARETTRIM], caretTrimReplace);
      range6 = range6.split(/\s+/).join(" ");
      var rangeList = range6.split(" ").map((comp2) => parseComparator(comp2, this.options)).join(" ").split(/\s+/).map((comp2) => replaceGTE0(comp2, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp2) => {
          debug4("loose invalid filter", comp2, this.options);
          return !!comp2.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug4("range list", rangeList);
      var rangeMap = /* @__PURE__ */ new Map();
      var comparators = rangeList.map((comp2) => new Comparator(comp2, this.options));
      var _iterator2 = _createForOfIteratorHelper$1(comparators), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var comp = _step2.value;
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      var result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range6, options) {
      if (!(range6 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range6.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version6) {
      if (!version6) {
        return false;
      }
      if (typeof version6 === "string") {
        try {
          version6 = new SemVer2(version6, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version6, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range5 = Range2;
  var LRU = lruCache2;
  var cache2 = new LRU({
    max: 1e3
  });
  var parseOptions2 = parseOptions_1;
  var Comparator = requireComparator();
  var debug4 = debug_1;
  var SemVer2 = semver;
  var re2 = re$1.exports.re, t2 = re$1.exports.t, comparatorTrimReplace = re$1.exports.comparatorTrimReplace, tildeTrimReplace = re$1.exports.tildeTrimReplace, caretTrimReplace = re$1.exports.caretTrimReplace;
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug4("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug4("caret", comp);
    comp = replaceTildes(comp, options);
    debug4("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug4("xrange", comp);
    comp = replaceStars(comp, options);
    debug4("stars", comp);
    return comp;
  };
  var isX2 = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options);
  }).join(" ");
  var replaceTilde = (comp, options) => {
    var r2 = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r2, (_, M, m, p, pr) => {
      debug4("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX2(M)) {
        ret = "";
      } else if (isX2(m)) {
        ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
      } else if (isX2(p)) {
        ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
      } else if (pr) {
        debug4("replaceTilde pr", pr);
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
      }
      debug4("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options);
  }).join(" ");
  var replaceCaret = (comp, options) => {
    debug4("caret", comp, options);
    var r2 = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    var z = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M, m, p, pr) => {
      debug4("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX2(M)) {
        ret = "";
      } else if (isX2(m)) {
        ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
      } else if (isX2(p)) {
        if (M === "0") {
          ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
        }
      } else if (pr) {
        debug4("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
        }
      } else {
        debug4("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
        }
      }
      debug4("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug4("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => {
      return replaceXRange(c, options);
    }).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    var r2 = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r2, (ret, gtlt, M, m, p, pr) => {
      debug4("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX2(M);
      var xm = xM || isX2(m);
      var xp = xm || isX2(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
      } else if (xm) {
        ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
      } else if (xp) {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
      }
      debug4("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug4("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug4("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX2(fM)) {
      from = "";
    } else if (isX2(fm)) {
      from = ">=".concat(fM, ".0.0").concat(incPr ? "-0" : "");
    } else if (isX2(fp)) {
      from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? "-0" : "");
    } else if (fpr) {
      from = ">=".concat(from);
    } else {
      from = ">=".concat(from).concat(incPr ? "-0" : "");
    }
    if (isX2(tM)) {
      to = "";
    } else if (isX2(tm)) {
      to = "<".concat(+tM + 1, ".0.0-0");
    } else if (isX2(tp)) {
      to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
    } else if (tpr) {
      to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
    } else if (incPr) {
      to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
    } else {
      to = "<=".concat(to);
    }
    return "".concat(from, " ").concat(to).trim();
  };
  var testSet = (set5, version6, options) => {
    for (var i = 0; i < set5.length; i++) {
      if (!set5[i].test(version6)) {
        return false;
      }
    }
    if (version6.prerelease.length && !options.includePrerelease) {
      for (var _i = 0; _i < set5.length; _i++) {
        debug4(set5[_i].semver);
        if (set5[_i].semver === Comparator.ANY) {
          continue;
        }
        if (set5[_i].semver.prerelease.length > 0) {
          var allowed = set5[_i].semver;
          if (allowed.major === version6.major && allowed.minor === version6.minor && allowed.patch === version6.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range5;
}
var Range = requireRange();
var satisfies = (version6, range6, options) => {
  try {
    range6 = new Range(range6, options);
  } catch (er) {
    return false;
  }
  return range6.test(version6);
};
var satisfies_1 = satisfies;
function post(window2, url, data3) {
  var editor = window2.open(url);
  var wait = 1e4;
  var step = 250;
  var _URL = new URL(url), origin = _URL.origin;
  var count = ~~(wait / step);
  function listen(evt) {
    if (evt.source === editor) {
      count = 0;
      window2.removeEventListener("message", listen, false);
    }
  }
  window2.addEventListener("message", listen, false);
  function send() {
    if (count <= 0) {
      return;
    }
    editor.postMessage(data3, origin);
    setTimeout(send, step);
    count -= 1;
  }
  setTimeout(send, step);
}
var embedStyle = '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n';
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
function mergeDeep2(dest) {
  for (var _len = arguments.length, src = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    src[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _src = src; _i < _src.length; _i++) {
    var s = _src[_i];
    deepMerge_2(dest, s);
  }
  return dest;
}
function deepMerge_2(dest, src) {
  for (var _i2 = 0, _Object$keys = Object.keys(src); _i2 < _Object$keys.length; _i2++) {
    var property2 = _Object$keys[_i2];
    writeConfig(dest, property2, src[property2], true);
  }
}
var name3 = "vega-embed";
var version$13 = "6.21.0";
var description4 = "Publish Vega visualizations as embedded web components.";
var keywords5 = ["vega", "data", "visualization", "component", "embed"];
var repository3 = {
  type: "git",
  url: "http://github.com/vega/vega-embed.git"
};
var author3 = {
  name: "UW Interactive Data Lab",
  url: "http://idl.cs.washington.edu"
};
var contributors2 = [{
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}];
var bugs2 = {
  url: "https://github.com/vega/vega-embed/issues"
};
var homepage2 = "https://github.com/vega/vega-embed#readme";
var license3 = "BSD-3-Clause";
var main4 = "build/vega-embed.js";
var module3 = "build/vega-embed.module.js";
var unpkg3 = "build/vega-embed.min.js";
var jsdelivr3 = "build/vega-embed.min.js";
var types3 = "build/vega-embed.module.d.ts";
var files3 = ["src", "build", "build-es5", "patches"];
var devDependencies3 = {
  "@auto-it/conventional-commits": "^10.37.1",
  "@auto-it/first-time-contributor": "^10.37.1",
  "@babel/plugin-transform-runtime": "^7.18.2",
  "@rollup/plugin-commonjs": "22.0.0",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.3.0",
  "@types/semver": "^7.3.9",
  auto: "^10.37.1",
  "browser-sync": "^2.27.10",
  concurrently: "^7.2.1",
  "del-cli": "^4.0.1",
  "jest-canvas-mock": "^2.4.0",
  "patch-package": "^6.4.7",
  "postinstall-postinstall": "^2.1.0",
  rollup: "2.75.6",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  "rollup-plugin-ts": "^3.0.0",
  sass: "^1.52.1",
  typescript: "^4.7.2",
  vega: "^5.22.1",
  "vega-lite": "^5.2.0",
  "vega-lite-dev-config": "^0.20.0"
};
var peerDependencies2 = {
  vega: "^5.21.0",
  "vega-lite": "*"
};
var dependencies2 = {
  "fast-json-patch": "^3.1.1",
  "json-stringify-pretty-compact": "^3.0.0",
  semver: "^7.3.7",
  tslib: "^2.4.0",
  "vega-interpreter": "^1.0.4",
  "vega-schema-url-parser": "^2.2.0",
  "vega-themes": "^2.10.0",
  "vega-tooltip": "^0.28.0"
};
var bundledDependencies = ["yallist"];
var scripts3 = {
  prebuild: "yarn clean && yarn build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "del-cli build build-es5 src/style.ts",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint && yarn test",
  serve: "browser-sync start --directory -s -f build *.html",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  pretest: "yarn build:style",
  test: "beemo jest --stdio stream",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prepare: "beemo create-config && npx patch-package",
  prettierbase: "beemo prettier '*.{css,scss,html}'",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  release: "yarn build && auto shipit"
};
var pkg3 = {
  name: name3,
  version: version$13,
  description: description4,
  keywords: keywords5,
  repository: repository3,
  author: author3,
  contributors: contributors2,
  bugs: bugs2,
  homepage: homepage2,
  license: license3,
  main: main4,
  module: module3,
  unpkg: unpkg3,
  jsdelivr: jsdelivr3,
  types: types3,
  files: files3,
  devDependencies: devDependencies3,
  peerDependencies: peerDependencies2,
  dependencies: dependencies2,
  bundledDependencies,
  scripts: scripts3
};
var _w$vl;
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys(object2, enumerableOnly) {
  var keys5 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols4 = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols4 = symbols4.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys5.push.apply(keys5, symbols4);
  }
  return keys5;
}
function _objectSpread(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source4 = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source4), true).forEach(function(key2) {
      _defineProperty(target2, key2, source4[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source4)) : ownKeys(Object(source4)).forEach(function(key2) {
      Object.defineProperty(target2, key2, Object.getOwnPropertyDescriptor(source4, key2));
    });
  }
  return target2;
}
var version5 = pkg3.version;
var vega = vega_module_exports;
var _vegaLite = src_exports3;
var w3 = typeof window !== "undefined" ? window : void 0;
if (_vegaLite === void 0 && w3 !== null && w3 !== void 0 && (_w$vl = w3.vl) !== null && _w$vl !== void 0 && _w$vl.compile) {
  _vegaLite = w3.vl;
}
var DEFAULT_ACTIONS = {
  export: {
    svg: true,
    png: true
  },
  source: true,
  compiled: true,
  editor: true
};
var I18N = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
};
var NAMES = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
};
var VERSION = {
  vega: vega.version,
  "vega-lite": _vegaLite ? _vegaLite.version : "not available"
};
var PREPROCESSOR = {
  vega: (vgSpec) => vgSpec,
  "vega-lite": (vlSpec, config) => _vegaLite.compile(vlSpec, {
    config
  }).spec
};
var SVG_CIRCLES = '\n<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n  <circle r="2" cy="8" cx="2"></circle>\n  <circle r="2" cy="8" cx="8"></circle>\n  <circle r="2" cy="8" cx="14"></circle>\n</svg>';
var CHART_WRAPPER_CLASS = "chart-wrapper";
function isTooltipHandler(h2) {
  return typeof h2 === "function";
}
function viewSource(source4, sourceHeader, sourceFooter, mode) {
  var header = "<html><head>".concat(sourceHeader, '</head><body><pre><code class="json">');
  var footer = "</code></pre>".concat(sourceFooter, "</body></html>");
  var win = window.open("");
  win.document.write(header + source4 + footer);
  win.document.title = "".concat(NAMES[mode], " JSON Source");
}
function guessMode(spec, providedMode) {
  if (spec.$schema) {
    var parsed = parser_module_default(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      var _NAMES$providedMode;
      console.warn("The given visualization spec is written in ".concat(NAMES[parsed.library], ", but mode argument sets ").concat((_NAMES$providedMode = NAMES[providedMode]) !== null && _NAMES$providedMode !== void 0 ? _NAMES$providedMode : providedMode, "."));
    }
    var mode = parsed.library;
    if (!satisfies_1(VERSION[mode], "^".concat(parsed.version.slice(1)))) {
      console.warn("The input spec uses ".concat(NAMES[mode], " ").concat(parsed.version, ", but the current version of ").concat(NAMES[mode], " is v").concat(VERSION[mode], "."));
    }
    return mode;
  }
  if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
    return "vega-lite";
  }
  if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
    return "vega";
  }
  return providedMode !== null && providedMode !== void 0 ? providedMode : "vega";
}
function isLoader(o) {
  return !!(o && "load" in o);
}
function createLoader(opts2) {
  return isLoader(opts2) ? opts2 : vega.loader(opts2);
}
function embedOptionsFromUsermeta(parsedSpec) {
  var _embedOptions, _parsedSpec$usermeta;
  var opts2 = (_embedOptions = (_parsedSpec$usermeta = parsedSpec.usermeta) === null || _parsedSpec$usermeta === void 0 ? void 0 : _parsedSpec$usermeta.embedOptions) !== null && _embedOptions !== void 0 ? _embedOptions : {};
  if (isString(opts2.defaultStyle)) {
    opts2.defaultStyle = false;
  }
  return opts2;
}
function embed(_x3, _x22) {
  return _embed2.apply(this, arguments);
}
function _embed2() {
  _embed2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(el, spec) {
    var _parsedOpts$config, _usermetaOpts$config;
    var opts2, parsedSpec, loader2, loadedEmbedOptions, usermetaLoader, _opts$loader, usermetaOpts, parsedOpts, mergedOpts, _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts2 = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
            if (!isString(spec)) {
              _context.next = 10;
              break;
            }
            loader2 = createLoader(opts2.loader);
            _context.t0 = JSON;
            _context.next = 6;
            return loader2.load(spec);
          case 6:
            _context.t1 = _context.sent;
            parsedSpec = _context.t0.parse.call(_context.t0, _context.t1);
            _context.next = 11;
            break;
          case 10:
            parsedSpec = spec;
          case 11:
            loadedEmbedOptions = embedOptionsFromUsermeta(parsedSpec);
            usermetaLoader = loadedEmbedOptions.loader;
            if (!loader2 || usermetaLoader) {
              loader2 = createLoader((_opts$loader = opts2.loader) !== null && _opts$loader !== void 0 ? _opts$loader : usermetaLoader);
            }
            _context.next = 16;
            return loadOpts(loadedEmbedOptions, loader2);
          case 16:
            usermetaOpts = _context.sent;
            _context.next = 19;
            return loadOpts(opts2, loader2);
          case 19:
            parsedOpts = _context.sent;
            mergedOpts = _objectSpread(_objectSpread({}, mergeDeep2(parsedOpts, usermetaOpts)), {}, {
              config: mergeConfig((_parsedOpts$config = parsedOpts.config) !== null && _parsedOpts$config !== void 0 ? _parsedOpts$config : {}, (_usermetaOpts$config = usermetaOpts.config) !== null && _usermetaOpts$config !== void 0 ? _usermetaOpts$config : {})
            });
            _context.next = 23;
            return _embed(el, parsedSpec, mergedOpts, loader2);
          case 23:
            return _context.abrupt("return", _context.sent);
          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _embed2.apply(this, arguments);
}
function loadOpts(_x3, _x4) {
  return _loadOpts.apply(this, arguments);
}
function _loadOpts() {
  _loadOpts = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(opt, loader2) {
    var _opt$config;
    var config, patch2;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!isString(opt.config)) {
              _context2.next = 8;
              break;
            }
            _context2.t1 = JSON;
            _context2.next = 4;
            return loader2.load(opt.config);
          case 4:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 9;
            break;
          case 8:
            _context2.t0 = (_opt$config = opt.config) !== null && _opt$config !== void 0 ? _opt$config : {};
          case 9:
            config = _context2.t0;
            if (!isString(opt.patch)) {
              _context2.next = 18;
              break;
            }
            _context2.t4 = JSON;
            _context2.next = 14;
            return loader2.load(opt.patch);
          case 14:
            _context2.t5 = _context2.sent;
            _context2.t3 = _context2.t4.parse.call(_context2.t4, _context2.t5);
            _context2.next = 19;
            break;
          case 18:
            _context2.t3 = opt.patch;
          case 19:
            patch2 = _context2.t3;
            return _context2.abrupt("return", _objectSpread(_objectSpread(_objectSpread({}, opt), patch2 ? {
              patch: patch2
            } : {}), config ? {
              config
            } : {}));
          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadOpts.apply(this, arguments);
}
function getRoot(el) {
  var _document$head;
  var possibleRoot = el.getRootNode ? el.getRootNode() : document;
  return possibleRoot instanceof ShadowRoot ? {
    root: possibleRoot,
    rootContainer: possibleRoot
  } : {
    root: document,
    rootContainer: (_document$head = document.head) !== null && _document$head !== void 0 ? _document$head : document.body
  };
}
function _embed(_x5, _x6) {
  return _embed3.apply(this, arguments);
}
function _embed3() {
  _embed3 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(el, spec) {
    var _opts$config, _opts$actions, _opts$renderer, _opts$logLevel, _opts$downloadFileNam, _ref, _expressionInterprete;
    var opts2, loader2, config, actions, i18n, renderer, logLevel, downloadFileName, element3, ID, _getRoot, root, rootContainer, style2, mode, vgSpec, parsed, container, chartWrapper, patch2, name4, expressionFunction2, ast, runtime2, view, handler, hover2, _ref2, hoverSet, updateSet, documentClickHandler, wrapper, details, summary, ctrl, _iterator, _step, _loop, viewSourceLink, compileLink, _opts$editorUrl, editorUrl, editorLink, finalize2, _args4 = arguments;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            finalize2 = function _finalize() {
              if (documentClickHandler) {
                document.removeEventListener("click", documentClickHandler);
              }
              view.finalize();
            };
            opts2 = _args4.length > 2 && _args4[2] !== void 0 ? _args4[2] : {};
            loader2 = _args4.length > 3 ? _args4[3] : void 0;
            config = opts2.theme ? mergeConfig(vega_themes_module_exports[opts2.theme], (_opts$config = opts2.config) !== null && _opts$config !== void 0 ? _opts$config : {}) : opts2.config;
            actions = isBoolean(opts2.actions) ? opts2.actions : mergeDeep2({}, DEFAULT_ACTIONS, (_opts$actions = opts2.actions) !== null && _opts$actions !== void 0 ? _opts$actions : {});
            i18n = _objectSpread(_objectSpread({}, I18N), opts2.i18n);
            renderer = (_opts$renderer = opts2.renderer) !== null && _opts$renderer !== void 0 ? _opts$renderer : "canvas";
            logLevel = (_opts$logLevel = opts2.logLevel) !== null && _opts$logLevel !== void 0 ? _opts$logLevel : vega.Warn;
            downloadFileName = (_opts$downloadFileNam = opts2.downloadFileName) !== null && _opts$downloadFileNam !== void 0 ? _opts$downloadFileNam : "visualization";
            element3 = typeof el === "string" ? document.querySelector(el) : el;
            if (element3) {
              _context4.next = 12;
              break;
            }
            throw new Error("".concat(el, " does not exist"));
          case 12:
            if (opts2.defaultStyle !== false) {
              ID = "vega-embed-style";
              _getRoot = getRoot(element3), root = _getRoot.root, rootContainer = _getRoot.rootContainer;
              if (!root.getElementById(ID)) {
                style2 = document.createElement("style");
                style2.id = ID;
                style2.innerHTML = opts2.defaultStyle === void 0 || opts2.defaultStyle === true ? embedStyle.toString() : opts2.defaultStyle;
                rootContainer.appendChild(style2);
              }
            }
            mode = guessMode(spec, opts2.mode);
            vgSpec = PREPROCESSOR[mode](spec, config);
            if (mode === "vega-lite") {
              if (vgSpec.$schema) {
                parsed = parser_module_default(vgSpec.$schema);
                if (!satisfies_1(VERSION.vega, "^".concat(parsed.version.slice(1)))) {
                  console.warn("The compiled spec uses Vega ".concat(parsed.version, ", but current version is v").concat(VERSION.vega, "."));
                }
              }
            }
            element3.classList.add("vega-embed");
            if (actions) {
              element3.classList.add("has-actions");
            }
            element3.innerHTML = "";
            container = element3;
            if (actions) {
              chartWrapper = document.createElement("div");
              chartWrapper.classList.add(CHART_WRAPPER_CLASS);
              element3.appendChild(chartWrapper);
              container = chartWrapper;
            }
            patch2 = opts2.patch;
            if (patch2) {
              vgSpec = patch2 instanceof Function ? patch2(vgSpec) : applyPatch(vgSpec, patch2, true, false).newDocument;
            }
            if (opts2.formatLocale) {
              vega.formatLocale(opts2.formatLocale);
            }
            if (opts2.timeFormatLocale) {
              vega.timeFormatLocale(opts2.timeFormatLocale);
            }
            if (opts2.expressionFunctions) {
              for (name4 in opts2.expressionFunctions) {
                expressionFunction2 = opts2.expressionFunctions[name4];
                if ("fn" in expressionFunction2) {
                  vega.expressionFunction(name4, expressionFunction2.fn, expressionFunction2["visitor"]);
                } else if (expressionFunction2 instanceof Function) {
                  vega.expressionFunction(name4, expressionFunction2);
                }
              }
            }
            ast = opts2.ast;
            runtime2 = vega.parse(vgSpec, mode === "vega-lite" ? {} : config, {
              ast
            });
            view = new (opts2.viewClass || vega.View)(runtime2, _objectSpread({
              loader: loader2,
              logLevel,
              renderer
            }, ast ? {
              expr: (_ref = (_expressionInterprete = vega.expressionInterpreter) !== null && _expressionInterprete !== void 0 ? _expressionInterprete : opts2.expr) !== null && _ref !== void 0 ? _ref : expression2
            } : {}));
            view.addSignalListener("autosize", (_, autosize) => {
              var type3 = autosize.type;
              if (type3 == "fit-x") {
                container.classList.add("fit-x");
                container.classList.remove("fit-y");
              } else if (type3 == "fit-y") {
                container.classList.remove("fit-x");
                container.classList.add("fit-y");
              } else if (type3 == "fit") {
                container.classList.add("fit-x", "fit-y");
              } else {
                container.classList.remove("fit-x", "fit-y");
              }
            });
            if (opts2.tooltip !== false) {
              handler = isTooltipHandler(opts2.tooltip) ? opts2.tooltip : (
                // user provided boolean true or tooltip options
                new Handler2(opts2.tooltip === true ? {} : opts2.tooltip).call
              );
              view.tooltip(handler);
            }
            hover2 = opts2.hover;
            if (hover2 === void 0) {
              hover2 = mode === "vega";
            }
            if (hover2) {
              _ref2 = typeof hover2 === "boolean" ? {} : hover2, hoverSet = _ref2.hoverSet, updateSet = _ref2.updateSet;
              view.hover(hoverSet, updateSet);
            }
            if (opts2) {
              if (opts2.width != null) {
                view.width(opts2.width);
              }
              if (opts2.height != null) {
                view.height(opts2.height);
              }
              if (opts2.padding != null) {
                view.padding(opts2.padding);
              }
            }
            _context4.next = 37;
            return view.initialize(container, opts2.bind).runAsync();
          case 37:
            if (actions !== false) {
              wrapper = element3;
              if (opts2.defaultStyle !== false) {
                details = document.createElement("details");
                details.title = i18n.CLICK_TO_VIEW_ACTIONS;
                element3.append(details);
                wrapper = details;
                summary = document.createElement("summary");
                summary.innerHTML = SVG_CIRCLES;
                details.append(summary);
                documentClickHandler = (ev) => {
                  if (!details.contains(ev.target)) {
                    details.removeAttribute("open");
                  }
                };
                document.addEventListener("click", documentClickHandler);
              }
              ctrl = document.createElement("div");
              wrapper.append(ctrl);
              ctrl.classList.add("vega-actions");
              if (actions === true || actions.export !== false) {
                _iterator = _createForOfIteratorHelper(["svg", "png"]);
                try {
                  _loop = function _loop2() {
                    var ext = _step.value;
                    if (actions === true || actions.export === true || actions.export[ext]) {
                      var i18nExportAction = i18n["".concat(ext.toUpperCase(), "_ACTION")];
                      var exportLink = document.createElement("a");
                      exportLink.text = i18nExportAction;
                      exportLink.href = "#";
                      exportLink.target = "_blank";
                      exportLink.download = "".concat(downloadFileName, ".").concat(ext);
                      exportLink.addEventListener("mousedown", function() {
                        var _ref3 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(e2) {
                          var url;
                          return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  e2.preventDefault();
                                  _context3.next = 3;
                                  return view.toImageURL(ext, opts2.scaleFactor);
                                case 3:
                                  url = _context3.sent;
                                  this.href = url;
                                case 5:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _callee3, this);
                        }));
                        return function(_x7) {
                          return _ref3.apply(this, arguments);
                        };
                      }());
                      ctrl.append(exportLink);
                    }
                  };
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    _loop();
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              if (actions === true || actions.source !== false) {
                viewSourceLink = document.createElement("a");
                viewSourceLink.text = i18n.SOURCE_ACTION;
                viewSourceLink.href = "#";
                viewSourceLink.addEventListener("click", function(e2) {
                  var _opts$sourceHeader, _opts$sourceFooter;
                  viewSource((0, import_json_stringify_pretty_compact.default)(spec), (_opts$sourceHeader = opts2.sourceHeader) !== null && _opts$sourceHeader !== void 0 ? _opts$sourceHeader : "", (_opts$sourceFooter = opts2.sourceFooter) !== null && _opts$sourceFooter !== void 0 ? _opts$sourceFooter : "", mode);
                  e2.preventDefault();
                });
                ctrl.append(viewSourceLink);
              }
              if (mode === "vega-lite" && (actions === true || actions.compiled !== false)) {
                compileLink = document.createElement("a");
                compileLink.text = i18n.COMPILED_ACTION;
                compileLink.href = "#";
                compileLink.addEventListener("click", function(e2) {
                  var _opts$sourceHeader2, _opts$sourceFooter2;
                  viewSource((0, import_json_stringify_pretty_compact.default)(vgSpec), (_opts$sourceHeader2 = opts2.sourceHeader) !== null && _opts$sourceHeader2 !== void 0 ? _opts$sourceHeader2 : "", (_opts$sourceFooter2 = opts2.sourceFooter) !== null && _opts$sourceFooter2 !== void 0 ? _opts$sourceFooter2 : "", "vega");
                  e2.preventDefault();
                });
                ctrl.append(compileLink);
              }
              if (actions === true || actions.editor !== false) {
                editorUrl = (_opts$editorUrl = opts2.editorUrl) !== null && _opts$editorUrl !== void 0 ? _opts$editorUrl : "https://vega.github.io/editor/";
                editorLink = document.createElement("a");
                editorLink.text = i18n.EDITOR_ACTION;
                editorLink.href = "#";
                editorLink.addEventListener("click", function(e2) {
                  post(window, editorUrl, {
                    config,
                    mode,
                    renderer,
                    spec: (0, import_json_stringify_pretty_compact.default)(spec)
                  });
                  e2.preventDefault();
                });
                ctrl.append(editorLink);
              }
            }
            return _context4.abrupt("return", {
              view,
              spec,
              vgSpec,
              finalize: finalize2,
              embedOptions: opts2
            });
          case 39:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _embed3.apply(this, arguments);
}

export {
  version5 as version,
  vega,
  _vegaLite,
  DEFAULT_ACTIONS,
  guessMode,
  embed
};
/*! Bundled license information:

fast-json-patch/module/helpers.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

fast-json-patch/module/duplex.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   *)

vega-tooltip/build/vega-tooltip.module.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-RXXZQR4D.js.map
